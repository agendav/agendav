(function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
})(this, function() {
    "use strict";
    var hookCallback;
    function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function isObjectEmpty(obj) {
        var k;
        for (k in obj) {
            return false;
        }
        return true;
    }
    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }
        if (hasOwnProp(b, "toString")) {
            a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
            a.valueOf = b.valueOf;
        }
        return a;
    }
    function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            meridiem: null
        };
    }
    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }
    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function(fun) {
            var t = Object(this);
            var len = t.length >>> 0;
            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }
            return false;
        };
    }
    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function(i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict) {
                isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }
            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }
    function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }
        return m;
    }
    function isUndefined(input) {
        return input === void 0;
    }
    var momentProperties = utils_hooks__hooks.momentProperties = [];
    function copyConfig(to, from) {
        var i, prop, val;
        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }
        return to;
    }
    var updateInProgress = false;
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }
    function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function absFloor(number) {
        if (number < 0) {
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }
        return value;
    }
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }
    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
            console.warn("Deprecation warning: " + msg);
        }
    }
    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
            if (utils_hooks__hooks.deprecationHandler != null) {
                utils_hooks__hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = "";
                    if (typeof arguments[i] === "object") {
                        arg += "\n[" + i + "] ";
                        for (var key in arguments[0]) {
                            arg += key + ": " + arguments[0][key] + ", ";
                        }
                        arg = arg.slice(0, -2);
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }
    utils_hooks__hooks.suppressDeprecationWarnings = false;
    utils_hooks__hooks.deprecationHandler = null;
    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function locale_set__set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this["_" + i] = prop;
            }
        }
        this._config = config;
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }
    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }
    var keys;
    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function(obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }
    var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    };
    function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now) : output;
    }
    var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
            return format;
        }
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        });
        return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
        return this._invalidDate;
    }
    var defaultOrdinal = "%d";
    var defaultOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
        return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    };
    function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }
        return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({
                unit: u,
                priority: priorities[u]
            });
        }
        units.sort(function(a, b) {
            return a.priority - b.priority;
        });
        return units;
    }
    function makeGetSet(unit, keepTime) {
        return function(value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }
    function get_set__get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function get_set__set(mom, unit, value) {
        if (mom.isValid()) {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
    }
    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }
    function stringSet(units, value) {
        if (typeof units === "object") {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {};
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === "string") {
            func = function() {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function() {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }
    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }
        return function(mom) {
            var output = "", i;
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
    }
    function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }
        return format;
    }
    var match1 = /\d/;
    var match2 = /\d\d/;
    var match3 = /\d{3}/;
    var match4 = /\d{4}/;
    var match6 = /[+-]?\d{6}/;
    var match1to2 = /\d\d?/;
    var match3to4 = /\d\d\d\d?/;
    var match5to6 = /\d\d\d\d\d\d?/;
    var match1to3 = /\d{1,3}/;
    var match1to4 = /\d{1,4}/;
    var match1to6 = /[+-]?\d{1,6}/;
    var matchUnsigned = /\d+/;
    var matchSigned = /[+-]?\d+/;
    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
    var regexes = {};
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
    }
    function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === "string") {
            token = [ token ];
        }
        if (typeof callback === "number") {
            func = function(input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }
    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;
    var indexOf;
    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function(o) {
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    });
    addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });
    addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    });
    addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_");
    function localeMonths(m, format) {
        if (!m) {
            return this._months;
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()];
    }
    var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
    function localeMonthsShort(m, format) {
        if (!m) {
            return this._monthsShort;
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()];
    }
    function units_month__handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = create_utc__createUTC([ 2e3, i ]);
                this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === "MMM") {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === "MMM") {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
            return units_month__handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
            mom = create_utc__createUTC([ 2e3, i ]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
                regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
            return mom;
        }
        if (typeof value === "string") {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                if (typeof value !== "number") {
                    return mom;
                }
            }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
    }
    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, "Month");
        }
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, "_monthsShortRegex")) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }
    var defaultMonthsRegex = matchWord;
    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, "_monthsRegex")) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, "_monthsRegex")) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
            mom = create_utc__createUTC([ 2e3, i ]);
            shortPieces.push(this.monthsShort(mom, ""));
            longPieces.push(this.months(mom, ""));
            mixedPieces.push(this.months(mom, ""));
            mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? "" + y : "+" + y;
    });
    addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    });
    addFormatToken(0, [ "YYYY", 4 ], 0, "year");
    addFormatToken(0, [ "YYYYY", 5 ], 0, "year");
    addFormatToken(0, [ "YYYYYY", 6, true ], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR);
    addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    utils_hooks__hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }
    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }
    function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }
        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }
        return {
            week: resWeek,
            year: resYear
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", [ "ww", 2 ], "wo", "week");
    addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });
    addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    function parseWeekday(input, locale) {
        if (typeof input !== "string") {
            return input;
        }
        if (!isNaN(input)) {
            return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === "number") {
            return input;
        }
        return null;
    }
    function parseIsoWeekday(input, locale) {
        if (typeof input === "string") {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
    function localeWeekdays(m, format) {
        if (!m) {
            return this._weekdays;
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? "format" : "standalone"][m.day()];
    }
    var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
    function localeWeekdaysShort(m) {
        return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    function localeWeekdaysMin(m) {
        return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];
            for (i = 0; i < 7; ++i) {
                mom = create_utc__createUTC([ 2e3, 1 ]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            }
        }
        if (strict) {
            if (format === "dddd") {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === "ddd") {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === "dddd") {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === "ddd") {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
            return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
            mom = create_utc__createUTC([ 2e3, 1 ]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", ".?") + "$", "i");
                this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", ".?") + "$", "i");
                this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", ".?") + "$", "i");
            }
            if (!this._weekdaysParse[i]) {
                regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
        } else {
            return day;
        }
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }
    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }
    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, "_weekdaysShortRegex")) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }
    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, "_weekdaysRegex")) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, "_weekdaysMinRegex")) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            mom = create_utc__createUTC([ 2e3, 1 ]).day(i);
            minp = this.weekdaysMin(mom, "");
            shortp = this.weekdaysShort(mom, "");
            longp = this.weekdays(mom, "");
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    addFormatToken("H", [ "HH", 2 ], 0, "hour");
    addFormatToken("h", [ "hh", 2 ], 0, hFormat);
    addFormatToken("k", [ "kk", 2 ], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken([ "H", "HH" ], HOUR);
    addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? "pm" : "PM";
        } else {
            return isLower ? "am" : "AM";
        }
    }
    var getSetHour = makeGetSet("Hours", true);
    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {};
    var globalLocale;
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
            split = normalizeLocale(names[i]).split("-");
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split("-") : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join("-"));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && typeof module !== "undefined" && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require("./locale/" + name);
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }
    function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            } else {
                data = defineLocale(key, values);
            }
            if (data) {
                globalLocale = data;
            }
        }
        return globalLocale._abbr;
    }
    function defineLocale(name, config) {
        if (config !== null) {
            var parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change " + "an existing locale. moment.defineLocale(localeName, " + "config) should only be used for creating a new locale " + "See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    deprecateSimple("parentLocaleUndefined", "specified parentLocale is not defined yet. See http://momentjs.com/guides/#/warnings/parent-locale/");
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));
            locale_locales__getSetGlobalLocale(name);
            return locales[name];
        } else {
            delete locales[name];
            return null;
        }
    }
    function updateLocale(name, config) {
        if (config != null) {
            var locale, parentConfig = baseConfig;
            if (locales[name] != null) {
                parentConfig = locales[name]._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;
            locale_locales__getSetGlobalLocale(name);
        } else {
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }
    function locale_locales__getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }
        if (!key) {
            return globalLocale;
        }
        if (!isArray(key)) {
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [ key ];
        }
        return chooseLocale(key);
    }
    function locale_locales__listLocales() {
        return keys(locales);
    }
    function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }
            getParsingFlags(m).overflow = overflow;
        }
        return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, false ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, false ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, false ], [ "YYYYDDD", /\d{7}/ ] ];
    var isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        timeFormat = (match[2] || " ") + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = "Z";
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }
        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }
    utils_hooks__hooks.createFromInputFallback = deprecate("value provided is not in a recognized ISO format. moment construction falls back to js Date(), " + "which is not reliable across all browsers and versions. Non ISO date formats are " + "discouraged and will be removed in an upcoming major release. Please refer to " + "http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    });
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ];
        }
        return [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
    }
    function configFromArray(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
            return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }
            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }
        for (;i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;
            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);
            if (w.d != null) {
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }
    utils_hooks__hooks.ISO_8601 = function() {};
    function configFromStringAndFormat(config) {
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            return hour;
        }
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);
            if (!valid__isValid(tempConfig)) {
                continue;
            }
            currentScore += getParsingFlags(tempConfig).charsLeftOver;
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
            getParsingFlags(tempConfig).score = currentScore;
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (config._d) {
            return;
        }
        var i = normalizeObjectUnits(config._i);
        config._a = map([ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ], function(obj) {
            return obj && parseInt(obj, 10);
        });
        configFromArray(config);
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            res.add(1, "d");
            res._nextDay = undefined;
        }
        return res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        config._locale = config._locale || locale_locales__getLocale(config._l);
        if (input === null || format === undefined && input === "") {
            return valid__createInvalid({
                nullInput: true
            });
        }
        if (typeof input === "string") {
            config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (isDate(input)) {
            config._d = input;
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }
        if (!valid__isValid(config)) {
            config._d = null;
        }
        return config;
    }
    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof input === "object") {
            configFromObject(config);
        } else if (typeof input === "number") {
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (typeof locale === "boolean") {
            strict = locale;
            locale = undefined;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
            input = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
    }
    function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }
    var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = local__createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return valid__createInvalid();
        }
    });
    var prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = local__createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return valid__createInvalid();
        }
    });
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    }
    var now = function() {
        return Date.now ? Date.now() : +new Date();
    };
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1e3 * 60 * 60;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = locale_locales__getLocale();
        this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset();
            var sign = "+";
            if (offset < 0) {
                offset = -offset;
                sign = "-";
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher) || [];
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
            res._d.setTime(res._d.valueOf() + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }
    function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }
    utils_hooks__hooks.updateOffset = function() {};
    function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0, localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === "string") {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, "m");
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, "m"), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }
    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== "string") {
                input = -input;
            }
            this.utcOffset(input, keepLocalTime);
            return this;
        } else {
            return -this.utcOffset();
        }
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
                this.subtract(getDateOffset(this), "m");
            }
        }
        return this;
    }
    function setOffsetToParsedOffset() {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === "string") {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone === 0) {
                this.utcOffset(0, true);
            } else {
                this.utcOffset(offsetFromString(matchOffset, this._i));
            }
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }
        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }
        return this._isDSTShifted;
    }
    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
    var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
    function create__createDuration(input, key) {
        var duration = input, match = null, sign, ret, diffRes;
        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === "number") {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign)
            };
        } else if (duration == null) {
            duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
            ret._locale = input._locale;
        }
        return ret;
    }
    create__createDuration.fn = Duration.prototype;
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
            --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
    }
    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {
                milliseconds: 0,
                months: 0
            };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }
        return res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). " + "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
                tmp = val;
                val = period;
                period = tmp;
            }
            val = typeof val === "string" ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }
    function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
        if (!mom.isValid()) {
            return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, "Date", get_set__get(mom, "Date") + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }
    var add_subtract__add = createAdder(1, "add");
    var add_subtract__subtract = createAdder(-1, "subtract");
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, "days", true);
        return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
    }
    function moment_calendar__calendar(time, formats) {
        var now = time || local__createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = utils_hooks__hooks.calendarFormat(this, sod) || "sameElse";
        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : "millisecond");
        if (units === "millisecond") {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : "millisecond");
        if (units === "millisecond") {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }
    function isBetween(from, to, units, inclusivity) {
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ")" ? this.isBefore(to, units) : !this.isAfter(to, units));
    }
    function isSame(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || "millisecond");
        if (units === "millisecond") {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
        var that, zoneDelta, delta, output;
        if (!this.isValid()) {
            return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
            return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        if (units === "year" || units === "month" || units === "quarter") {
            output = monthDiff(this, that);
            if (units === "quarter") {
                output = output / 3;
            } else if (units === "year") {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === "second" ? delta / 1e3 : units === "minute" ? delta / 6e4 : units === "hour" ? delta / 36e5 : units === "day" ? (delta - zoneDelta) / 864e5 : units === "week" ? (delta - zoneDelta) / 6048e5 : delta;
        }
        return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
            adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
    }
    utils_hooks__hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    utils_hooks__hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
        } else {
            return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
        }
    }
    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || local__createLocal(time).isValid())) {
            return create__createDuration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || local__createLocal(time).isValid())) {
            return create__createDuration({
                from: this,
                to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }
    function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    });
    function localeData() {
        return this._locale;
    }
    function startOf(units) {
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            this.month(0);

          case "quarter":
          case "month":
            this.date(1);

          case "week":
          case "isoWeek":
          case "day":
          case "date":
            this.hours(0);

          case "hour":
            this.minutes(0);

          case "minute":
            this.seconds(0);

          case "second":
            this.milliseconds(0);
        }
        if (units === "week") {
            this.weekday(0);
        }
        if (units === "isoWeek") {
            this.isoWeekday(1);
        }
        if (units === "quarter") {
            this.month(Math.floor(this.month() / 3) * 3);
        }
        return this;
    }
    function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === "millisecond") {
            return this;
        }
        if (units === "date") {
            units = "day";
        }
        return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
    }
    function to_type__valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
        return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function moment_valid__isValid() {
        return valid__isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    });
    addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", [ "DD", 2 ], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });
    addParseToken([ "D", "DD" ], DATE);
    addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", [ "mm", 2 ], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", [ "ss", 2 ], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken([ "s", "ss" ], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, [ "SSS", 3 ], 0, "millisecond");
    addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return this.millisecond() * 10;
    });
    addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return this.millisecond() * 100;
    });
    addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return this.millisecond() * 1e3;
    });
    addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return this.millisecond() * 1e4;
    });
    addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return this.millisecond() * 1e5;
    });
    addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token;
    for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
    }
    var getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var momentPrototype__proto = Moment.prototype;
    momentPrototype__proto.add = add_subtract__add;
    momentPrototype__proto.calendar = moment_calendar__calendar;
    momentPrototype__proto.clone = clone;
    momentPrototype__proto.diff = diff;
    momentPrototype__proto.endOf = endOf;
    momentPrototype__proto.format = format;
    momentPrototype__proto.from = from;
    momentPrototype__proto.fromNow = fromNow;
    momentPrototype__proto.to = to;
    momentPrototype__proto.toNow = toNow;
    momentPrototype__proto.get = stringGet;
    momentPrototype__proto.invalidAt = invalidAt;
    momentPrototype__proto.isAfter = isAfter;
    momentPrototype__proto.isBefore = isBefore;
    momentPrototype__proto.isBetween = isBetween;
    momentPrototype__proto.isSame = isSame;
    momentPrototype__proto.isSameOrAfter = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore = isSameOrBefore;
    momentPrototype__proto.isValid = moment_valid__isValid;
    momentPrototype__proto.lang = lang;
    momentPrototype__proto.locale = locale;
    momentPrototype__proto.localeData = localeData;
    momentPrototype__proto.max = prototypeMax;
    momentPrototype__proto.min = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set = stringSet;
    momentPrototype__proto.startOf = startOf;
    momentPrototype__proto.subtract = add_subtract__subtract;
    momentPrototype__proto.toArray = toArray;
    momentPrototype__proto.toObject = toObject;
    momentPrototype__proto.toDate = toDate;
    momentPrototype__proto.toISOString = moment_format__toISOString;
    momentPrototype__proto.toJSON = toJSON;
    momentPrototype__proto.toString = toString;
    momentPrototype__proto.unix = unix;
    momentPrototype__proto.valueOf = to_type__valueOf;
    momentPrototype__proto.creationData = creationData;
    momentPrototype__proto.year = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;
    momentPrototype__proto.weekYear = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
    momentPrototype__proto.month = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;
    momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
    momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
    momentPrototype__proto.weeksInYear = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
    momentPrototype__proto.date = getSetDayOfMonth;
    momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
    momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear = getSetDayOfYear;
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
    momentPrototype__proto.utcOffset = getSetOffset;
    momentPrototype__proto.utc = setOffsetToUTC;
    momentPrototype__proto.local = setOffsetToLocal;
    momentPrototype__proto.parseZone = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST = isDaylightSavingTime;
    momentPrototype__proto.isLocal = isLocal;
    momentPrototype__proto.isUtcOffset = isUtcOffset;
    momentPrototype__proto.isUtc = isUtc;
    momentPrototype__proto.isUTC = isUtc;
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;
    momentPrototype__proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
    momentPrototype__proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
    momentPrototype__proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
    momentPrototype__proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
    momentPrototype__proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
    var momentPrototype = momentPrototype__proto;
    function moment__createUnix(input) {
        return local__createLocal(input * 1e3);
    }
    function moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    var prototype__proto = Locale.prototype;
    prototype__proto.calendar = locale_calendar__calendar;
    prototype__proto.longDateFormat = longDateFormat;
    prototype__proto.invalidDate = invalidDate;
    prototype__proto.ordinal = ordinal;
    prototype__proto.preparse = preParsePostFormat;
    prototype__proto.postformat = preParsePostFormat;
    prototype__proto.relativeTime = relative__relativeTime;
    prototype__proto.pastFuture = pastFuture;
    prototype__proto.set = locale_set__set;
    prototype__proto.months = localeMonths;
    prototype__proto.monthsShort = localeMonthsShort;
    prototype__proto.monthsParse = localeMonthsParse;
    prototype__proto.monthsRegex = monthsRegex;
    prototype__proto.monthsShortRegex = monthsShortRegex;
    prototype__proto.week = localeWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
    prototype__proto.weekdays = localeWeekdays;
    prototype__proto.weekdaysMin = localeWeekdaysMin;
    prototype__proto.weekdaysShort = localeWeekdaysShort;
    prototype__proto.weekdaysParse = localeWeekdaysParse;
    prototype__proto.weekdaysRegex = weekdaysRegex;
    prototype__proto.weekdaysShortRegex = weekdaysShortRegex;
    prototype__proto.weekdaysMinRegex = weekdaysMinRegex;
    prototype__proto.isPM = localeIsPM;
    prototype__proto.meridiem = localeMeridiem;
    function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (typeof format === "number") {
            index = format;
            format = undefined;
        }
        format = format || "";
        if (index != null) {
            return lists__get(format, index, field, "month");
        }
        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = lists__get(format, i, field, "month");
        }
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === "boolean") {
            if (typeof format === "number") {
                index = format;
                format = undefined;
            }
            format = format || "";
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;
            if (typeof format === "number") {
                index = format;
                format = undefined;
            }
            format = format || "";
        }
        var locale = locale_locales__getLocale(), shift = localeSorted ? locale._week.dow : 0;
        if (index != null) {
            return lists__get(format, (index + shift) % 7, field, "day");
        }
        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = lists__get(format, (i + shift) % 7, field, "day");
        }
        return out;
    }
    function lists__listMonths(format, index) {
        return listMonthsImpl(format, index, "months");
    }
    function lists__listMonthsShort(format, index) {
        return listMonthsImpl(format, index, "monthsShort");
    }
    function lists__listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdays");
    }
    function lists__listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
    }
    function lists__listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
    }
    locale_locales__getSetGlobalLocale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
            return number + output;
        }
    });
    utils_hooks__hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", locale_locales__getLocale);
    var mathAbs = Math.abs;
    function duration_abs__abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
    }
    function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
    }
    function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }
    function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }
    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }
    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;
        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }
        data.milliseconds = milliseconds % 1e3;
        seconds = absFloor(milliseconds / 1e3);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
    }
    function daysToMonths(days) {
        return days * 4800 / 146097;
    }
    function monthsToDays(months) {
        return months * 146097 / 4800;
    }
    function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "year") {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === "month" ? months : months / 12;
        } else {
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
              case "week":
                return days / 7 + milliseconds / 6048e5;

              case "day":
                return days + milliseconds / 864e5;

              case "hour":
                return days * 24 + milliseconds / 36e5;

              case "minute":
                return days * 1440 + milliseconds / 6e4;

              case "second":
                return days * 86400 + milliseconds / 1e3;

              case "millisecond":
                return Math.floor(days * 864e5) + milliseconds;

              default:
                throw new Error("Unknown unit " + units);
            }
        }
    }
    function duration_as__valueOf() {
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    var asMilliseconds = makeAs("ms");
    var asSeconds = makeAs("s");
    var asMinutes = makeAs("m");
    var asHours = makeAs("h");
    var asDays = makeAs("d");
    var asWeeks = makeAs("w");
    var asMonths = makeAs("M");
    var asYears = makeAs("y");
    function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + "s"]();
    }
    function makeGetter(name) {
        return function() {
            return this._data[name];
        };
    }
    var milliseconds = makeGetter("milliseconds");
    var seconds = makeGetter("seconds");
    var minutes = makeGetter("minutes");
    var hours = makeGetter("hours");
    var days = makeGetter("days");
    var months = makeGetter("months");
    var years = makeGetter("years");
    function weeks() {
        return absFloor(this.days() / 7);
    }
    var round = Math.round;
    var thresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as("s"));
        var minutes = round(duration.as("m"));
        var hours = round(duration.as("h"));
        var days = round(duration.as("d"));
        var months = round(duration.as("M"));
        var years = round(duration.as("y"));
        var a = seconds < thresholds.s && [ "s", seconds ] || minutes <= 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours <= 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days <= 1 && [ "d" ] || days < thresholds.d && [ "dd", days ] || months <= 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years <= 1 && [ "y" ] || [ "yy", years ];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }
    function duration_humanize__getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === "function") {
            round = roundingFunction;
            return true;
        }
        return false;
    }
    function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }
    function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
    }
    var iso_string__abs = Math.abs;
    function iso_string__toISOString() {
        var seconds = iso_string__abs(this._milliseconds) / 1e3;
        var days = iso_string__abs(this._days);
        var months = iso_string__abs(this._months);
        var minutes, hours, years;
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();
        if (!total) {
            return "P0D";
        }
        return (total < 0 ? "-" : "") + "P" + (Y ? Y + "Y" : "") + (M ? M + "M" : "") + (D ? D + "D" : "") + (h || m || s ? "T" : "") + (h ? h + "H" : "") + (m ? m + "M" : "") + (s ? s + "S" : "");
    }
    var duration_prototype__proto = Duration.prototype;
    duration_prototype__proto.abs = duration_abs__abs;
    duration_prototype__proto.add = duration_add_subtract__add;
    duration_prototype__proto.subtract = duration_add_subtract__subtract;
    duration_prototype__proto.as = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds = asSeconds;
    duration_prototype__proto.asMinutes = asMinutes;
    duration_prototype__proto.asHours = asHours;
    duration_prototype__proto.asDays = asDays;
    duration_prototype__proto.asWeeks = asWeeks;
    duration_prototype__proto.asMonths = asMonths;
    duration_prototype__proto.asYears = asYears;
    duration_prototype__proto.valueOf = duration_as__valueOf;
    duration_prototype__proto._bubble = bubble;
    duration_prototype__proto.get = duration_get__get;
    duration_prototype__proto.milliseconds = milliseconds;
    duration_prototype__proto.seconds = seconds;
    duration_prototype__proto.minutes = minutes;
    duration_prototype__proto.hours = hours;
    duration_prototype__proto.days = days;
    duration_prototype__proto.weeks = weeks;
    duration_prototype__proto.months = months;
    duration_prototype__proto.years = years;
    duration_prototype__proto.humanize = humanize;
    duration_prototype__proto.toISOString = iso_string__toISOString;
    duration_prototype__proto.toString = iso_string__toISOString;
    duration_prototype__proto.toJSON = iso_string__toISOString;
    duration_prototype__proto.locale = locale;
    duration_prototype__proto.localeData = localeData;
    duration_prototype__proto.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", iso_string__toISOString);
    duration_prototype__proto.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    });
    utils_hooks__hooks.version = "2.15.2";
    setHookCallback(local__createLocal);
    utils_hooks__hooks.fn = momentPrototype;
    utils_hooks__hooks.min = min;
    utils_hooks__hooks.max = max;
    utils_hooks__hooks.now = now;
    utils_hooks__hooks.utc = create_utc__createUTC;
    utils_hooks__hooks.unix = moment__createUnix;
    utils_hooks__hooks.months = lists__listMonths;
    utils_hooks__hooks.isDate = isDate;
    utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid = valid__createInvalid;
    utils_hooks__hooks.duration = create__createDuration;
    utils_hooks__hooks.isMoment = isMoment;
    utils_hooks__hooks.weekdays = lists__listWeekdays;
    utils_hooks__hooks.parseZone = moment__createInZone;
    utils_hooks__hooks.localeData = locale_locales__getLocale;
    utils_hooks__hooks.isDuration = isDuration;
    utils_hooks__hooks.monthsShort = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale = defineLocale;
    utils_hooks__hooks.updateLocale = updateLocale;
    utils_hooks__hooks.locales = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits = normalizeUnits;
    utils_hooks__hooks.relativeTimeRounding = duration_humanize__getSetRelativeTimeRounding;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.calendarFormat = getCalendarFormat;
    utils_hooks__hooks.prototype = momentPrototype;
    var _moment = utils_hooks__hooks;
    return _moment;
});

!function(a, b) {
    "use strict";
    "function" == typeof define && define.amd ? define([ "moment" ], b) : "object" == typeof module && module.exports ? module.exports = b(require("moment")) : b(a.moment);
}(this, function(a) {
    "use strict";
    function b(a) {
        return a > 96 ? a - 87 : a > 64 ? a - 29 : a - 48;
    }
    function c(a) {
        var c, d = 0, e = a.split("."), f = e[0], g = e[1] || "", h = 1, i = 0, j = 1;
        for (45 === a.charCodeAt(0) && (d = 1, j = -1), d; d < f.length; d++) c = b(f.charCodeAt(d)), 
        i = 60 * i + c;
        for (d = 0; d < g.length; d++) h /= 60, c = b(g.charCodeAt(d)), i += c * h;
        return i * j;
    }
    function d(a) {
        for (var b = 0; b < a.length; b++) a[b] = c(a[b]);
    }
    function e(a, b) {
        for (var c = 0; c < b; c++) a[c] = Math.round((a[c - 1] || 0) + 6e4 * a[c]);
        a[b - 1] = 1 / 0;
    }
    function f(a, b) {
        var c, d = [];
        for (c = 0; c < b.length; c++) d[c] = a[b[c]];
        return d;
    }
    function g(a) {
        var b = a.split("|"), c = b[2].split(" "), g = b[3].split(""), h = b[4].split(" ");
        return d(c), d(g), d(h), e(h, g.length), {
            name: b[0],
            abbrs: f(b[1].split(" "), g),
            offsets: f(c, g),
            untils: h,
            population: 0 | b[5]
        };
    }
    function h(a) {
        a && this._set(g(a));
    }
    function i(a) {
        var b = a.toTimeString(), c = b.match(/\([a-z ]+\)/i);
        c && c[0] ? (c = c[0].match(/[A-Z]/g), c = c ? c.join("") : void 0) : (c = b.match(/[A-Z]{3,5}/g), 
        c = c ? c[0] : void 0), "GMT" === c && (c = void 0), this.at = +a, this.abbr = c, 
        this.offset = a.getTimezoneOffset();
    }
    function j(a) {
        this.zone = a, this.offsetScore = 0, this.abbrScore = 0;
    }
    function k(a, b) {
        for (var c, d; d = 6e4 * ((b.at - a.at) / 12e4 | 0); ) c = new i(new Date(a.at + d)), 
        c.offset === a.offset ? a = c : b = c;
        return a;
    }
    function l() {
        var a, b, c, d = new Date().getFullYear() - 2, e = new i(new Date(d, 0, 1)), f = [ e ];
        for (c = 1; c < 48; c++) b = new i(new Date(d, c, 1)), b.offset !== e.offset && (a = k(e, b), 
        f.push(a), f.push(new i(new Date(a.at + 6e4)))), e = b;
        for (c = 0; c < 4; c++) f.push(new i(new Date(d + c, 0, 1))), f.push(new i(new Date(d + c, 6, 1)));
        return f;
    }
    function m(a, b) {
        return a.offsetScore !== b.offsetScore ? a.offsetScore - b.offsetScore : a.abbrScore !== b.abbrScore ? a.abbrScore - b.abbrScore : b.zone.population - a.zone.population;
    }
    function n(a, b) {
        var c, e;
        for (d(b), c = 0; c < b.length; c++) e = b[c], I[e] = I[e] || {}, I[e][a] = !0;
    }
    function o(a) {
        var b, c, d, e = a.length, f = {}, g = [];
        for (b = 0; b < e; b++) {
            d = I[a[b].offset] || {};
            for (c in d) d.hasOwnProperty(c) && (f[c] = !0);
        }
        for (b in f) f.hasOwnProperty(b) && g.push(H[b]);
        return g;
    }
    function p() {
        try {
            var a = Intl.DateTimeFormat().resolvedOptions().timeZone;
            if (a) {
                var b = H[r(a)];
                if (b) return b;
                z("Moment Timezone found " + a + " from the Intl api, but did not have that data loaded.");
            }
        } catch (c) {}
        var d, e, f, g = l(), h = g.length, i = o(g), k = [];
        for (e = 0; e < i.length; e++) {
            for (d = new j(t(i[e]), h), f = 0; f < h; f++) d.scoreOffsetAt(g[f]);
            k.push(d);
        }
        return k.sort(m), k.length > 0 ? k[0].zone.name : void 0;
    }
    function q(a) {
        return D && !a || (D = p()), D;
    }
    function r(a) {
        return (a || "").toLowerCase().replace(/\//g, "_");
    }
    function s(a) {
        var b, c, d, e;
        for ("string" == typeof a && (a = [ a ]), b = 0; b < a.length; b++) d = a[b].split("|"), 
        c = d[0], e = r(c), F[e] = a[b], H[e] = c, d[5] && n(e, d[2].split(" "));
    }
    function t(a, b) {
        a = r(a);
        var c, d = F[a];
        return d instanceof h ? d : "string" == typeof d ? (d = new h(d), F[a] = d, d) : G[a] && b !== t && (c = t(G[a], t)) ? (d = F[a] = new h(), 
        d._set(c), d.name = H[a], d) : null;
    }
    function u() {
        var a, b = [];
        for (a in H) H.hasOwnProperty(a) && (F[a] || F[G[a]]) && H[a] && b.push(H[a]);
        return b.sort();
    }
    function v(a) {
        var b, c, d, e;
        for ("string" == typeof a && (a = [ a ]), b = 0; b < a.length; b++) c = a[b].split("|"), 
        d = r(c[0]), e = r(c[1]), G[d] = e, H[d] = c[0], G[e] = d, H[e] = c[1];
    }
    function w(a) {
        s(a.zones), v(a.links), A.dataVersion = a.version;
    }
    function x(a) {
        return x.didShowError || (x.didShowError = !0, z("moment.tz.zoneExists('" + a + "') has been deprecated in favor of !moment.tz.zone('" + a + "')")), 
        !!t(a);
    }
    function y(a) {
        return !(!a._a || void 0 !== a._tzm);
    }
    function z(a) {
        "undefined" != typeof console && "function" == typeof console.error && console.error(a);
    }
    function A(b) {
        var c = Array.prototype.slice.call(arguments, 0, -1), d = arguments[arguments.length - 1], e = t(d), f = a.utc.apply(null, c);
        return e && !a.isMoment(b) && y(f) && f.add(e.parse(f), "minutes"), f.tz(d), f;
    }
    function B(a) {
        return function() {
            return this._z ? this._z.abbr(this) : a.call(this);
        };
    }
    function C(a) {
        return function() {
            return this._z = null, a.apply(this, arguments);
        };
    }
    if (void 0 !== a.tz) return z("Moment Timezone " + a.tz.version + " was already loaded " + (a.tz.dataVersion ? "with data from " : "without any data") + a.tz.dataVersion), 
    a;
    var D, E = "0.5.9", F = {}, G = {}, H = {}, I = {}, J = a.version.split("."), K = +J[0], L = +J[1];
    (K < 2 || 2 === K && L < 6) && z("Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js " + a.version + ". See momentjs.com"), 
    h.prototype = {
        _set: function(a) {
            this.name = a.name, this.abbrs = a.abbrs, this.untils = a.untils, this.offsets = a.offsets, 
            this.population = a.population;
        },
        _index: function(a) {
            var b, c = +a, d = this.untils;
            for (b = 0; b < d.length; b++) if (c < d[b]) return b;
        },
        parse: function(a) {
            var b, c, d, e, f = +a, g = this.offsets, h = this.untils, i = h.length - 1;
            for (e = 0; e < i; e++) if (b = g[e], c = g[e + 1], d = g[e ? e - 1 : e], b < c && A.moveAmbiguousForward ? b = c : b > d && A.moveInvalidForward && (b = d), 
            f < h[e] - 6e4 * b) return g[e];
            return g[i];
        },
        abbr: function(a) {
            return this.abbrs[this._index(a)];
        },
        offset: function(a) {
            return this.offsets[this._index(a)];
        }
    }, j.prototype.scoreOffsetAt = function(a) {
        this.offsetScore += Math.abs(this.zone.offset(a.at) - a.offset), this.zone.abbr(a.at).replace(/[^A-Z]/g, "") !== a.abbr && this.abbrScore++;
    }, A.version = E, A.dataVersion = "", A._zones = F, A._links = G, A._names = H, 
    A.add = s, A.link = v, A.load = w, A.zone = t, A.zoneExists = x, A.guess = q, A.names = u, 
    A.Zone = h, A.unpack = g, A.unpackBase60 = c, A.needsOffset = y, A.moveInvalidForward = !0, 
    A.moveAmbiguousForward = !1;
    var M = a.fn;
    a.tz = A, a.defaultZone = null, a.updateOffset = function(b, c) {
        var d, e = a.defaultZone;
        void 0 === b._z && (e && y(b) && !b._isUTC && (b._d = a.utc(b._a)._d, b.utc().add(e.parse(b), "minutes")), 
        b._z = e), b._z && (d = b._z.offset(b), Math.abs(d) < 16 && (d /= 60), void 0 !== b.utcOffset ? b.utcOffset(-d, c) : b.zone(d, c));
    }, M.tz = function(b) {
        return b ? (this._z = t(b), this._z ? a.updateOffset(this) : z("Moment Timezone has no data for " + b + ". See http://momentjs.com/timezone/docs/#/data-loading/."), 
        this) : this._z ? this._z.name : void 0;
    }, M.zoneName = B(M.zoneName), M.zoneAbbr = B(M.zoneAbbr), M.utc = C(M.utc), a.tz.setDefault = function(b) {
        return (K < 2 || 2 === K && L < 9) && z("Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js " + a.version + "."), 
        a.defaultZone = b ? t(b) : null, a;
    };
    var N = a.momentProperties;
    return "[object Array]" === Object.prototype.toString.call(N) ? (N.push("_z"), N.push("_a")) : N && (N._z = null), 
    w({
        version: "2016i",
        zones: [ "Africa/Abidjan|GMT|0|0||48e5", "Africa/Khartoum|EAT|-30|0||51e5", "Africa/Algiers|CET|-10|0||26e5", "Africa/Lagos|WAT|-10|0||17e6", "Africa/Maputo|CAT|-20|0||26e5", "Africa/Cairo|EET EEST|-20 -30|010101010|1Cby0 Fb0 c10 8n0 8Nd0 gL0 e10 mn0|15e6", "Africa/Casablanca|WET WEST|0 -10|01010101010101010101010101010101010101010|1Cco0 Db0 1zd0 Lz0 1Nf0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 Rc0 11A0 e00 e00 U00 11A0 8o0 e00 11A0|32e5", "Europe/Paris|CET CEST|-10 -20|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e6", "Africa/Johannesburg|SAST|-20|0||84e5", "Africa/Tripoli|EET CET CEST|-20 -10 -20|0120|1IlA0 TA0 1o00|11e5", "Africa/Windhoek|WAST WAT|-20 -10|01010101010101010101010|1C1c0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0|32e4", "America/Adak|HST HDT|a0 90|01010101010101010101010|1BR00 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|326", "America/Anchorage|AKST AKDT|90 80|01010101010101010101010|1BQX0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|30e4", "America/Santo_Domingo|AST|40|0||29e5", "America/Araguaina|BRT BRST|30 20|010|1IdD0 Lz0|14e4", "America/Argentina/Buenos_Aires|ART|30|0|", "America/Asuncion|PYST PYT|30 40|01010101010101010101010|1C430 1a10 1fz0 1a10 1fz0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0|28e5", "America/Panama|EST|50|0||15e5", "America/Bahia|BRT BRST|30 20|010|1FJf0 Rb0|27e5", "America/Bahia_Banderas|MST CDT CST|70 50 60|01212121212121212121212|1C1l0 1nW0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|84e3", "America/Fortaleza|BRT|30|0||34e5", "America/Managua|CST|60|0||22e5", "America/Manaus|AMT|40|0||19e5", "America/Bogota|COT|50|0||90e5", "America/Denver|MST MDT|70 60|01010101010101010101010|1BQV0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e5", "America/Campo_Grande|AMST AMT|30 40|01010101010101010101010|1BIr0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10|77e4", "America/Cancun|CST CDT EST|60 50 50|010101010102|1C1k0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4", "America/Caracas|VET VET|4u 40|01|1QMT0|29e5", "America/Cayenne|GFT|30|0||58e3", "America/Chicago|CST CDT|60 50|01010101010101010101010|1BQU0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|92e5", "America/Chihuahua|MST MDT|70 60|01010101010101010101010|1C1l0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|81e4", "America/Phoenix|MST|70|0||42e5", "America/Los_Angeles|PST PDT|80 70|01010101010101010101010|1BQW0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e6", "America/New_York|EST EDT|50 40|01010101010101010101010|1BQT0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e6", "America/Rio_Branco|AMT ACT|40 50|01|1KLE0|31e4", "America/Fort_Nelson|PST PDT MST|80 70 70|010101010102|1BQW0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2", "America/Halifax|AST ADT|40 30|01010101010101010101010|1BQS0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|39e4", "America/Godthab|WGT WGST|30 20|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e3", "America/Goose_Bay|AST ADT|40 30|01010101010101010101010|1BQQ1 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|76e2", "America/Grand_Turk|EST EDT AST|50 40 40|0101010101012|1BQT0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2", "America/Guayaquil|ECT|50|0||27e5", "America/Guyana|GYT|40|0||80e4", "America/Havana|CST CDT|50 40|01010101010101010101010|1BQR0 1wo0 U00 1zc0 U00 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0|21e5", "America/La_Paz|BOT|40|0||19e5", "America/Lima|PET|50|0||11e6", "America/Mexico_City|CST CDT|60 50|01010101010101010101010|1C1k0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|20e6", "America/Metlakatla|PST AKST AKDT|80 90 80|012121212121|1PAa0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2", "America/Miquelon|PMST PMDT|30 20|01010101010101010101010|1BQR0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|61e2", "America/Montevideo|UYST UYT|20 30|010101010101|1BQQ0 1ld0 14n0 1ld0 14n0 1o10 11z0 1o10 11z0 1o10 11z0|17e5", "America/Noronha|FNT|20|0||30e2", "America/North_Dakota/Beulah|MST MDT CST CDT|70 60 60 50|01232323232323232323232|1BQV0 1zb0 Oo0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0", "America/Paramaribo|SRT|30|0||24e4", "America/Port-au-Prince|EST EDT|50 40|010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5", "America/Santiago|CLST CLT|30 40|010101010101010101010|1C1f0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0|62e5", "America/Sao_Paulo|BRST BRT|20 30|01010101010101010101010|1BIq0 1zd0 On0 1zd0 Rb0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10|20e6", "America/Scoresbysund|EGT EGST|10 0|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|452", "America/St_Johns|NST NDT|3u 2u|01010101010101010101010|1BQPv 1zb0 Op0 1zcX Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4", "Antarctica/Casey|+11 +08|-b0 -80|01010|1BN30 40P0 KL0 blz0|10", "Antarctica/Davis|+05 +07|-50 -70|0101|1BPw0 3Wn0 KN0|70", "Antarctica/DumontDUrville|+10|-a0|0||80", "Antarctica/Macquarie|AEDT MIST|-b0 -b0|01|1C140|1", "Asia/Tashkent|+05|-50|0||23e5", "Pacific/Auckland|NZDT NZST|-d0 -c0|01010101010101010101010|1C120 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|14e5", "Antarctica/Rothera|-03|30|0||130", "Antarctica/Syowa|+03|-30|0||20", "Antarctica/Troll|+00 +02|0 -20|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|40", "Asia/Almaty|+06|-60|0||15e5", "Asia/Baghdad|AST|-30|0||66e5", "Asia/Amman|EET EEST|-20 -30|010101010101010101010|1BVy0 1qM0 11A0 1o00 11A0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0|25e5", "Asia/Kamchatka|+12 +11|-c0 -b0|010|1Dp30 WM0|18e4", "Asia/Baku|+04 +05|-40 -50|0101010101010|1BWo0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5", "Asia/Bangkok|ICT|-70|0||15e6", "Asia/Barnaul|+06 +07|-60 -70|010101|1BWk0 1qM0 WM0 8Hz0 3rd0", "Asia/Beirut|EET EEST|-20 -30|01010101010101010101010|1BWm0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0|22e5", "Asia/Brunei|BNT|-80|0||42e4", "Asia/Kolkata|IST|-5u|0||15e6", "Asia/Chita|+09 +10 +08|-90 -a0 -80|010120|1BWh0 1qM0 WM0 8Hz0 3re0|33e4", "Asia/Choibalsan|CHOT CHOST|-80 -90|0101010101010|1O8G0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|38e3", "Asia/Shanghai|CST|-80|0||23e6", "Asia/Colombo|+0530|-5u|0||22e5", "Asia/Dhaka|BDT|-60|0||16e6", "Asia/Damascus|EET EEST|-20 -30|01010101010101010101010|1C0m0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0|26e5", "Asia/Dili|TLT|-90|0||19e4", "Asia/Dubai|GST|-40|0||39e5", "Asia/Famagusta|EET EEST +03|-20 -30 -30|010101010101012|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0", "Asia/Gaza|EET EEST|-20 -30|01010101010101010101010|1BVW1 SKX 1xd1 MKX 1AN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0|18e5", "Asia/Hebron|EET EEST|-20 -30|0101010101010101010101010|1BVy0 Tb0 1xd1 MKX bB0 cn0 1cN0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0|25e4", "Asia/Hong_Kong|HKT|-80|0||73e5", "Asia/Hovd|HOVT HOVST|-70 -80|0101010101010|1O8H0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|81e3", "Asia/Irkutsk|+08 +09|-80 -90|01010|1BWi0 1qM0 WM0 8Hz0|60e4", "Europe/Istanbul|EET EEST +03|-20 -30 -30|010101010101012|1BWp0 1qM0 Xc0 1qo0 WM0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6", "Asia/Jakarta|WIB|-70|0||31e6", "Asia/Jayapura|WIT|-90|0||26e4", "Asia/Jerusalem|IST IDT|-20 -30|01010101010101010101010|1BVA0 17X0 1kp0 1dz0 1c10 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0|81e4", "Asia/Kabul|AFT|-4u|0||46e5", "Asia/Karachi|PKT|-50|0||24e6", "Asia/Urumqi|XJT|-60|0||32e5", "Asia/Kathmandu|NPT|-5J|0||12e5", "Asia/Khandyga|+10 +11 +09|-a0 -b0 -90|010102|1BWg0 1qM0 WM0 17V0 7zD0|66e2", "Asia/Krasnoyarsk|+07 +08|-70 -80|01010|1BWj0 1qM0 WM0 8Hz0|10e5", "Asia/Kuala_Lumpur|MYT|-80|0||71e5", "Asia/Magadan|+11 +12 +10|-b0 -c0 -a0|010120|1BWf0 1qM0 WM0 8Hz0 3Cq0|95e3", "Asia/Makassar|WITA|-80|0||15e5", "Asia/Manila|PHT|-80|0||24e6", "Europe/Athens|EET EEST|-20 -30|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|35e5", "Asia/Novokuznetsk|+07 +06|-70 -60|010|1Dp80 WM0|55e4", "Asia/Novosibirsk|+06 +07|-60 -70|010101|1BWk0 1qM0 WM0 8Hz0 4eN0|15e5", "Asia/Omsk|+06 +07|-60 -70|01010|1BWk0 1qM0 WM0 8Hz0|12e5", "Asia/Pyongyang|KST KST|-90 -8u|01|1P4D0|29e5", "Asia/Rangoon|MMT|-6u|0||48e5", "Asia/Sakhalin|+10 +11|-a0 -b0|010101|1BWg0 1qM0 WM0 8Hz0 3rd0|58e4", "Asia/Seoul|KST|-90|0||23e6", "Asia/Singapore|SGT|-80|0||56e5", "Asia/Srednekolymsk|+11 +12|-b0 -c0|01010|1BWf0 1qM0 WM0 8Hz0|35e2", "Asia/Tbilisi|+04|-40|0||11e5", "Asia/Tehran|IRST IRDT|-3u -4u|01010101010101010101010|1BTUu 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0|14e6", "Asia/Thimphu|BTT|-60|0||79e3", "Asia/Tokyo|JST|-90|0||38e6", "Asia/Tomsk|+06 +07|-60 -70|010101|1BWk0 1qM0 WM0 8Hz0 3Qp0|10e5", "Asia/Ulaanbaatar|ULAT ULAST|-80 -90|0101010101010|1O8G0 1cJ0 1cP0 1cJ0 1cP0 1fx0 1cP0 1cJ0 1cP0 1cJ0 1cP0 1cJ0|12e5", "Asia/Ust-Nera|+11 +12 +10|-b0 -c0 -a0|010102|1BWf0 1qM0 WM0 17V0 7zD0|65e2", "Asia/Vladivostok|+10 +11|-a0 -b0|01010|1BWg0 1qM0 WM0 8Hz0|60e4", "Asia/Yakutsk|+09 +10|-90 -a0|01010|1BWh0 1qM0 WM0 8Hz0|28e4", "Asia/Yekaterinburg|+05 +06|-50 -60|01010|1BWl0 1qM0 WM0 8Hz0|14e5", "Asia/Yerevan|+04 +05|-40 -50|01010|1BWm0 1qM0 WM0 1qM0|13e5", "Atlantic/Azores|AZOT AZOST|10 0|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|25e4", "Europe/Lisbon|WET WEST|0 -10|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e5", "Atlantic/Cape_Verde|CVT|10|0||50e4", "Atlantic/South_Georgia|GST|20|0||30", "Atlantic/Stanley|FKST FKT|30 40|010|1C6R0 U10|21e2", "Australia/Sydney|AEDT AEST|-b0 -a0|01010101010101010101010|1C140 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|40e5", "Australia/Adelaide|ACDT ACST|-au -9u|01010101010101010101010|1C14u 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0|11e5", "Australia/Brisbane|AEST|-a0|0||20e5", "Australia/Darwin|ACST|-9u|0||12e4", "Australia/Eucla|ACWST|-8J|0||368", "Australia/Lord_Howe|LHDT LHST|-b0 -au|01010101010101010101010|1C130 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu|347", "Australia/Perth|AWST|-80|0||18e5", "Pacific/Easter|EASST EAST|50 60|010101010101010101010|1C1f0 1fB0 1nX0 G10 1EL0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0|30e2", "Europe/Dublin|GMT IST|0 -10|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5", "Etc/GMT+1|-01|10|0|", "Etc/GMT+10|-10|a0|0|", "Etc/GMT+11|-11|b0|0|", "Etc/GMT+12|-12|c0|0|", "Etc/GMT+2|-02|20|0|", "Etc/GMT+4|-04|40|0|", "Etc/GMT+5|-05|50|0|", "Etc/GMT+6|-06|60|0|", "Etc/GMT+7|-07|70|0|", "Etc/GMT+8|-08|80|0|", "Etc/GMT+9|-09|90|0|", "Etc/GMT-1|+01|-10|0|", "Etc/GMT-11|+11|-b0|0|", "Etc/GMT-12|+12|-c0|0|", "Etc/GMT-13|+13|-d0|0|", "Etc/GMT-14|+14|-e0|0|", "Etc/GMT-2|+02|-20|0|", "Etc/GMT-7|+07|-70|0|", "Etc/GMT-8|+08|-80|0|", "Etc/GMT-9|+09|-90|0|", "Etc/UCT|UCT|0|0|", "Etc/UTC|UTC|0|0|", "Europe/Astrakhan|+03 +04|-30 -40|010101|1BWn0 1qM0 WM0 8Hz0 3rd0", "Europe/London|GMT BST|0 -10|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|10e6", "Europe/Chisinau|EET EEST|-20 -30|01010101010101010101010|1BWo0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|67e4", "Europe/Kaliningrad|EET EEST +03|-20 -30 -30|01020|1BWo0 1qM0 WM0 8Hz0|44e4", "Europe/Volgograd|+03 +04|-30 -40|01010|1BWn0 1qM0 WM0 8Hz0|10e5", "Europe/Minsk|EET EEST +03|-20 -30 -30|0102|1BWo0 1qM0 WM0|19e5", "Europe/Moscow|MSK MSD MSK|-30 -40 -40|01020|1BWn0 1qM0 WM0 8Hz0|16e6", "Europe/Samara|+04 +03|-40 -30|010|1Dpb0 WM0|12e5", "Europe/Simferopol|EET EEST MSK MSK|-20 -30 -40 -30|01010101023|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11z0 1nW0|33e4", "Pacific/Honolulu|HST|a0|0||37e4", "Indian/Chagos|IOT|-60|0||30e2", "Indian/Christmas|CXT|-70|0||21e2", "Indian/Cocos|CCT|-6u|0||596", "Indian/Mahe|SCT|-40|0||79e3", "Indian/Maldives|MVT|-50|0||35e4", "Indian/Mauritius|MUT|-40|0||15e4", "Indian/Reunion|RET|-40|0||84e4", "Pacific/Majuro|MHT|-c0|0||28e3", "MET|MET MEST|-10 -20|01010101010101010101010|1BWp0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00", "Pacific/Chatham|CHADT CHAST|-dJ -cJ|01010101010101010101010|1C120 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|600", "Pacific/Apia|SST SDT WSDT WSST|b0 a0 -e0 -d0|01012323232323232323232|1Dbn0 1ff0 1a00 CI0 AQ0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00|37e3", "Pacific/Bougainville|PGT BST|-a0 -b0|01|1NwE0|18e4", "Pacific/Chuuk|CHUT|-a0|0||49e3", "Pacific/Efate|VUT|-b0|0||66e3", "Pacific/Enderbury|PHOT|-d0|0||1", "Pacific/Fakaofo|TKT TKT|b0 -d0|01|1Gfn0|483", "Pacific/Fiji|FJST FJT|-d0 -c0|01010101010101010101010|1BWe0 1o00 Rc0 1wo0 Ao0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0|88e4", "Pacific/Funafuti|TVT|-c0|0||45e2", "Pacific/Galapagos|GALT|60|0||25e3", "Pacific/Gambier|GAMT|90|0||125", "Pacific/Guadalcanal|SBT|-b0|0||11e4", "Pacific/Guam|ChST|-a0|0||17e4", "Pacific/Kiritimati|LINT|-e0|0||51e2", "Pacific/Kosrae|KOST|-b0|0||66e2", "Pacific/Marquesas|MART|9u|0||86e2", "Pacific/Pago_Pago|SST|b0|0||37e2", "Pacific/Nauru|NRT|-c0|0||10e3", "Pacific/Niue|NUT|b0|0||12e2", "Pacific/Norfolk|NFT NFT|-bu -b0|01|1PoCu|25e4", "Pacific/Noumea|NCT|-b0|0||98e3", "Pacific/Palau|PWT|-90|0||21e3", "Pacific/Pitcairn|PST|80|0||56", "Pacific/Pohnpei|PONT|-b0|0||34e3", "Pacific/Port_Moresby|PGT|-a0|0||25e4", "Pacific/Rarotonga|CKT|a0|0||13e3", "Pacific/Tahiti|TAHT|a0|0||18e4", "Pacific/Tarawa|GILT|-c0|0||29e3", "Pacific/Tongatapu|+13 +14|-d0 -e0|0101010101|1S4d0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0|75e3", "Pacific/Wake|WAKT|-c0|0||16e3", "Pacific/Wallis|WFT|-c0|0||94" ],
        links: [ "Africa/Abidjan|Africa/Accra", "Africa/Abidjan|Africa/Bamako", "Africa/Abidjan|Africa/Banjul", "Africa/Abidjan|Africa/Bissau", "Africa/Abidjan|Africa/Conakry", "Africa/Abidjan|Africa/Dakar", "Africa/Abidjan|Africa/Freetown", "Africa/Abidjan|Africa/Lome", "Africa/Abidjan|Africa/Monrovia", "Africa/Abidjan|Africa/Nouakchott", "Africa/Abidjan|Africa/Ouagadougou", "Africa/Abidjan|Africa/Sao_Tome", "Africa/Abidjan|Africa/Timbuktu", "Africa/Abidjan|America/Danmarkshavn", "Africa/Abidjan|Atlantic/Reykjavik", "Africa/Abidjan|Atlantic/St_Helena", "Africa/Abidjan|Etc/GMT", "Africa/Abidjan|Etc/GMT+0", "Africa/Abidjan|Etc/GMT-0", "Africa/Abidjan|Etc/GMT0", "Africa/Abidjan|Etc/Greenwich", "Africa/Abidjan|GMT", "Africa/Abidjan|GMT+0", "Africa/Abidjan|GMT-0", "Africa/Abidjan|GMT0", "Africa/Abidjan|Greenwich", "Africa/Abidjan|Iceland", "Africa/Algiers|Africa/Tunis", "Africa/Cairo|Egypt", "Africa/Casablanca|Africa/El_Aaiun", "Africa/Johannesburg|Africa/Maseru", "Africa/Johannesburg|Africa/Mbabane", "Africa/Khartoum|Africa/Addis_Ababa", "Africa/Khartoum|Africa/Asmara", "Africa/Khartoum|Africa/Asmera", "Africa/Khartoum|Africa/Dar_es_Salaam", "Africa/Khartoum|Africa/Djibouti", "Africa/Khartoum|Africa/Juba", "Africa/Khartoum|Africa/Kampala", "Africa/Khartoum|Africa/Mogadishu", "Africa/Khartoum|Africa/Nairobi", "Africa/Khartoum|Indian/Antananarivo", "Africa/Khartoum|Indian/Comoro", "Africa/Khartoum|Indian/Mayotte", "Africa/Lagos|Africa/Bangui", "Africa/Lagos|Africa/Brazzaville", "Africa/Lagos|Africa/Douala", "Africa/Lagos|Africa/Kinshasa", "Africa/Lagos|Africa/Libreville", "Africa/Lagos|Africa/Luanda", "Africa/Lagos|Africa/Malabo", "Africa/Lagos|Africa/Ndjamena", "Africa/Lagos|Africa/Niamey", "Africa/Lagos|Africa/Porto-Novo", "Africa/Maputo|Africa/Blantyre", "Africa/Maputo|Africa/Bujumbura", "Africa/Maputo|Africa/Gaborone", "Africa/Maputo|Africa/Harare", "Africa/Maputo|Africa/Kigali", "Africa/Maputo|Africa/Lubumbashi", "Africa/Maputo|Africa/Lusaka", "Africa/Tripoli|Libya", "America/Adak|America/Atka", "America/Adak|US/Aleutian", "America/Anchorage|America/Juneau", "America/Anchorage|America/Nome", "America/Anchorage|America/Sitka", "America/Anchorage|America/Yakutat", "America/Anchorage|US/Alaska", "America/Argentina/Buenos_Aires|America/Argentina/Catamarca", "America/Argentina/Buenos_Aires|America/Argentina/ComodRivadavia", "America/Argentina/Buenos_Aires|America/Argentina/Cordoba", "America/Argentina/Buenos_Aires|America/Argentina/Jujuy", "America/Argentina/Buenos_Aires|America/Argentina/La_Rioja", "America/Argentina/Buenos_Aires|America/Argentina/Mendoza", "America/Argentina/Buenos_Aires|America/Argentina/Rio_Gallegos", "America/Argentina/Buenos_Aires|America/Argentina/Salta", "America/Argentina/Buenos_Aires|America/Argentina/San_Juan", "America/Argentina/Buenos_Aires|America/Argentina/San_Luis", "America/Argentina/Buenos_Aires|America/Argentina/Tucuman", "America/Argentina/Buenos_Aires|America/Argentina/Ushuaia", "America/Argentina/Buenos_Aires|America/Buenos_Aires", "America/Argentina/Buenos_Aires|America/Catamarca", "America/Argentina/Buenos_Aires|America/Cordoba", "America/Argentina/Buenos_Aires|America/Jujuy", "America/Argentina/Buenos_Aires|America/Mendoza", "America/Argentina/Buenos_Aires|America/Rosario", "America/Campo_Grande|America/Cuiaba", "America/Chicago|America/Indiana/Knox", "America/Chicago|America/Indiana/Tell_City", "America/Chicago|America/Knox_IN", "America/Chicago|America/Matamoros", "America/Chicago|America/Menominee", "America/Chicago|America/North_Dakota/Center", "America/Chicago|America/North_Dakota/New_Salem", "America/Chicago|America/Rainy_River", "America/Chicago|America/Rankin_Inlet", "America/Chicago|America/Resolute", "America/Chicago|America/Winnipeg", "America/Chicago|CST6CDT", "America/Chicago|Canada/Central", "America/Chicago|US/Central", "America/Chicago|US/Indiana-Starke", "America/Chihuahua|America/Mazatlan", "America/Chihuahua|Mexico/BajaSur", "America/Denver|America/Boise", "America/Denver|America/Cambridge_Bay", "America/Denver|America/Edmonton", "America/Denver|America/Inuvik", "America/Denver|America/Ojinaga", "America/Denver|America/Shiprock", "America/Denver|America/Yellowknife", "America/Denver|Canada/Mountain", "America/Denver|MST7MDT", "America/Denver|Navajo", "America/Denver|US/Mountain", "America/Fortaleza|America/Belem", "America/Fortaleza|America/Maceio", "America/Fortaleza|America/Recife", "America/Fortaleza|America/Santarem", "America/Halifax|America/Glace_Bay", "America/Halifax|America/Moncton", "America/Halifax|America/Thule", "America/Halifax|Atlantic/Bermuda", "America/Halifax|Canada/Atlantic", "America/Havana|Cuba", "America/Los_Angeles|America/Dawson", "America/Los_Angeles|America/Ensenada", "America/Los_Angeles|America/Santa_Isabel", "America/Los_Angeles|America/Tijuana", "America/Los_Angeles|America/Vancouver", "America/Los_Angeles|America/Whitehorse", "America/Los_Angeles|Canada/Pacific", "America/Los_Angeles|Canada/Yukon", "America/Los_Angeles|Mexico/BajaNorte", "America/Los_Angeles|PST8PDT", "America/Los_Angeles|US/Pacific", "America/Los_Angeles|US/Pacific-New", "America/Managua|America/Belize", "America/Managua|America/Costa_Rica", "America/Managua|America/El_Salvador", "America/Managua|America/Guatemala", "America/Managua|America/Regina", "America/Managua|America/Swift_Current", "America/Managua|America/Tegucigalpa", "America/Managua|Canada/East-Saskatchewan", "America/Managua|Canada/Saskatchewan", "America/Manaus|America/Boa_Vista", "America/Manaus|America/Porto_Velho", "America/Manaus|Brazil/West", "America/Mexico_City|America/Merida", "America/Mexico_City|America/Monterrey", "America/Mexico_City|Mexico/General", "America/New_York|America/Detroit", "America/New_York|America/Fort_Wayne", "America/New_York|America/Indiana/Indianapolis", "America/New_York|America/Indiana/Marengo", "America/New_York|America/Indiana/Petersburg", "America/New_York|America/Indiana/Vevay", "America/New_York|America/Indiana/Vincennes", "America/New_York|America/Indiana/Winamac", "America/New_York|America/Indianapolis", "America/New_York|America/Iqaluit", "America/New_York|America/Kentucky/Louisville", "America/New_York|America/Kentucky/Monticello", "America/New_York|America/Louisville", "America/New_York|America/Montreal", "America/New_York|America/Nassau", "America/New_York|America/Nipigon", "America/New_York|America/Pangnirtung", "America/New_York|America/Thunder_Bay", "America/New_York|America/Toronto", "America/New_York|Canada/Eastern", "America/New_York|EST5EDT", "America/New_York|US/East-Indiana", "America/New_York|US/Eastern", "America/New_York|US/Michigan", "America/Noronha|Brazil/DeNoronha", "America/Panama|America/Atikokan", "America/Panama|America/Cayman", "America/Panama|America/Coral_Harbour", "America/Panama|America/Jamaica", "America/Panama|EST", "America/Panama|Jamaica", "America/Phoenix|America/Creston", "America/Phoenix|America/Dawson_Creek", "America/Phoenix|America/Hermosillo", "America/Phoenix|MST", "America/Phoenix|US/Arizona", "America/Rio_Branco|America/Eirunepe", "America/Rio_Branco|America/Porto_Acre", "America/Rio_Branco|Brazil/Acre", "America/Santiago|Antarctica/Palmer", "America/Santiago|Chile/Continental", "America/Santo_Domingo|America/Anguilla", "America/Santo_Domingo|America/Antigua", "America/Santo_Domingo|America/Aruba", "America/Santo_Domingo|America/Barbados", "America/Santo_Domingo|America/Blanc-Sablon", "America/Santo_Domingo|America/Curacao", "America/Santo_Domingo|America/Dominica", "America/Santo_Domingo|America/Grenada", "America/Santo_Domingo|America/Guadeloupe", "America/Santo_Domingo|America/Kralendijk", "America/Santo_Domingo|America/Lower_Princes", "America/Santo_Domingo|America/Marigot", "America/Santo_Domingo|America/Martinique", "America/Santo_Domingo|America/Montserrat", "America/Santo_Domingo|America/Port_of_Spain", "America/Santo_Domingo|America/Puerto_Rico", "America/Santo_Domingo|America/St_Barthelemy", "America/Santo_Domingo|America/St_Kitts", "America/Santo_Domingo|America/St_Lucia", "America/Santo_Domingo|America/St_Thomas", "America/Santo_Domingo|America/St_Vincent", "America/Santo_Domingo|America/Tortola", "America/Santo_Domingo|America/Virgin", "America/Sao_Paulo|Brazil/East", "America/St_Johns|Canada/Newfoundland", "Antarctica/DumontDUrville|Etc/GMT-10", "Antarctica/Rothera|Etc/GMT+3", "Antarctica/Syowa|Etc/GMT-3", "Asia/Almaty|Antarctica/Vostok", "Asia/Almaty|Asia/Bishkek", "Asia/Almaty|Asia/Qyzylorda", "Asia/Almaty|Etc/GMT-6", "Asia/Baghdad|Asia/Aden", "Asia/Baghdad|Asia/Bahrain", "Asia/Baghdad|Asia/Kuwait", "Asia/Baghdad|Asia/Qatar", "Asia/Baghdad|Asia/Riyadh", "Asia/Bangkok|Asia/Ho_Chi_Minh", "Asia/Bangkok|Asia/Phnom_Penh", "Asia/Bangkok|Asia/Saigon", "Asia/Bangkok|Asia/Vientiane", "Asia/Dhaka|Asia/Dacca", "Asia/Dubai|Asia/Muscat", "Asia/Hong_Kong|Hongkong", "Asia/Jakarta|Asia/Pontianak", "Asia/Jerusalem|Asia/Tel_Aviv", "Asia/Jerusalem|Israel", "Asia/Kamchatka|Asia/Anadyr", "Asia/Kathmandu|Asia/Katmandu", "Asia/Kolkata|Asia/Calcutta", "Asia/Kuala_Lumpur|Asia/Kuching", "Asia/Makassar|Asia/Ujung_Pandang", "Asia/Rangoon|Asia/Yangon", "Asia/Seoul|ROK", "Asia/Shanghai|Asia/Chongqing", "Asia/Shanghai|Asia/Chungking", "Asia/Shanghai|Asia/Harbin", "Asia/Shanghai|Asia/Macao", "Asia/Shanghai|Asia/Macau", "Asia/Shanghai|Asia/Taipei", "Asia/Shanghai|PRC", "Asia/Shanghai|ROC", "Asia/Singapore|Singapore", "Asia/Tashkent|Antarctica/Mawson", "Asia/Tashkent|Asia/Aqtau", "Asia/Tashkent|Asia/Aqtobe", "Asia/Tashkent|Asia/Ashgabat", "Asia/Tashkent|Asia/Ashkhabad", "Asia/Tashkent|Asia/Dushanbe", "Asia/Tashkent|Asia/Oral", "Asia/Tashkent|Asia/Samarkand", "Asia/Tashkent|Etc/GMT-5", "Asia/Tashkent|Indian/Kerguelen", "Asia/Tbilisi|Etc/GMT-4", "Asia/Tehran|Iran", "Asia/Thimphu|Asia/Thimbu", "Asia/Tokyo|Japan", "Asia/Ulaanbaatar|Asia/Ulan_Bator", "Asia/Urumqi|Asia/Kashgar", "Australia/Adelaide|Australia/Broken_Hill", "Australia/Adelaide|Australia/South", "Australia/Adelaide|Australia/Yancowinna", "Australia/Brisbane|Australia/Lindeman", "Australia/Brisbane|Australia/Queensland", "Australia/Darwin|Australia/North", "Australia/Lord_Howe|Australia/LHI", "Australia/Perth|Australia/West", "Australia/Sydney|Australia/ACT", "Australia/Sydney|Australia/Canberra", "Australia/Sydney|Australia/Currie", "Australia/Sydney|Australia/Hobart", "Australia/Sydney|Australia/Melbourne", "Australia/Sydney|Australia/NSW", "Australia/Sydney|Australia/Tasmania", "Australia/Sydney|Australia/Victoria", "Etc/UCT|UCT", "Etc/UTC|Etc/Universal", "Etc/UTC|Etc/Zulu", "Etc/UTC|UTC", "Etc/UTC|Universal", "Etc/UTC|Zulu", "Europe/Astrakhan|Europe/Ulyanovsk", "Europe/Athens|Asia/Nicosia", "Europe/Athens|EET", "Europe/Athens|Europe/Bucharest", "Europe/Athens|Europe/Helsinki", "Europe/Athens|Europe/Kiev", "Europe/Athens|Europe/Mariehamn", "Europe/Athens|Europe/Nicosia", "Europe/Athens|Europe/Riga", "Europe/Athens|Europe/Sofia", "Europe/Athens|Europe/Tallinn", "Europe/Athens|Europe/Uzhgorod", "Europe/Athens|Europe/Vilnius", "Europe/Athens|Europe/Zaporozhye", "Europe/Chisinau|Europe/Tiraspol", "Europe/Dublin|Eire", "Europe/Istanbul|Asia/Istanbul", "Europe/Istanbul|Turkey", "Europe/Lisbon|Atlantic/Canary", "Europe/Lisbon|Atlantic/Faeroe", "Europe/Lisbon|Atlantic/Faroe", "Europe/Lisbon|Atlantic/Madeira", "Europe/Lisbon|Portugal", "Europe/Lisbon|WET", "Europe/London|Europe/Belfast", "Europe/London|Europe/Guernsey", "Europe/London|Europe/Isle_of_Man", "Europe/London|Europe/Jersey", "Europe/London|GB", "Europe/London|GB-Eire", "Europe/Moscow|W-SU", "Europe/Paris|Africa/Ceuta", "Europe/Paris|Arctic/Longyearbyen", "Europe/Paris|Atlantic/Jan_Mayen", "Europe/Paris|CET", "Europe/Paris|Europe/Amsterdam", "Europe/Paris|Europe/Andorra", "Europe/Paris|Europe/Belgrade", "Europe/Paris|Europe/Berlin", "Europe/Paris|Europe/Bratislava", "Europe/Paris|Europe/Brussels", "Europe/Paris|Europe/Budapest", "Europe/Paris|Europe/Busingen", "Europe/Paris|Europe/Copenhagen", "Europe/Paris|Europe/Gibraltar", "Europe/Paris|Europe/Ljubljana", "Europe/Paris|Europe/Luxembourg", "Europe/Paris|Europe/Madrid", "Europe/Paris|Europe/Malta", "Europe/Paris|Europe/Monaco", "Europe/Paris|Europe/Oslo", "Europe/Paris|Europe/Podgorica", "Europe/Paris|Europe/Prague", "Europe/Paris|Europe/Rome", "Europe/Paris|Europe/San_Marino", "Europe/Paris|Europe/Sarajevo", "Europe/Paris|Europe/Skopje", "Europe/Paris|Europe/Stockholm", "Europe/Paris|Europe/Tirane", "Europe/Paris|Europe/Vaduz", "Europe/Paris|Europe/Vatican", "Europe/Paris|Europe/Vienna", "Europe/Paris|Europe/Warsaw", "Europe/Paris|Europe/Zagreb", "Europe/Paris|Europe/Zurich", "Europe/Paris|Poland", "Europe/Volgograd|Europe/Kirov", "Pacific/Auckland|Antarctica/McMurdo", "Pacific/Auckland|Antarctica/South_Pole", "Pacific/Auckland|NZ", "Pacific/Chatham|NZ-CHAT", "Pacific/Chuuk|Pacific/Truk", "Pacific/Chuuk|Pacific/Yap", "Pacific/Easter|Chile/EasterIsland", "Pacific/Guam|Pacific/Saipan", "Pacific/Honolulu|HST", "Pacific/Honolulu|Pacific/Johnston", "Pacific/Honolulu|US/Hawaii", "Pacific/Majuro|Kwajalein", "Pacific/Majuro|Pacific/Kwajalein", "Pacific/Pago_Pago|Pacific/Midway", "Pacific/Pago_Pago|Pacific/Samoa", "Pacific/Pago_Pago|US/Samoa", "Pacific/Pohnpei|Pacific/Ponape" ]
    }), a;
});

(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        };
    } else {
        factory(global);
    }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var arr = [];
    var document = window.document;
    var slice = arr.slice;
    var concat = arr.concat;
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var support = {};
    var version = "2.2.4", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            return ret;
        },
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[i] || {};
            i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }
        if (i === length) {
            target = this;
            i--;
        }
        for (;i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) {
                        continue;
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
            var realStringObj = obj && obj.toString();
            return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
        },
        isPlainObject: function(obj) {
            var key;
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }
            if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
                return false;
            }
            for (key in obj) {}
            return key === undefined || hasOwn.call(obj, key);
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },
        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code);
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {
                    indirect(code);
                }
            }
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) {
                length = obj.length;
                for (;i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }
            return obj;
        },
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [ arr ] : arr);
                } else {
                    push.call(ret, arr);
                }
            }
            return ret;
        },
        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            var len = +second.length, j = 0, i = first.length;
            for (;j < len; j++) {
                first[i++] = second[j];
            }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
            for (;i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }
            return matches;
        },
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) {
                length = elems.length;
                for (;i < length; i++) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);
                    if (value != null) {
                        ret.push(value);
                    }
                }
            }
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        now: Date.now,
        support: support
    });
    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = function(window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            var i = 0, len = list.length;
            for (;i < len; i++) {
                if (list[i] === elem) {
                    return i;
                }
            }
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
            setDocument();
        };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    var j = target.length, i = 0;
                    while (target[j++] = els[i++]) {}
                    target.length = j - 1;
                }
            };
        }
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, nidselect, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results;
            }
            if (!seed) {
                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;
                if (documentIsHTML) {
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                        if (m = match[1]) {
                            if (nodeType === 9) {
                                if (elem = context.getElementById(m)) {
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }
                            } else {
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            }
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }
                    if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;
                        } else if (context.nodeName.toLowerCase() !== "object") {
                            if (nid = context.getAttribute("id")) {
                                nid = nid.replace(rescape, "\\$&");
                            } else {
                                context.setAttribute("id", nid = expando);
                            }
                            groups = tokenize(selector);
                            i = groups.length;
                            nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
                            while (i--) {
                                groups[i] = nidselect + " " + toSelector(groups[i]);
                            }
                            newSelector = groups.join(",");
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }
                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {} finally {
                                if (nid === expando) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            var keys = [];
            function cache(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) {
                    delete cache[keys.shift()];
                }
                return cache[key + " "] = value;
            }
            return cache;
        }
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                div = null;
            }
        }
        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = arr.length;
            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) {
                return diff;
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);
            if ((parent = document.defaultView) && parent.top !== parent) {
                if (parent.addEventListener) {
                    parent.addEventListener("unload", unloadHandler, false);
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", unloadHandler);
                }
            }
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(document.createComment(""));
                return !div.getElementsByTagName("*").length;
            });
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m ? [ m ] : [];
                    }
                };
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    };
                };
            } else {
                delete Expr.find["ID"];
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    };
                };
            }
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }
                    return tmp;
                }
                return results;
            };
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            };
            rbuggyMatches = [];
            rbuggyQSA = [];
            if (support.qsa = rnative.test(document.querySelectorAll)) {
                assert(function(div) {
                    docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                    if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }
                    if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=");
                    }
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                    if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                    }
                });
                assert(function(div) {
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function(div) {
                    support.disconnectedMatch = matches.call(div, "div");
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
            hasCompare = rnative.test(docElem.compareDocumentPosition);
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            } : function(a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            };
            sortOrder = hasCompare ? function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                }
                return compare & 4 ? -1 : 1;
            } : function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }
                cur = a;
                while (cur = cur.parentNode) {
                    ap.unshift(cur);
                }
                cur = b;
                while (cur = cur.parentNode) {
                    bp.unshift(cur);
                }
                while (ap[i] === bp[i]) {
                    i++;
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            };
            return document;
        };
        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            expr = expr.replace(rattributeQuotes, "='$1']");
            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }
            sortInput = null;
            return results;
        };
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            return ret;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    match[1] = match[1].replace(runescape, funescape);
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }
                    return match.slice(0, 4);
                },
                CHILD: function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1].slice(0, 3) === "nth") {
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +(match[7] + match[8] || match[3] === "odd");
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }
                    return match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                    return first === 1 && last === 0 ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false;
                                        }
                                    }
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }
                            start = [ forward ? parent.firstChild : parent.lastChild ];
                            if (forward && useCache) {
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [ dirruns, nodeIndex, diff ];
                                        break;
                                    }
                                }
                            } else {
                                if (useCache) {
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }
                                if (diff === false) {
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                uniqueCache[type] = [ dirruns, diff ];
                                            }
                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            diff -= last;
                            return diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) {
                        return fn(argument);
                    }
                    if (fn.length > 1) {
                        args = [ pseudo, pseudo, "", argument ];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        };
                    }
                    return fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        input[0] = null;
                        return !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);
                        return false;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: function(elem) {
                    return elem.disabled === false;
                },
                disabled: function(elem) {
                    return elem.disabled === true;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
                },
                selected: function(elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }
                    return elem.selected === true;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },
                parent: function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },
                text: function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (;i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;--i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (;++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }
                matched = false;
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }
                if (!matched) {
                    break;
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = "";
            for (;i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            } : function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                            if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2];
                            } else {
                                uniqueCache[dir] = newCache;
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length;
            for (;i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
            for (;i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length;
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem);
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }
        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
            } ];
            for (;i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [ addCombinator(elementMatcher(matchers), matcher) ];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (;j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length;
                if (outermost) {
                    outermostContext = context === document || context || outermost;
                }
                for (;i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        if (!context && elem.ownerDocument !== document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                        }
                        while (matcher = elementMatchers[j++]) {
                            if (matcher(elem, context || document, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }
                    if (bySet) {
                        if (elem = !matcher && elem) {
                            matchedCount--;
                        }
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while (matcher = setMatchers[j++]) {
                        matcher(unmatched, setMatched, context, xml);
                    }
                    if (seed) {
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched);
                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                        Sizzle.uniqueSort(results);
                    }
                }
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }
                return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                cached.selector = selector;
            }
            return cached;
        };
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;
                    } else if (compiled) {
                        context = context.parentNode;
                    }
                    selector = selector.slice(tokens.shift().value.length);
                }
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];
                    if (Expr.relative[type = token.type]) {
                        break;
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }
                            break;
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }
        return Sizzle;
    }(window);
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    var dir = function(elem, dir, until) {
        var matched = [], truncate = until !== undefined;
        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };
    var siblings = function(n, elem) {
        var matched = [];
        for (;n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }
        return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
    var risSimple = /^.[^:#\[\.,]*$/;
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not;
            });
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return elem === qualifier !== not;
            });
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
        });
    }
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
            expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    };
    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector) {
            return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [ null, selector, null ];
            } else {
                match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }
                    return this;
                } else {
                    elem = document.getElementById(match[2]);
                    if (elem && elem.parentNode) {
                        this.length = 1;
                        this[0] = elem;
                    }
                    this.context = document;
                    this.selector = selector;
                    return this;
                }
            } else if (!context || context.jquery) {
                return (context || root).find(selector);
            } else {
                return this.constructor(context).find(selector);
            }
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;
        } else if (jQuery.isFunction(selector)) {
            return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                var i = 0;
                for (;i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (;i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur);
                        break;
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function(elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }
    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            if (name.slice(-5) !== "Until") {
                selector = until;
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }
            return this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g;
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = options.once;
            fired = firing = true;
            for (;queue.length; firingIndex = -1) {
                memory = queue.shift();
                while (++firingIndex < list.length) {
                    if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                        firingIndex = list.length;
                        memory = false;
                    }
                }
            }
            if (!options.memory) {
                memory = false;
            }
            firing = false;
            if (locked) {
                if (memory) {
                    list = [];
                } else {
                    list = "";
                }
            }
        }, self = {
            add: function() {
                if (list) {
                    if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                    }
                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            if (jQuery.isFunction(arg)) {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                                add(arg);
                            }
                        });
                    })(arguments);
                    if (memory && !firing) {
                        fire();
                    }
                }
                return this;
            },
            remove: function() {
                jQuery.each(arguments, function(_, arg) {
                    var index;
                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                        list.splice(index, 1);
                        if (index <= firingIndex) {
                            firingIndex--;
                        }
                    }
                });
                return this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            empty: function() {
                if (list) {
                    list = [];
                }
                return this;
            },
            disable: function() {
                locked = queue = [];
                list = memory = "";
                return this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                locked = queue = [];
                if (!memory) {
                    list = memory = "";
                }
                return this;
            },
            locked: function() {
                return !!locked;
            },
            fireWith: function(context, args) {
                if (!locked) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    queue.push(args);
                    if (!firing) {
                        fire();
                    }
                }
                return this;
            },
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) {
                    list.add(function() {
                        state = stateString;
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                };
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!--remaining) {
                        deferred.resolveWith(contexts, values);
                    }
                };
            }, progressValues, progressContexts, resolveContexts;
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (;i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
                    } else {
                        --remaining;
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }
            return deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
    };
    jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }
            readyList.resolveWith(document, [ jQuery ]);
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
    }
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
                window.setTimeout(jQuery.ready);
            } else {
                document.addEventListener("DOMContentLoaded", completed);
                window.addEventListener("load", completed);
            }
        }
        return readyList.promise(obj);
    };
    jQuery.ready.promise();
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }
        } else if (value !== undefined) {
            chainable = true;
            if (!jQuery.isFunction(value)) {
                raw = true;
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value);
                    fn = null;
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    };
                }
            }
            if (fn) {
                for (;i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
        register: function(owner, initial) {
            var value = initial || {};
            if (owner.nodeType) {
                owner[this.expando] = value;
            } else {
                Object.defineProperty(owner, this.expando, {
                    value: value,
                    writable: true,
                    configurable: true
                });
            }
            return owner[this.expando];
        },
        cache: function(owner) {
            if (!acceptData(owner)) {
                return {};
            }
            var value = owner[this.expando];
            if (!value) {
                value = {};
                if (acceptData(owner)) {
                    if (owner.nodeType) {
                        owner[this.expando] = value;
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }
            return value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if (typeof data === "string") {
                cache[data] = value;
            } else {
                for (prop in data) {
                    cache[prop] = data[prop];
                }
            }
            return cache;
        },
        get: function(owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
        },
        access: function(owner, key, value) {
            var stored;
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key);
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }
            this.set(owner, key, value);
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, cache = owner[this.expando];
            if (cache === undefined) {
                return;
            }
            if (key === undefined) {
                this.register(owner);
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);
                    if (key in cache) {
                        name = [ key, camel ];
                    } else {
                        name = camel;
                        name = name in cache ? [ name ] : name.match(rnotwhite) || [];
                    }
                }
                i = name.length;
                while (i--) {
                    delete cache[name[i]];
                }
            }
            if (key === undefined || jQuery.isEmptyObject(cache)) {
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);
                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") {
                return this.each(function() {
                    dataUser.set(this, key);
                });
            }
            return access(this, function(value) {
                var data, camelKey;
                if (elem && value === undefined) {
                    data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
                    if (data !== undefined) {
                        return data;
                    }
                    camelKey = jQuery.camelCase(key);
                    data = dataUser.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }
                    return;
                }
                camelKey = jQuery.camelCase(key);
                this.each(function() {
                    var data = dataUser.get(this, camelKey);
                    dataUser.set(this, camelKey, value);
                    if (key.indexOf("-") > -1 && data !== undefined) {
                        dataUser.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    });
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress");
                }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }
            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type);
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!--count) {
                    defer.resolveWith(elements, [ elements ]);
                }
            };
            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";
            while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3];
            valueParts = valueParts || [];
            initialInUnit = +initial || 1;
            do {
                scale = scale || ".5";
                initialInUnit = initialInUnit / scale;
                jQuery.style(elem, prop, initialInUnit + unit);
            } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
        }
        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([\w:-]+)/;
    var rscriptType = /^$|\/(?:java|ecma)script/i;
    var wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function getAll(context, tag) {
        var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (;i < l; i++) {
            dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for (;i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
                if (jQuery.type(elem) === "object") {
                    jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem);
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));
                    tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }
                    jQuery.merge(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = "";
                }
            }
        }
        fragment.textContent = "";
        i = 0;
        while (elem = nodes[i++]) {
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (contains) {
                setGlobalEval(tmp);
            }
            if (scripts) {
                j = 0;
                while (elem = tmp[j++]) {
                    if (rscriptType.test(elem.type || "")) {
                        scripts.push(elem);
                    }
                }
            }
        }
        return fragment;
    }
    (function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    })();
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
        return true;
    }
    function returnFalse() {
        return false;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === "object") {
            if (typeof selector !== "string") {
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }
        if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {
                fn = data;
                data = undefined;
            } else {
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }
        if (one === 1) {
            origFn = fn;
            fn = function(event) {
                jQuery().off(event);
                return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!elemData) {
                return;
            }
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                };
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj);
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }
                jQuery.event.global[type] = true;
            }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
                return;
            }
            types = (types || "").match(rnotwhite) || [ "" ];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);
                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
            }
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;
                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                        event.handleObj = handleObj;
                        event.data = handleObj.data;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }
            return event.result;
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
                for (;cur !== this; cur = cur.parentNode || this) {
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector + " ";
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [ cur ]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }
            return handlerQueue;
        },
        props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }
                return event;
            }
        },
        mouseHooks: {
            props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = new jQuery.Event(originalEvent);
            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }
            if (!event.target) {
                event.target = document;
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: true
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };
    jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
            this.type = src;
        }
        if (props) {
            jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }
            this.stopPropagation();
        }
    };
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });
    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }
        return elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
            return;
        }
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;
            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);
            dataUser.set(dest, udataCur);
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
                var self = collection.eq(index);
                if (isFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }
        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
                fragment = first;
            }
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;
                for (;i < l; i++) {
                    node = fragment;
                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);
                        if (hasScripts) {
                            jQuery.merge(scripts, getAll(node, "script"));
                        }
                    }
                    callback.call(collection[i], node, i);
                }
                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;
                    jQuery.map(scripts, restoreScript);
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                            if (node.src) {
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                            }
                        }
                    }
                }
            }
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (;(node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }
            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
            }
        }
        return elem;
    }
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone);
                srcElements = getAll(elem);
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
        },
        cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;
            for (;(elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });
    jQuery.fn.extend({
        domManip: domManip,
        detach: function(selector) {
            return remove(this, selector, true);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },
        empty: function() {
            var elem, i = 0;
            for (;(elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.textContent = "";
                }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (;i < l; i++) {
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }
            }, ignored);
        }
    });
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
            for (;i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);
                push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {
        HTML: "block",
        BODY: "block"
    };
    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], "display");
        elem.detach();
        return display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        if (!display) {
            display = actualDisplay(nodeName, doc);
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
                doc = iframe[0].contentDocument;
                doc.write();
                doc.close();
                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }
            elemdisplay[nodeName] = display;
        }
        return display;
    }
    var rmargin = /^margin/;
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
            view = window;
        }
        return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
            elem.style[name] = old[name];
        }
        return ret;
    };
    var documentElement = document.documentElement;
    (function() {
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
        if (!div.style) {
            return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
        container.appendChild(div);
        function computeStyleTests() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
            div.innerHTML = "";
            documentElement.appendChild(container);
            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = divStyle.marginLeft === "2px";
            boxSizingReliableVal = divStyle.width === "4px";
            div.style.marginRight = "50%";
            pixelMarginRightVal = divStyle.marginRight === "4px";
            documentElement.removeChild(container);
        }
        jQuery.extend(support, {
            pixelPosition: function() {
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelMarginRight: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return reliableMarginLeftVal;
            },
            reliableMarginRight: function() {
                var ret, marginDiv = div.appendChild(document.createElement("div"));
                marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                documentElement.appendChild(container);
                ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
                documentElement.removeChild(container);
                div.removeChild(marginDiv);
                return ret;
            }
        });
    })();
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        computed = computed || getStyles(elem);
        ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
        if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
            ret = jQuery.style(elem, name);
        }
        if (computed) {
            if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }
        return ret !== undefined ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                if (conditionFn()) {
                    delete this.get;
                    return;
                }
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ], emptyStyle = document.createElement("div").style;
    function vendorPropName(name) {
        if (name in emptyStyle) {
            return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0;
        for (;i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }
            if (rnumnonpx.test(val)) {
                return val;
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;
        for (;index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = dataPriv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);
                if (display !== "none" || !hidden) {
                    dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }
        return elements;
    }
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: true,
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        cssProps: {
            float: "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);
                    type = "number";
                }
                if (value == null || value !== value) {
                    return;
                }
                if (type === "number") {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value;
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }
                return style[name];
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });
    jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },
            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                }
                return setPositiveNumber(elem, value, subtract);
            }
        };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
                marginLeft: 0
            }, function() {
                return elem.getBoundingClientRect().left;
            })) + "px";
        }
    });
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return swap(elem, {
                display: "inline-block"
            }, curCSS, [ elem, "marginRight" ]);
        }
    });
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [ value ];
                for (;i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;
                    for (;i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }
                    return map;
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }
            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }
                result = jQuery.css(tween.elem, tween.prop, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };
    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function createFxNow() {
        window.setTimeout(function() {
            fxNow = undefined;
        });
        return fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        includeWidth = includeWidth ? 1 : 0;
        for (;i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }
        return attrs;
    }
    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for (;index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween;
            }
        }
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;
            anim.always(function() {
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
            display = jQuery.css(elem, "display");
            checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
            } else {
                display = undefined;
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = dataPriv.access(elem, "fxshow", {});
            }
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }
            if (index !== name) {
                props[name] = value;
                delete props[index];
            }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
            for (;index < length; index++) {
                animation.tweens[index].run(percent);
            }
            deferred.notifyWith(elem, [ animation, percent, remaining ]);
            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [ animation ]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (;index < length; index++) {
                    animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                    deferred.notifyWith(elem, [ animation, 1, 0 ]);
                    deferred.resolveWith(elem, [ animation, gotoEnd ]);
                } else {
                    deferred.rejectWith(elem, [ animation, gotoEnd ]);
                }
                return this;
            }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (;index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (jQuery.isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                }
                return result;
            }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [ function(prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
            } ]
        },
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = [ "*" ];
            } else {
                props = props.match(rnotwhite);
            }
            var prop, index = 0, length = props.length;
            for (;index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },
        prefilters: [ defaultPrefilter ],
        prefilter: function(callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };
        return opt;
    };
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || dataPriv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };
            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }
            return this.each(function() {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                data.finish = true;
                jQuery.queue(this, type, []);
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }
                delete data.finish;
            });
        }
    });
    jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
    });
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = jQuery.now();
        for (;i < timers.length; i++) {
            timer = timers[i];
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }
        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };
    jQuery.fx.stop = function() {
        window.clearInterval(timerId);
        timerId = null;
    };
    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    };
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function() {
                window.clearTimeout(timeout);
            };
        });
    };
    (function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });
    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                elem.setAttribute(name, value + "");
                return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name;
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false;
                    }
                    elem.removeAttribute(name);
                }
            }
        }
    });
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });
    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }
            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }
                return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }
            return elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    });
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function(elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }
    jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }
            if (typeof value === "string" && value) {
                classes = value.match(rnotwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }
            if (!arguments.length) {
                return this.attr("class", "");
            }
            if (typeof value === "string" && value) {
                classes = value.match(rnotwhite) || [];
                while (elem = this[i++]) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
                    if (cur) {
                        j = 0;
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(" " + clazz + " ") > -1) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }
            return this.each(function() {
                var className, i, self, classNames;
                if (type === "string") {
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnotwhite) || [];
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {
                        dataPriv.set(this, "__className__", className);
                    }
                    if (this.setAttribute) {
                        this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                    }
                }
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            className = " " + selector + " ";
            while (elem = this[i++]) {
                if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }
            return false;
        }
    });
    var rreturn = /\r/g, rspaces = /[\x20\t\r\n\f]+/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val;
                if (this.nodeType !== 1) {
                    return;
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                    for (;i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) {
                                return value;
                            }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });
    jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            };
        }
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = tmp = elem = elem || document;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }
            if (type.indexOf(".") > -1) {
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }
            data = data == null ? [ event ] : jQuery.makeArray(data, [ event ]);
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (;cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type;
                handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype];
                        if (tmp) {
                            elem[ontype] = null;
                        }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }
            return event.result;
        },
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });
            jQuery.event.trigger(e, null, elem);
        }
    });
    jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    });
    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });
    support.focusin = "onfocusin" in window;
    if (!support.focusin) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);
                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;
    var nonce = jQuery.now();
    var rquery = /\?/;
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    };
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || typeof data !== "string") {
            return null;
        }
        try {
            xml = new window.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    };
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document.createElement("a");
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
        return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }
        current = dataTypes.shift();
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
                if (current === "*") {
                    current = prev;
                } else if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2];
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: true,
                context: true
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while (match = rheaders.exec(responseHeadersString)) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {
                                statusCode[code] = [ statusCode[code], map[code] ];
                            }
                        } else {
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
            s.type = options.method || options.type || s.method || s.type;
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ];
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");
                try {
                    urlAnchor.href = s.url;
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = true;
                }
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) {
                return jqXHR;
            }
            fireGlobals = jQuery.event && s.global;
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            cacheURL = s.url;
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data;
                    delete s.data;
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort();
            }
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [ jqXHR, s ]);
                }
                if (state === 2) {
                    return jqXHR;
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }
                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    if (state < 2) {
                        done(-1, e);
                    } else {
                        throw e;
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) {
                    return;
                }
                state = 2;
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                isSuccess = status >= 200 && status < 300 || status === 304;
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess);
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";
                    } else if (status === 304) {
                        statusText = "notmodified";
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]);
                } else {
                    deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]);
                }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]);
                }
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]);
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]);
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });
    jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    });
    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            throws: true
        });
    };
    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }
            return this.each(function() {
                var self = jQuery(this), contents = self.contents();
                if (contents.length) {
                    contents.wrapAll(html);
                } else {
                    self.append(html);
                }
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });
    jQuery.expr.filters.hidden = function(elem) {
        return !jQuery.expr.filters.visible(elem);
    };
    jQuery.expr.filters.visible = function(elem) {
        return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v);
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
                }
            });
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }
        } else {
            add(prefix, obj);
        }
    }
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function() {
                add(this.name, this.value);
            });
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }
        return s.join("&").replace(r20, "+");
    };
    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr();
                    xhr.open(options.type, options.url, options.async, options.username, options.password);
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {
                                    if (typeof xhr.status !== "number") {
                                        complete(0, "error");
                                    } else {
                                        complete(xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                        binary: xhr.response
                                    } : {
                                        text: xhr.responseText
                                    }, xhr.getAllResponseHeaders());
                                }
                            }
                        };
                    };
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback("error");
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState === 4) {
                                window.setTimeout(function() {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        };
                    }
                    callback = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {
                        if (callback) {
                            throw e;
                        }
                    }
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    });
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            this[callback] = true;
            return callback;
        }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            };
            jqXHR.always(function() {
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);
                } else {
                    window[callbackName] = overwritten;
                }
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName);
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        if (parsed) {
            return [ context.createElement(parsed[1]) ];
        }
        parsed = buildFragment([ data ], context, scripts);
        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }
        var selector, type, response, self = this, off = url.indexOf(" ");
        if (off > -1) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
            callback = params;
            params = undefined;
        } else if (params && typeof params === "object") {
            type = "POST";
        }
        if (self.length > 0) {
            jQuery.ajax({
                url: url,
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function(responseText) {
                response = arguments;
                self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
            }).always(callback && function(jqXHR, status) {
                self.each(function() {
                    callback.apply(this, response || [ jqXHR.responseText, status, jqXHR ]);
                });
            });
        }
        return this;
    };
    jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    });
    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            if (position === "static") {
                elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };
    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }
            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;
            if (!doc) {
                return;
            }
            docElem = doc.documentElement;
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }
            box = elem.getBoundingClientRect();
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },
        position: function() {
            if (!this[0]) {
                return;
            }
            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect();
            } else {
                offsetParent = this.offsetParent();
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent;
                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || documentElement;
            });
        }
    });
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }
                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        };
    });
    jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name];
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        size: function() {
            return this.length;
        }
    });
    jQuery.fn.andSelf = jQuery.fn.addBack;
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }
    var _jQuery = window.jQuery, _$ = window.$;
    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }
        return jQuery;
    };
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }
    return jQuery;
});

+function($) {
    "use strict";
    var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
    };
    Button.VERSION = "3.3.7";
    Button.DEFAULTS = {
        loadingText: "loading..."
    };
    Button.prototype.setState = function(state) {
        var d = "disabled";
        var $el = this.$element;
        var val = $el.is("input") ? "val" : "html";
        var data = $el.data();
        state += "Text";
        if (data.resetText == null) $el.data("resetText", $el[val]());
        setTimeout($.proxy(function() {
            $el[val](data[state] == null ? this.options[state] : data[state]);
            if (state == "loadingText") {
                this.isLoading = true;
                $el.addClass(d).attr(d, d).prop(d, true);
            } else if (this.isLoading) {
                this.isLoading = false;
                $el.removeClass(d).removeAttr(d).prop(d, false);
            }
        }, this), 0);
    };
    Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            if ($input.prop("type") == "radio") {
                if ($input.prop("checked")) changed = false;
                $parent.find(".active").removeClass("active");
                this.$element.addClass("active");
            } else if ($input.prop("type") == "checkbox") {
                if ($input.prop("checked") !== this.$element.hasClass("active")) changed = false;
                this.$element.toggleClass("active");
            }
            $input.prop("checked", this.$element.hasClass("active"));
            if (changed) $input.trigger("change");
        } else {
            this.$element.attr("aria-pressed", !this.$element.hasClass("active"));
            this.$element.toggleClass("active");
        }
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.button");
            var options = typeof option == "object" && option;
            if (!data) $this.data("bs.button", data = new Button(this, options));
            if (option == "toggle") data.toggle(); else if (option) data.setState(option);
        });
    }
    var old = $.fn.button;
    $.fn.button = Plugin;
    $.fn.button.Constructor = Button;
    $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
    };
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle");
        if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
            e.preventDefault();
            if ($btn.is("input,button")) $btn.trigger("focus"); else $btn.find("input:visible,button:visible").first().trigger("focus");
        }
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery);

(function(root, factory) {
    if (typeof define === "function" && define.amd && define.amd.dust === true) {
        define("dust.core", [], factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        root.dust = factory();
    }
})(this, function() {
    var dust = {
        version: "2.7.5"
    }, NONE = "NONE", ERROR = "ERROR", WARN = "WARN", INFO = "INFO", DEBUG = "DEBUG", EMPTY_FUNC = function() {};
    dust.config = {
        whitespace: false,
        amd: false,
        cjs: false,
        cache: true
    };
    dust._aliases = {
        write: "w",
        end: "e",
        map: "m",
        render: "r",
        reference: "f",
        section: "s",
        exists: "x",
        notexists: "nx",
        block: "b",
        partial: "p",
        helper: "h"
    };
    (function initLogging() {
        var loggingLevels = {
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3,
            NONE: 4
        }, consoleLog, log;
        if (typeof console !== "undefined" && console.log) {
            consoleLog = console.log;
            if (typeof consoleLog === "function") {
                log = function() {
                    consoleLog.apply(console, arguments);
                };
            } else {
                log = function() {
                    consoleLog(Array.prototype.slice.apply(arguments).join(" "));
                };
            }
        } else {
            log = EMPTY_FUNC;
        }
        dust.log = function(message, type) {
            type = type || INFO;
            if (loggingLevels[type] >= loggingLevels[dust.debugLevel]) {
                log("[DUST:" + type + "]", message);
            }
        };
        dust.debugLevel = NONE;
        if (typeof process !== "undefined" && process.env && /\bdust\b/.test(process.env.DEBUG)) {
            dust.debugLevel = DEBUG;
        }
    })();
    dust.helpers = {};
    dust.cache = {};
    dust.register = function(name, tmpl) {
        if (!name) {
            return;
        }
        tmpl.templateName = name;
        if (dust.config.cache !== false) {
            dust.cache[name] = tmpl;
        }
    };
    dust.render = function(nameOrTemplate, context, callback) {
        var chunk = new Stub(callback).head;
        try {
            load(nameOrTemplate, chunk, context).end();
        } catch (err) {
            chunk.setError(err);
        }
    };
    dust.stream = function(nameOrTemplate, context) {
        var stream = new Stream(), chunk = stream.head;
        dust.nextTick(function() {
            try {
                load(nameOrTemplate, chunk, context).end();
            } catch (err) {
                chunk.setError(err);
            }
        });
        return stream;
    };
    function getTemplate(nameOrTemplate, loadFromCache) {
        if (!nameOrTemplate) {
            return;
        }
        if (typeof nameOrTemplate === "function" && nameOrTemplate.template) {
            return nameOrTemplate.template;
        }
        if (dust.isTemplateFn(nameOrTemplate)) {
            return nameOrTemplate;
        }
        if (loadFromCache !== false) {
            return dust.cache[nameOrTemplate];
        }
    }
    function load(nameOrTemplate, chunk, context) {
        if (!nameOrTemplate) {
            return chunk.setError(new Error("No template or template name provided to render"));
        }
        var template = getTemplate(nameOrTemplate, dust.config.cache);
        if (template) {
            return template(chunk, Context.wrap(context, template.templateName));
        } else {
            if (dust.onLoad) {
                return chunk.map(function(chunk) {
                    var name = nameOrTemplate;
                    function done(err, srcOrTemplate) {
                        var template;
                        if (err) {
                            return chunk.setError(err);
                        }
                        template = getTemplate(srcOrTemplate, false) || getTemplate(name, dust.config.cache);
                        if (!template) {
                            if (dust.compile) {
                                template = dust.loadSource(dust.compile(srcOrTemplate, name));
                            } else {
                                return chunk.setError(new Error("Dust compiler not available"));
                            }
                        }
                        template(chunk, Context.wrap(context, template.templateName)).end();
                    }
                    if (dust.onLoad.length === 3) {
                        dust.onLoad(name, context.options, done);
                    } else {
                        dust.onLoad(name, done);
                    }
                });
            }
            return chunk.setError(new Error("Template Not Found: " + nameOrTemplate));
        }
    }
    dust.loadSource = function(source) {
        return eval(source);
    };
    if (Array.isArray) {
        dust.isArray = Array.isArray;
    } else {
        dust.isArray = function(arr) {
            return Object.prototype.toString.call(arr) === "[object Array]";
        };
    }
    dust.nextTick = function() {
        return function(callback) {
            setTimeout(callback, 0);
        };
    }();
    dust.isEmpty = function(value) {
        if (value === 0) {
            return false;
        }
        if (dust.isArray(value) && !value.length) {
            return true;
        }
        return !value;
    };
    dust.isEmptyObject = function(obj) {
        var key;
        if (obj === null) {
            return false;
        }
        if (obj === undefined) {
            return false;
        }
        if (obj.length > 0) {
            return false;
        }
        for (key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    };
    dust.isTemplateFn = function(elem) {
        return typeof elem === "function" && elem.__dustBody;
    };
    dust.isThenable = function(elem) {
        return elem && typeof elem === "object" && typeof elem.then === "function";
    };
    dust.isStreamable = function(elem) {
        return elem && typeof elem.on === "function" && typeof elem.pipe === "function";
    };
    dust.filter = function(string, auto, filters, context) {
        var i, len, name, filter;
        if (filters) {
            for (i = 0, len = filters.length; i < len; i++) {
                name = filters[i];
                if (!name.length) {
                    continue;
                }
                filter = dust.filters[name];
                if (name === "s") {
                    auto = null;
                } else if (typeof filter === "function") {
                    string = filter(string, context);
                } else {
                    dust.log("Invalid filter `" + name + "`", WARN);
                }
            }
        }
        if (auto) {
            string = dust.filters[auto](string, context);
        }
        return string;
    };
    dust.filters = {
        h: function(value) {
            return dust.escapeHtml(value);
        },
        j: function(value) {
            return dust.escapeJs(value);
        },
        u: encodeURI,
        uc: encodeURIComponent,
        js: function(value) {
            return dust.escapeJSON(value);
        },
        jp: function(value) {
            if (!JSON) {
                dust.log("JSON is undefined; could not parse `" + value + "`", WARN);
                return value;
            } else {
                return JSON.parse(value);
            }
        }
    };
    function Context(stack, global, options, blocks, templateName) {
        if (stack !== undefined && !(stack instanceof Stack)) {
            stack = new Stack(stack);
        }
        this.stack = stack;
        this.global = global;
        this.options = options;
        this.blocks = blocks;
        this.templateName = templateName;
        this._isContext = true;
    }
    dust.makeBase = dust.context = function(global, options) {
        return new Context(undefined, global, options);
    };
    dust.isContext = function(obj) {
        return typeof obj === "object" && obj._isContext === true;
    };
    function getWithResolvedData(ctx, cur, down) {
        return function(data) {
            return ctx.push(data)._get(cur, down);
        };
    }
    Context.wrap = function(context, name) {
        if (dust.isContext(context)) {
            return context;
        }
        return new Context(context, {}, {}, null, name);
    };
    Context.prototype.get = function(path, cur) {
        if (typeof path === "string") {
            if (path[0] === ".") {
                cur = true;
                path = path.substr(1);
            }
            path = path.split(".");
        }
        return this._get(cur, path);
    };
    Context.prototype._get = function(cur, down) {
        var ctx = this.stack || {}, i = 1, value, first, len, ctxThis, fn;
        first = down[0];
        len = down.length;
        if (cur && len === 0) {
            ctxThis = ctx;
            ctx = ctx.head;
        } else {
            if (!cur) {
                while (ctx) {
                    if (ctx.isObject) {
                        ctxThis = ctx.head;
                        value = ctx.head[first];
                        if (value !== undefined) {
                            break;
                        }
                    }
                    ctx = ctx.tail;
                }
                if (value !== undefined) {
                    ctx = value;
                } else {
                    ctx = this.global && this.global[first];
                }
            } else if (ctx) {
                if (ctx.head) {
                    ctx = ctx.head[first];
                } else {
                    ctx = undefined;
                }
            }
            while (ctx && i < len) {
                if (dust.isThenable(ctx)) {
                    return ctx.then(getWithResolvedData(this, cur, down.slice(i)));
                }
                ctxThis = ctx;
                ctx = ctx[down[i]];
                i++;
            }
        }
        if (typeof ctx === "function") {
            fn = function() {
                try {
                    return ctx.apply(ctxThis, arguments);
                } catch (err) {
                    dust.log(err, ERROR);
                    throw err;
                }
            };
            fn.__dustBody = !!ctx.__dustBody;
            return fn;
        } else {
            if (ctx === undefined) {
                dust.log("Cannot find reference `{" + down.join(".") + "}` in template `" + this.getTemplateName() + "`", INFO);
            }
            return ctx;
        }
    };
    Context.prototype.getPath = function(cur, down) {
        return this._get(cur, down);
    };
    Context.prototype.push = function(head, idx, len) {
        if (head === undefined) {
            dust.log("Not pushing an undefined variable onto the context", INFO);
            return this;
        }
        return this.rebase(new Stack(head, this.stack, idx, len));
    };
    Context.prototype.pop = function() {
        var head = this.current();
        this.stack = this.stack && this.stack.tail;
        return head;
    };
    Context.prototype.rebase = function(head) {
        return new Context(head, this.global, this.options, this.blocks, this.getTemplateName());
    };
    Context.prototype.clone = function() {
        var context = this.rebase();
        context.stack = this.stack;
        return context;
    };
    Context.prototype.current = function() {
        return this.stack && this.stack.head;
    };
    Context.prototype.getBlock = function(key) {
        var blocks, len, fn;
        if (typeof key === "function") {
            key = key(new Chunk(), this).data.join("");
        }
        blocks = this.blocks;
        if (!blocks) {
            dust.log("No blocks for context `" + key + "` in template `" + this.getTemplateName() + "`", DEBUG);
            return false;
        }
        len = blocks.length;
        while (len--) {
            fn = blocks[len][key];
            if (fn) {
                return fn;
            }
        }
        dust.log("Malformed template `" + this.getTemplateName() + "` was missing one or more blocks.");
        return false;
    };
    Context.prototype.shiftBlocks = function(locals) {
        var blocks = this.blocks, newBlocks;
        if (locals) {
            if (!blocks) {
                newBlocks = [ locals ];
            } else {
                newBlocks = blocks.concat([ locals ]);
            }
            return new Context(this.stack, this.global, this.options, newBlocks, this.getTemplateName());
        }
        return this;
    };
    Context.prototype.resolve = function(body) {
        var chunk;
        if (typeof body !== "function") {
            return body;
        }
        chunk = new Chunk().render(body, this);
        if (chunk instanceof Chunk) {
            return chunk.data.join("");
        }
        return chunk;
    };
    Context.prototype.getTemplateName = function() {
        return this.templateName;
    };
    function Stack(head, tail, idx, len) {
        this.tail = tail;
        this.isObject = head && typeof head === "object";
        this.head = head;
        this.index = idx;
        this.of = len;
    }
    function Stub(callback) {
        this.head = new Chunk(this);
        this.callback = callback;
        this.out = "";
    }
    Stub.prototype.flush = function() {
        var chunk = this.head;
        while (chunk) {
            if (chunk.flushable) {
                this.out += chunk.data.join("");
            } else if (chunk.error) {
                this.callback(chunk.error);
                dust.log("Rendering failed with error `" + chunk.error + "`", ERROR);
                this.flush = EMPTY_FUNC;
                return;
            } else {
                return;
            }
            chunk = chunk.next;
            this.head = chunk;
        }
        this.callback(null, this.out);
    };
    function Stream() {
        this.head = new Chunk(this);
    }
    Stream.prototype.flush = function() {
        var chunk = this.head;
        while (chunk) {
            if (chunk.flushable) {
                this.emit("data", chunk.data.join(""));
            } else if (chunk.error) {
                this.emit("error", chunk.error);
                this.emit("end");
                dust.log("Streaming failed with error `" + chunk.error + "`", ERROR);
                this.flush = EMPTY_FUNC;
                return;
            } else {
                return;
            }
            chunk = chunk.next;
            this.head = chunk;
        }
        this.emit("end");
    };
    Stream.prototype.emit = function(type, data) {
        var events = this.events || {}, handlers = events[type] || [], i, l;
        if (!handlers.length) {
            dust.log("Stream broadcasting, but no listeners for `" + type + "`", DEBUG);
            return false;
        }
        handlers = handlers.slice(0);
        for (i = 0, l = handlers.length; i < l; i++) {
            handlers[i](data);
        }
        return true;
    };
    Stream.prototype.on = function(type, callback) {
        var events = this.events = this.events || {}, handlers = events[type] = events[type] || [];
        if (typeof callback !== "function") {
            dust.log("No callback function provided for `" + type + "` event listener", WARN);
        } else {
            handlers.push(callback);
        }
        return this;
    };
    Stream.prototype.pipe = function(stream) {
        if (typeof stream.write !== "function" || typeof stream.end !== "function") {
            dust.log("Incompatible stream passed to `pipe`", WARN);
            return this;
        }
        var destEnded = false;
        if (typeof stream.emit === "function") {
            stream.emit("pipe", this);
        }
        if (typeof stream.on === "function") {
            stream.on("error", function() {
                destEnded = true;
            });
        }
        return this.on("data", function(data) {
            if (destEnded) {
                return;
            }
            try {
                stream.write(data, "utf8");
            } catch (err) {
                dust.log(err, ERROR);
            }
        }).on("end", function() {
            if (destEnded) {
                return;
            }
            try {
                stream.end();
                destEnded = true;
            } catch (err) {
                dust.log(err, ERROR);
            }
        });
    };
    function Chunk(root, next, taps) {
        this.root = root;
        this.next = next;
        this.data = [];
        this.flushable = false;
        this.taps = taps;
    }
    Chunk.prototype.write = function(data) {
        var taps = this.taps;
        if (taps) {
            data = taps.go(data);
        }
        this.data.push(data);
        return this;
    };
    Chunk.prototype.end = function(data) {
        if (data) {
            this.write(data);
        }
        this.flushable = true;
        this.root.flush();
        return this;
    };
    Chunk.prototype.map = function(callback) {
        var cursor = new Chunk(this.root, this.next, this.taps), branch = new Chunk(this.root, cursor, this.taps);
        this.next = branch;
        this.flushable = true;
        try {
            callback(branch);
        } catch (err) {
            dust.log(err, ERROR);
            branch.setError(err);
        }
        return cursor;
    };
    Chunk.prototype.tap = function(tap) {
        var taps = this.taps;
        if (taps) {
            this.taps = taps.push(tap);
        } else {
            this.taps = new Tap(tap);
        }
        return this;
    };
    Chunk.prototype.untap = function() {
        this.taps = this.taps.tail;
        return this;
    };
    Chunk.prototype.render = function(body, context) {
        return body(this, context);
    };
    Chunk.prototype.reference = function(elem, context, auto, filters) {
        if (typeof elem === "function") {
            elem = elem.apply(context.current(), [ this, context, null, {
                auto: auto,
                filters: filters
            } ]);
            if (elem instanceof Chunk) {
                return elem;
            } else {
                return this.reference(elem, context, auto, filters);
            }
        }
        if (dust.isThenable(elem)) {
            return this.await(elem, context, null, auto, filters);
        } else if (dust.isStreamable(elem)) {
            return this.stream(elem, context, null, auto, filters);
        } else if (!dust.isEmpty(elem)) {
            return this.write(dust.filter(elem, auto, filters, context));
        } else {
            return this;
        }
    };
    Chunk.prototype.section = function(elem, context, bodies, params) {
        var body = bodies.block, skip = bodies["else"], chunk = this, i, len, head;
        if (typeof elem === "function" && !dust.isTemplateFn(elem)) {
            try {
                elem = elem.apply(context.current(), [ this, context, bodies, params ]);
            } catch (err) {
                dust.log(err, ERROR);
                return this.setError(err);
            }
            if (elem instanceof Chunk) {
                return elem;
            }
        }
        if (dust.isEmptyObject(bodies)) {
            return chunk;
        }
        if (!dust.isEmptyObject(params)) {
            context = context.push(params);
        }
        if (dust.isArray(elem)) {
            if (body) {
                len = elem.length;
                if (len > 0) {
                    head = context.stack && context.stack.head || {};
                    head.$len = len;
                    for (i = 0; i < len; i++) {
                        head.$idx = i;
                        chunk = body(chunk, context.push(elem[i], i, len));
                    }
                    head.$idx = undefined;
                    head.$len = undefined;
                    return chunk;
                } else if (skip) {
                    return skip(this, context);
                }
            }
        } else if (dust.isThenable(elem)) {
            return this.await(elem, context, bodies);
        } else if (dust.isStreamable(elem)) {
            return this.stream(elem, context, bodies);
        } else if (elem === true) {
            if (body) {
                return body(this, context);
            }
        } else if (elem || elem === 0) {
            if (body) {
                return body(this, context.push(elem));
            }
        } else if (skip) {
            return skip(this, context);
        }
        dust.log("Section without corresponding key in template `" + context.getTemplateName() + "`", DEBUG);
        return this;
    };
    Chunk.prototype.exists = function(elem, context, bodies) {
        var body = bodies.block, skip = bodies["else"];
        if (!dust.isEmpty(elem)) {
            if (body) {
                return body(this, context);
            }
            dust.log("No block for exists check in template `" + context.getTemplateName() + "`", DEBUG);
        } else if (skip) {
            return skip(this, context);
        }
        return this;
    };
    Chunk.prototype.notexists = function(elem, context, bodies) {
        var body = bodies.block, skip = bodies["else"];
        if (dust.isEmpty(elem)) {
            if (body) {
                return body(this, context);
            }
            dust.log("No block for not-exists check in template `" + context.getTemplateName() + "`", DEBUG);
        } else if (skip) {
            return skip(this, context);
        }
        return this;
    };
    Chunk.prototype.block = function(elem, context, bodies) {
        var body = elem || bodies.block;
        if (body) {
            return body(this, context);
        }
        return this;
    };
    Chunk.prototype.partial = function(elem, context, partialContext, params) {
        var head;
        if (params === undefined) {
            params = partialContext;
            partialContext = context;
        }
        if (!dust.isEmptyObject(params)) {
            partialContext = partialContext.clone();
            head = partialContext.pop();
            partialContext = partialContext.push(params).push(head);
        }
        if (dust.isTemplateFn(elem)) {
            return this.capture(elem, context, function(name, chunk) {
                partialContext.templateName = name;
                load(name, chunk, partialContext).end();
            });
        } else {
            partialContext.templateName = elem;
            return load(elem, this, partialContext);
        }
    };
    Chunk.prototype.helper = function(name, context, bodies, params, auto) {
        var chunk = this, filters = params.filters, ret;
        if (auto === undefined) {
            auto = "h";
        }
        if (dust.helpers[name]) {
            try {
                ret = dust.helpers[name](chunk, context, bodies, params);
                if (ret instanceof Chunk) {
                    return ret;
                }
                if (typeof filters === "string") {
                    filters = filters.split("|");
                }
                if (!dust.isEmptyObject(bodies)) {
                    return chunk.section(ret, context, bodies, params);
                }
                return chunk.reference(ret, context, auto, filters);
            } catch (err) {
                dust.log("Error in helper `" + name + "`: " + err.message, ERROR);
                return chunk.setError(err);
            }
        } else {
            dust.log("Helper `" + name + "` does not exist", WARN);
            return chunk;
        }
    };
    Chunk.prototype.await = function(thenable, context, bodies, auto, filters) {
        return this.map(function(chunk) {
            thenable.then(function(data) {
                if (bodies) {
                    chunk = chunk.section(data, context, bodies);
                } else {
                    chunk = chunk.reference(data, context, auto, filters);
                }
                chunk.end();
            }, function(err) {
                var errorBody = bodies && bodies.error;
                if (errorBody) {
                    chunk.render(errorBody, context.push(err)).end();
                } else {
                    dust.log("Unhandled promise rejection in `" + context.getTemplateName() + "`", INFO);
                    chunk.end();
                }
            });
        });
    };
    Chunk.prototype.stream = function(stream, context, bodies, auto, filters) {
        var body = bodies && bodies.block, errorBody = bodies && bodies.error;
        return this.map(function(chunk) {
            var ended = false;
            stream.on("data", function data(thunk) {
                if (ended) {
                    return;
                }
                if (body) {
                    chunk = chunk.map(function(chunk) {
                        chunk.render(body, context.push(thunk)).end();
                    });
                } else if (!bodies) {
                    chunk = chunk.reference(thunk, context, auto, filters);
                }
            }).on("error", function error(err) {
                if (ended) {
                    return;
                }
                if (errorBody) {
                    chunk.render(errorBody, context.push(err));
                } else {
                    dust.log("Unhandled stream error in `" + context.getTemplateName() + "`", INFO);
                }
                if (!ended) {
                    ended = true;
                    chunk.end();
                }
            }).on("end", function end() {
                if (!ended) {
                    ended = true;
                    chunk.end();
                }
            });
        });
    };
    Chunk.prototype.capture = function(body, context, callback) {
        return this.map(function(chunk) {
            var stub = new Stub(function(err, out) {
                if (err) {
                    chunk.setError(err);
                } else {
                    callback(out, chunk);
                }
            });
            body(stub.head, context).end();
        });
    };
    Chunk.prototype.setError = function(err) {
        this.error = err;
        this.root.flush();
        return this;
    };
    for (var f in Chunk.prototype) {
        if (dust._aliases[f]) {
            Chunk.prototype[dust._aliases[f]] = Chunk.prototype[f];
        }
    }
    function Tap(head, tail) {
        this.head = head;
        this.tail = tail;
    }
    Tap.prototype.push = function(tap) {
        return new Tap(tap, this);
    };
    Tap.prototype.go = function(value) {
        var tap = this;
        while (tap) {
            value = tap.head(value);
            tap = tap.tail;
        }
        return value;
    };
    var HCHARS = /[&<>"']/, AMP = /&/g, LT = /</g, GT = />/g, QUOT = /\"/g, SQUOT = /\'/g;
    dust.escapeHtml = function(s) {
        if (typeof s === "string" || s && typeof s.toString === "function") {
            if (typeof s !== "string") {
                s = s.toString();
            }
            if (!HCHARS.test(s)) {
                return s;
            }
            return s.replace(AMP, "&amp;").replace(LT, "&lt;").replace(GT, "&gt;").replace(QUOT, "&quot;").replace(SQUOT, "&#39;");
        }
        return s;
    };
    var BS = /\\/g, FS = /\//g, CR = /\r/g, LS = /\u2028/g, PS = /\u2029/g, NL = /\n/g, LF = /\f/g, SQ = /'/g, DQ = /"/g, TB = /\t/g;
    dust.escapeJs = function(s) {
        if (typeof s === "string") {
            return s.replace(BS, "\\\\").replace(FS, "\\/").replace(DQ, '\\"').replace(SQ, "\\'").replace(CR, "\\r").replace(LS, "\\u2028").replace(PS, "\\u2029").replace(NL, "\\n").replace(LF, "\\f").replace(TB, "\\t");
        }
        return s;
    };
    dust.escapeJSON = function(o) {
        if (!JSON) {
            dust.log("JSON is undefined; could not escape `" + o + "`", WARN);
            return o;
        } else {
            return JSON.stringify(o).replace(LS, "\\u2028").replace(PS, "\\u2029").replace(LT, "\\u003c");
        }
    };
    return dust;
});

if (typeof define === "function" && define.amd && define.amd.dust === true) {
    define([ "require", "dust.core" ], function(require, dust) {
        dust.onLoad = function(name, cb) {
            require([ name ], function() {
                cb();
            });
        };
        return dust;
    });
}

(function(root, factory) {
    if (typeof define === "function" && define.amd && define.amd.dust === true) {
        define([ "dust.core" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("dustjs-linkedin"));
    } else {
        factory(root.dust);
    }
})(this, function(dust) {
    function log(helper, msg, level) {
        level = level || "INFO";
        helper = helper ? "{@" + helper + "}: " : "";
        dust.log(helper + msg, level);
    }
    var _deprecatedCache = {};
    function _deprecated(target) {
        if (_deprecatedCache[target]) {
            return;
        }
        log(target, "Deprecation warning: " + target + " is deprecated and will be removed in a future version of dustjs-helpers", "WARN");
        log(null, "For help and a deprecation timeline, see https://github.com/linkedin/dustjs-helpers/wiki/Deprecated-Features#" + target.replace(/\W+/g, ""), "WARN");
        _deprecatedCache[target] = true;
    }
    function isSelect(context) {
        return context.stack.tail && context.stack.tail.head && typeof context.stack.tail.head.__select__ !== "undefined";
    }
    function getSelectState(context) {
        return isSelect(context) && context.get("__select__");
    }
    function addSelectState(context, opts) {
        var head = context.stack.head, newContext = context.rebase(), key;
        if (context.stack && context.stack.tail) {
            newContext.stack = context.stack.tail;
        }
        var state = {
            isPending: false,
            isResolved: false,
            isDeferredComplete: false,
            deferreds: []
        };
        for (key in opts) {
            state[key] = opts[key];
        }
        return newContext.push({
            __select__: state
        }).push(head, context.stack.index, context.stack.of);
    }
    function resolveSelectDeferreds(state) {
        var x, len;
        state.isDeferredPending = true;
        if (state.deferreds.length) {
            state.isDeferredComplete = true;
            for (x = 0, len = state.deferreds.length; x < len; x++) {
                state.deferreds[x]();
            }
        }
        state.isDeferredPending = false;
    }
    function jsonFilter(key, value) {
        if (typeof value === "function") {
            return value.toString().replace(/(^\s+|\s+$)/gm, "").replace(/\n/gm, "").replace(/,\s*/gm, ", ").replace(/\)\{/gm, ") {");
        }
        return value;
    }
    function truthTest(name, test) {
        return function(chunk, context, bodies, params) {
            return filter(chunk, context, bodies, params, name, test);
        };
    }
    function filter(chunk, context, bodies, params, helperName, test) {
        var body = bodies.block, skip = bodies["else"], selectState = getSelectState(context) || {}, willResolve, key, value, type;
        if (selectState.isResolved && !selectState.isDeferredPending) {
            return chunk;
        }
        if (params.hasOwnProperty("key")) {
            key = params.key;
        } else if (selectState.hasOwnProperty("key")) {
            key = selectState.key;
        } else {
            log(helperName, "No key specified", "WARN");
            return chunk;
        }
        type = params.type || selectState.type;
        key = coerce(context.resolve(key), type);
        value = coerce(context.resolve(params.value), type);
        if (test(key, value)) {
            if (!selectState.isPending) {
                willResolve = true;
                selectState.isPending = true;
            }
            if (body) {
                chunk = chunk.render(body, context);
            }
            if (willResolve) {
                selectState.isResolved = true;
            }
        } else if (skip) {
            chunk = chunk.render(skip, context);
        }
        return chunk;
    }
    function coerce(value, type) {
        if (type) {
            type = type.toLowerCase();
        }
        switch (type) {
          case "number":
            return +value;

          case "string":
            return String(value);

          case "boolean":
            value = value === "false" ? false : value;
            return Boolean(value);

          case "date":
            return new Date(value);
        }
        return value;
    }
    var helpers = {
        tap: function(input, chunk, context) {
            _deprecated("tap");
            return context.resolve(input);
        },
        sep: function(chunk, context, bodies) {
            var body = bodies.block;
            if (context.stack.index === context.stack.of - 1) {
                return chunk;
            }
            if (body) {
                return body(chunk, context);
            } else {
                return chunk;
            }
        },
        first: function(chunk, context, bodies) {
            if (context.stack.index === 0) {
                return bodies.block(chunk, context);
            }
            return chunk;
        },
        last: function(chunk, context, bodies) {
            if (context.stack.index === context.stack.of - 1) {
                return bodies.block(chunk, context);
            }
            return chunk;
        },
        contextDump: function(chunk, context, bodies, params) {
            var to = context.resolve(params.to), key = context.resolve(params.key), target, output;
            switch (key) {
              case "full":
                target = context.stack;
                break;

              default:
                target = context.stack.head;
            }
            output = JSON.stringify(target, jsonFilter, 2);
            switch (to) {
              case "console":
                log("contextDump", output);
                break;

              default:
                output = output.replace(/</g, "\\u003c");
                chunk = chunk.write(output);
            }
            return chunk;
        },
        math: function(chunk, context, bodies, params) {
            var key = params.key, method = params.method, operand = params.operand, round = params.round, output, state, x, len;
            if (!params.hasOwnProperty("key") || !params.method) {
                log("math", "`key` or `method` was not provided", "ERROR");
                return chunk;
            }
            key = parseFloat(context.resolve(key));
            operand = parseFloat(context.resolve(operand));
            switch (method) {
              case "mod":
                if (operand === 0) {
                    log("math", "Division by 0", "ERROR");
                }
                output = key % operand;
                break;

              case "add":
                output = key + operand;
                break;

              case "subtract":
                output = key - operand;
                break;

              case "multiply":
                output = key * operand;
                break;

              case "divide":
                if (operand === 0) {
                    log("math", "Division by 0", "ERROR");
                }
                output = key / operand;
                break;

              case "ceil":
              case "floor":
              case "round":
              case "abs":
                output = Math[method](key);
                break;

              case "toint":
                output = parseInt(key, 10);
                break;

              default:
                log("math", "Method `" + method + "` is not supported", "ERROR");
            }
            if (typeof output !== "undefined") {
                if (round) {
                    output = Math.round(output);
                }
                if (bodies && bodies.block) {
                    context = addSelectState(context, {
                        key: output
                    });
                    chunk = chunk.render(bodies.block, context);
                    resolveSelectDeferreds(getSelectState(context));
                } else {
                    chunk = chunk.write(output);
                }
            }
            return chunk;
        },
        select: function(chunk, context, bodies, params) {
            var body = bodies.block, state = {};
            if (params.hasOwnProperty("key")) {
                state.key = context.resolve(params.key);
            }
            if (params.hasOwnProperty("type")) {
                state.type = params.type;
            }
            if (body) {
                context = addSelectState(context, state);
                chunk = chunk.render(body, context);
                resolveSelectDeferreds(getSelectState(context));
            } else {
                log("select", "Missing body block", "WARN");
            }
            return chunk;
        },
        eq: truthTest("eq", function(left, right) {
            return left === right;
        }),
        ne: truthTest("ne", function(left, right) {
            return left !== right;
        }),
        lt: truthTest("lt", function(left, right) {
            return left < right;
        }),
        lte: truthTest("lte", function(left, right) {
            return left <= right;
        }),
        gt: truthTest("gt", function(left, right) {
            return left > right;
        }),
        gte: truthTest("gte", function(left, right) {
            return left >= right;
        }),
        any: function(chunk, context, bodies, params) {
            var selectState = getSelectState(context);
            if (!selectState) {
                log("any", "Must be used inside a {@select} block", "ERROR");
            } else {
                if (selectState.isDeferredComplete) {
                    log("any", "Must not be nested inside {@any} or {@none} block", "ERROR");
                } else {
                    chunk = chunk.map(function(chunk) {
                        selectState.deferreds.push(function() {
                            if (selectState.isResolved) {
                                chunk = chunk.render(bodies.block, context);
                            }
                            chunk.end();
                        });
                    });
                }
            }
            return chunk;
        },
        none: function(chunk, context, bodies, params) {
            var selectState = getSelectState(context);
            if (!selectState) {
                log("none", "Must be used inside a {@select} block", "ERROR");
            } else {
                if (selectState.isDeferredComplete) {
                    log("none", "Must not be nested inside {@any} or {@none} block", "ERROR");
                } else {
                    chunk = chunk.map(function(chunk) {
                        selectState.deferreds.push(function() {
                            if (!selectState.isResolved) {
                                chunk = chunk.render(bodies.block, context);
                            }
                            chunk.end();
                        });
                    });
                }
            }
            return chunk;
        },
        size: function(chunk, context, bodies, params) {
            var key = params.key, value, k;
            key = context.resolve(params.key);
            if (!key || key === true) {
                value = 0;
            } else if (dust.isArray(key)) {
                value = key.length;
            } else if (!isNaN(parseFloat(key)) && isFinite(key)) {
                value = key;
            } else if (typeof key === "object") {
                value = 0;
                for (k in key) {
                    if (key.hasOwnProperty(k)) {
                        value++;
                    }
                }
            } else {
                value = (key + "").length;
            }
            return chunk.write(value);
        }
    };
    for (var key in helpers) {
        dust.helpers[key] = helpers[key];
    }
    return dust;
});

(function(root, factory) {
    "use strict";
    if (typeof define === "function" && define.amd) {
        define(factory);
    } else if (typeof exports === "object") {
        module.exports = factory();
    } else {
        root.returnExports = factory();
    }
})(this, function() {
    var ArrayPrototype = Array.prototype;
    var ObjectPrototype = Object.prototype;
    var FunctionPrototype = Function.prototype;
    var StringPrototype = String.prototype;
    var NumberPrototype = Number.prototype;
    var array_slice = ArrayPrototype.slice;
    var array_splice = ArrayPrototype.splice;
    var array_push = ArrayPrototype.push;
    var array_unshift = ArrayPrototype.unshift;
    var call = FunctionPrototype.call;
    var to_string = ObjectPrototype.toString;
    var isFunction = function(val) {
        return to_string.call(val) === "[object Function]";
    };
    var isRegex = function(val) {
        return to_string.call(val) === "[object RegExp]";
    };
    var isArray = function isArray(obj) {
        return to_string.call(obj) === "[object Array]";
    };
    var isString = function isString(obj) {
        return to_string.call(obj) === "[object String]";
    };
    var isArguments = function isArguments(value) {
        var str = to_string.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
            isArgs = !isArray(value) && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && isFunction(value.callee);
        }
        return isArgs;
    };
    var defineProperties = function(has) {
        var supportsDescriptors = Object.defineProperty && function() {
            try {
                Object.defineProperty({}, "x", {});
                return true;
            } catch (e) {
                return false;
            }
        }();
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function(object, name, method, forceAssign) {
                if (!forceAssign && name in object) {
                    return;
                }
                Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function(object, name, method, forceAssign) {
                if (!forceAssign && name in object) {
                    return;
                }
                object[name] = method;
            };
        }
        return function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (has.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };
    }(ObjectPrototype.hasOwnProperty);
    function toInteger(num) {
        var n = +num;
        if (n !== n) {
            n = 0;
        } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
            n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
        return n;
    }
    function isPrimitive(input) {
        var type = typeof input;
        return input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string";
    }
    function toPrimitive(input) {
        var val, valueOf, toStr;
        if (isPrimitive(input)) {
            return input;
        }
        valueOf = input.valueOf;
        if (isFunction(valueOf)) {
            val = valueOf.call(input);
            if (isPrimitive(val)) {
                return val;
            }
        }
        toStr = input.toString;
        if (isFunction(toStr)) {
            val = toStr.call(input);
            if (isPrimitive(val)) {
                return val;
            }
        }
        throw new TypeError();
    }
    var ES = {
        ToObject: function(o) {
            if (o == null) {
                throw new TypeError("can't convert " + o + " to object");
            }
            return Object(o);
        },
        ToUint32: function ToUint32(x) {
            return x >>> 0;
        }
    };
    var Empty = function Empty() {};
    defineProperties(FunctionPrototype, {
        bind: function bind(that) {
            var target = this;
            if (!isFunction(target)) {
                throw new TypeError("Function.prototype.bind called on incompatible " + target);
            }
            var args = array_slice.call(arguments, 1);
            var bound;
            var binder = function() {
                if (this instanceof bound) {
                    var result = target.apply(this, args.concat(array_slice.call(arguments)));
                    if (Object(result) === result) {
                        return result;
                    }
                    return this;
                } else {
                    return target.apply(that, args.concat(array_slice.call(arguments)));
                }
            };
            var boundLength = Math.max(0, target.length - args.length);
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                boundArgs.push("$" + i);
            }
            bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this, arguments); }")(binder);
            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                Empty.prototype = null;
            }
            return bound;
        }
    });
    var owns = call.bind(ObjectPrototype.hasOwnProperty);
    var spliceNoopReturnsEmptyArray = function() {
        var a = [ 1, 2 ];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
    }();
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            } else {
                return array_splice.apply(this, arguments);
            }
        }
    }, !spliceNoopReturnsEmptyArray);
    var spliceWorksWithEmptyObject = function() {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
    }();
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            var args = arguments;
            this.length = Math.max(toInteger(this.length), 0);
            if (arguments.length > 0 && typeof deleteCount !== "number") {
                args = array_slice.call(arguments);
                if (args.length < 2) {
                    args.push(this.length - start);
                } else {
                    args[1] = toInteger(deleteCount);
                }
            }
            return array_splice.apply(this, args);
        }
    }, !spliceWorksWithEmptyObject);
    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
    defineProperties(ArrayPrototype, {
        unshift: function() {
            array_unshift.apply(this, arguments);
            return this.length;
        }
    }, hasUnshiftReturnValueBug);
    defineProperties(Array, {
        isArray: isArray
    });
    var boxedString = Object("a");
    var splitString = boxedString[0] !== "a" || !(0 in boxedString);
    var properlyBoxesContext = function properlyBoxed(method) {
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        if (method) {
            method.call("foo", function(_, __, context) {
                if (typeof context !== "object") {
                    properlyBoxesNonStrict = false;
                }
            });
            method.call([ 1 ], function() {
                "use strict";
                properlyBoxesStrict = typeof this === "string";
            }, "x");
        }
        return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
    };
    defineProperties(ArrayPrototype, {
        forEach: function forEach(fun) {
            var object = ES.ToObject(this), self = splitString && isString(this) ? this.split("") : object, thisp = arguments[1], i = -1, length = self.length >>> 0;
            if (!isFunction(fun)) {
                throw new TypeError();
            }
            while (++i < length) {
                if (i in self) {
                    fun.call(thisp, self[i], i, object);
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));
    defineProperties(ArrayPrototype, {
        map: function map(fun) {
            var object = ES.ToObject(this), self = splitString && isString(this) ? this.split("") : object, length = self.length >>> 0, result = Array(length), thisp = arguments[1];
            if (!isFunction(fun)) {
                throw new TypeError(fun + " is not a function");
            }
            for (var i = 0; i < length; i++) {
                if (i in self) {
                    result[i] = fun.call(thisp, self[i], i, object);
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.map));
    defineProperties(ArrayPrototype, {
        filter: function filter(fun) {
            var object = ES.ToObject(this), self = splitString && isString(this) ? this.split("") : object, length = self.length >>> 0, result = [], value, thisp = arguments[1];
            if (!isFunction(fun)) {
                throw new TypeError(fun + " is not a function");
            }
            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (fun.call(thisp, value, i, object)) {
                        result.push(value);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.filter));
    defineProperties(ArrayPrototype, {
        every: function every(fun) {
            var object = ES.ToObject(this), self = splitString && isString(this) ? this.split("") : object, length = self.length >>> 0, thisp = arguments[1];
            if (!isFunction(fun)) {
                throw new TypeError(fun + " is not a function");
            }
            for (var i = 0; i < length; i++) {
                if (i in self && !fun.call(thisp, self[i], i, object)) {
                    return false;
                }
            }
            return true;
        }
    }, !properlyBoxesContext(ArrayPrototype.every));
    defineProperties(ArrayPrototype, {
        some: function some(fun) {
            var object = ES.ToObject(this), self = splitString && isString(this) ? this.split("") : object, length = self.length >>> 0, thisp = arguments[1];
            if (!isFunction(fun)) {
                throw new TypeError(fun + " is not a function");
            }
            for (var i = 0; i < length; i++) {
                if (i in self && fun.call(thisp, self[i], i, object)) {
                    return true;
                }
            }
            return false;
        }
    }, !properlyBoxesContext(ArrayPrototype.some));
    var reduceCoercesToObject = false;
    if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call("es5", function(_, __, ___, list) {
            return list;
        }) === "object";
    }
    defineProperties(ArrayPrototype, {
        reduce: function reduce(fun) {
            var object = ES.ToObject(this), self = splitString && isString(this) ? this.split("") : object, length = self.length >>> 0;
            if (!isFunction(fun)) {
                throw new TypeError(fun + " is not a function");
            }
            if (!length && arguments.length === 1) {
                throw new TypeError("reduce of empty array with no initial value");
            }
            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }
                    if (++i >= length) {
                        throw new TypeError("reduce of empty array with no initial value");
                    }
                } while (true);
            }
            for (;i < length; i++) {
                if (i in self) {
                    result = fun.call(void 0, result, self[i], i, object);
                }
            }
            return result;
        }
    }, !reduceCoercesToObject);
    var reduceRightCoercesToObject = false;
    if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call("es5", function(_, __, ___, list) {
            return list;
        }) === "object";
    }
    defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(fun) {
            var object = ES.ToObject(this), self = splitString && isString(this) ? this.split("") : object, length = self.length >>> 0;
            if (!isFunction(fun)) {
                throw new TypeError(fun + " is not a function");
            }
            if (!length && arguments.length === 1) {
                throw new TypeError("reduceRight of empty array with no initial value");
            }
            var result, i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }
                    if (--i < 0) {
                        throw new TypeError("reduceRight of empty array with no initial value");
                    }
                } while (true);
            }
            if (i < 0) {
                return result;
            }
            do {
                if (i in self) {
                    result = fun.call(void 0, result, self[i], i, object);
                }
            } while (i--);
            return result;
        }
    }, !reduceRightCoercesToObject);
    var hasFirefox2IndexOfBug = Array.prototype.indexOf && [ 0, 1 ].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(sought) {
            var self = splitString && isString(this) ? this.split("") : ES.ToObject(this), length = self.length >>> 0;
            if (!length) {
                return -1;
            }
            var i = 0;
            if (arguments.length > 1) {
                i = toInteger(arguments[1]);
            }
            i = i >= 0 ? i : Math.max(0, length + i);
            for (;i < length; i++) {
                if (i in self && self[i] === sought) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);
    var hasFirefox2LastIndexOfBug = Array.prototype.lastIndexOf && [ 0, 1 ].lastIndexOf(0, -3) !== -1;
    defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(sought) {
            var self = splitString && isString(this) ? this.split("") : ES.ToObject(this), length = self.length >>> 0;
            if (!length) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = Math.min(i, toInteger(arguments[1]));
            }
            i = i >= 0 ? i : length - Math.abs(i);
            for (;i >= 0; i--) {
                if (i in self && sought === self[i]) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2LastIndexOfBug);
    var hasDontEnumBug = !{
        toString: null
    }.propertyIsEnumerable("toString"), hasProtoEnumBug = function() {}.propertyIsEnumerable("prototype"), hasStringEnumBug = !owns("x", "0"), dontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ], dontEnumsLength = dontEnums.length;
    defineProperties(Object, {
        keys: function keys(object) {
            var isFn = isFunction(object), isArgs = isArguments(object), isObject = object !== null && typeof object === "object", isStr = isObject && isString(object);
            if (!isObject && !isFn && !isArgs) {
                throw new TypeError("Object.keys called on a non-object");
            }
            var theKeys = [];
            var skipProto = hasProtoEnumBug && isFn;
            if (isStr && hasStringEnumBug || isArgs) {
                for (var i = 0; i < object.length; ++i) {
                    theKeys.push(String(i));
                }
            }
            if (!isArgs) {
                for (var name in object) {
                    if (!(skipProto && name === "prototype") && owns(object, name)) {
                        theKeys.push(String(name));
                    }
                }
            }
            if (hasDontEnumBug) {
                var ctor = object.constructor, skipConstructor = ctor && ctor.prototype === object;
                for (var j = 0; j < dontEnumsLength; j++) {
                    var dontEnum = dontEnums[j];
                    if (!(skipConstructor && dontEnum === "constructor") && owns(object, dontEnum)) {
                        theKeys.push(dontEnum);
                    }
                }
            }
            return theKeys;
        }
    });
    var keysWorksWithArguments = Object.keys && function() {
        return Object.keys(arguments).length === 2;
    }(1, 2);
    var originalKeys = Object.keys;
    defineProperties(Object, {
        keys: function keys(object) {
            if (isArguments(object)) {
                return originalKeys(ArrayPrototype.slice.call(object));
            } else {
                return originalKeys(object);
            }
        }
    }, !keysWorksWithArguments);
    var negativeDate = -621987552e5;
    var negativeYearString = "-000001";
    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
    defineProperties(Date.prototype, {
        toISOString: function toISOString() {
            var result, length, value, year, month;
            if (!isFinite(this)) {
                throw new RangeError("Date.prototype.toISOString called on non-finite value.");
            }
            year = this.getUTCFullYear();
            month = this.getUTCMonth();
            year += Math.floor(month / 12);
            month = (month % 12 + 12) % 12;
            result = [ month + 1, this.getUTCDate(), this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds() ];
            year = (year < 0 ? "-" : year > 9999 ? "+" : "") + ("00000" + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6);
            length = result.length;
            while (length--) {
                value = result[length];
                if (value < 10) {
                    result[length] = "0" + value;
                }
            }
            return year + "-" + result.slice(0, 2).join("-") + "T" + result.slice(2).join(":") + "." + ("000" + this.getUTCMilliseconds()).slice(-3) + "Z";
        }
    }, hasNegativeDateBug);
    var dateToJSONIsSupported = false;
    try {
        dateToJSONIsSupported = Date.prototype.toJSON && new Date(NaN).toJSON() === null && new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 && Date.prototype.toJSON.call({
            toISOString: function() {
                return true;
            }
        });
    } catch (e) {}
    if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
            var o = Object(this), tv = toPrimitive(o), toISO;
            if (typeof tv === "number" && !isFinite(tv)) {
                return null;
            }
            toISO = o.toISOString;
            if (typeof toISO !== "function") {
                throw new TypeError("toISOString property is not callable");
            }
            return toISO.call(o);
        };
    }
    var supportsExtendedYears = Date.parse("+033658-09-27T01:46:40.000Z") === 1e15;
    var acceptsInvalidDates = !isNaN(Date.parse("2012-04-04T24:00:00.500Z")) || !isNaN(Date.parse("2012-11-31T23:59:59.000Z"));
    var doesNotParseY2KNewYear = isNaN(Date.parse("2000-01-01T00:00:00.000Z"));
    if (!Date.parse || doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        Date = function(NativeDate) {
            function Date(Y, M, D, h, m, s, ms) {
                var length = arguments.length;
                if (this instanceof NativeDate) {
                    var date = length === 1 && String(Y) === Y ? new NativeDate(Date.parse(Y)) : length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) : length >= 6 ? new NativeDate(Y, M, D, h, m, s) : length >= 5 ? new NativeDate(Y, M, D, h, m) : length >= 4 ? new NativeDate(Y, M, D, h) : length >= 3 ? new NativeDate(Y, M, D) : length >= 2 ? new NativeDate(Y, M) : length >= 1 ? new NativeDate(Y) : new NativeDate();
                    date.constructor = Date;
                    return date;
                }
                return NativeDate.apply(this, arguments);
            }
            var isoDateExpression = new RegExp("^" + "(\\d{4}|[+-]\\d{6})" + "(?:-(\\d{2})" + "(?:-(\\d{2})" + "(?:" + "T(\\d{2})" + ":(\\d{2})" + "(?:" + ":(\\d{2})" + "(?:(\\.\\d{1,}))?" + ")?" + "(" + "Z|" + "(?:" + "([-+])" + "(\\d{2})" + ":(\\d{2})" + ")" + ")?)?)?)?" + "$");
            var months = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 ];
            function dayFromMonth(year, month) {
                var t = month > 1 ? 1 : 0;
                return months[month] + Math.floor((year - 1969 + t) / 4) - Math.floor((year - 1901 + t) / 100) + Math.floor((year - 1601 + t) / 400) + 365 * (year - 1970);
            }
            function toUTC(t) {
                return Number(new NativeDate(1970, 0, 1, 0, 0, 0, t));
            }
            for (var key in NativeDate) {
                Date[key] = NativeDate[key];
            }
            Date.now = NativeDate.now;
            Date.UTC = NativeDate.UTC;
            Date.prototype = NativeDate.prototype;
            Date.prototype.constructor = Date;
            Date.parse = function parse(string) {
                var match = isoDateExpression.exec(string);
                if (match) {
                    var year = Number(match[1]), month = Number(match[2] || 1) - 1, day = Number(match[3] || 1) - 1, hour = Number(match[4] || 0), minute = Number(match[5] || 0), second = Number(match[6] || 0), millisecond = Math.floor(Number(match[7] || 0) * 1e3), isLocalTime = Boolean(match[4] && !match[8]), signOffset = match[9] === "-" ? 1 : -1, hourOffset = Number(match[10] || 0), minuteOffset = Number(match[11] || 0), result;
                    if (hour < (minute > 0 || second > 0 || millisecond > 0 ? 24 : 25) && minute < 60 && second < 60 && millisecond < 1e3 && month > -1 && month < 12 && hourOffset < 24 && minuteOffset < 60 && day > -1 && day < dayFromMonth(year, month + 1) - dayFromMonth(year, month)) {
                        result = ((dayFromMonth(year, month) + day) * 24 + hour + hourOffset * signOffset) * 60;
                        result = ((result + minute + minuteOffset * signOffset) * 60 + second) * 1e3 + millisecond;
                        if (isLocalTime) {
                            result = toUTC(result);
                        }
                        if (-864e13 <= result && result <= 864e13) {
                            return result;
                        }
                    }
                    return NaN;
                }
                return NativeDate.parse.apply(this, arguments);
            };
            return Date;
        }(Date);
    }
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }
    var hasToFixedBugs = NumberPrototype.toFixed && (8e-5.toFixed(3) !== "0.000" || .9.toFixed(0) !== "1" || 1.255.toFixed(2) !== "1.25" || (0xde0b6b3a7640080).toFixed(0) !== "1000000000000000128");
    var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [ 0, 0, 0, 0, 0, 0 ],
        multiply: function multiply(n, c) {
            var i = -1;
            while (++i < toFixedHelpers.size) {
                c += n * toFixedHelpers.data[i];
                toFixedHelpers.data[i] = c % toFixedHelpers.base;
                c = Math.floor(c / toFixedHelpers.base);
            }
        },
        divide: function divide(n) {
            var i = toFixedHelpers.size, c = 0;
            while (--i >= 0) {
                c += toFixedHelpers.data[i];
                toFixedHelpers.data[i] = Math.floor(c / n);
                c = c % n * toFixedHelpers.base;
            }
        },
        numToString: function numToString() {
            var i = toFixedHelpers.size;
            var s = "";
            while (--i >= 0) {
                if (s !== "" || i === 0 || toFixedHelpers.data[i] !== 0) {
                    var t = String(toFixedHelpers.data[i]);
                    if (s === "") {
                        s = t;
                    } else {
                        s += "0000000".slice(0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        },
        pow: function pow(x, n, acc) {
            return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
        },
        log: function log(x) {
            var n = 0;
            while (x >= 4096) {
                n += 12;
                x /= 4096;
            }
            while (x >= 2) {
                n += 1;
                x /= 2;
            }
            return n;
        }
    };
    defineProperties(NumberPrototype, {
        toFixed: function toFixed(fractionDigits) {
            var f, x, s, m, e, z, j, k;
            f = Number(fractionDigits);
            f = f !== f ? 0 : Math.floor(f);
            if (f < 0 || f > 20) {
                throw new RangeError("Number.toFixed called with invalid number of decimals");
            }
            x = Number(this);
            if (x !== x) {
                return "NaN";
            }
            if (x <= -1e21 || x >= 1e21) {
                return String(x);
            }
            s = "";
            if (x < 0) {
                s = "-";
                x = -x;
            }
            m = "0";
            if (x > 1e-21) {
                e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
                z = e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1);
                z *= 4503599627370496;
                e = 52 - e;
                if (e > 0) {
                    toFixedHelpers.multiply(0, z);
                    j = f;
                    while (j >= 7) {
                        toFixedHelpers.multiply(1e7, 0);
                        j -= 7;
                    }
                    toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                    j = e - 1;
                    while (j >= 23) {
                        toFixedHelpers.divide(1 << 23);
                        j -= 23;
                    }
                    toFixedHelpers.divide(1 << j);
                    toFixedHelpers.multiply(1, 1);
                    toFixedHelpers.divide(2);
                    m = toFixedHelpers.numToString();
                } else {
                    toFixedHelpers.multiply(0, z);
                    toFixedHelpers.multiply(1 << -e, 0);
                    m = toFixedHelpers.numToString() + "0.00000000000000000000".slice(2, 2 + f);
                }
            }
            if (f > 0) {
                k = m.length;
                if (k <= f) {
                    m = s + "0.0000000000000000000".slice(0, f - k + 2) + m;
                } else {
                    m = s + m.slice(0, k - f) + "." + m.slice(k - f);
                }
            } else {
                m = s + m;
            }
            return m;
        }
    }, hasToFixedBugs);
    var string_split = StringPrototype.split;
    if ("ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || "tesst".split(/(s)*/)[1] === "t" || "test".split(/(?:)/, -1).length !== 4 || "".split(/.?/).length || ".".split(/()()/).length > 1) {
        (function() {
            var compliantExecNpcg = typeof /()??/.exec("")[1] === "undefined";
            StringPrototype.split = function(separator, limit) {
                var string = this;
                if (typeof separator === "undefined" && limit === 0) {
                    return [];
                }
                if (to_string.call(separator) !== "[object RegExp]") {
                    return string_split.call(this, separator, limit);
                }
                var output = [], flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + (separator.sticky ? "y" : ""), lastLastIndex = 0, separator2, match, lastIndex, lastLength;
                separator = new RegExp(separator.source, flags + "g");
                string += "";
                if (!compliantExecNpcg) {
                    separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
                }
                limit = typeof limit === "undefined" ? -1 >>> 0 : ES.ToUint32(limit);
                match = separator.exec(string);
                while (match) {
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        output.push(string.slice(lastLastIndex, match.index));
                        if (!compliantExecNpcg && match.length > 1) {
                            match[0].replace(separator2, function() {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (typeof arguments[i] === "undefined") {
                                        match[i] = void 0;
                                    }
                                }
                            });
                        }
                        if (match.length > 1 && match.index < string.length) {
                            array_push.apply(output, match.slice(1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= limit) {
                            break;
                        }
                    }
                    if (separator.lastIndex === match.index) {
                        separator.lastIndex++;
                    }
                    match = separator.exec(string);
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separator.test("")) {
                        output.push("");
                    }
                } else {
                    output.push(string.slice(lastLastIndex));
                }
                return output.length > limit ? output.slice(0, limit) : output;
            };
        })();
    } else if ("0".split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (typeof separator === "undefined" && limit === 0) {
                return [];
            }
            return string_split.call(this, separator, limit);
        };
    }
    var str_replace = StringPrototype.replace;
    var replaceReportsGroupsCorrectly = function() {
        var groups = [];
        "x".replace(/x(.)?/g, function(match, group) {
            groups.push(group);
        });
        return groups.length === 1 && typeof groups[0] === "undefined";
    }();
    if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
            var isFn = isFunction(replaceValue);
            var hasCapturingGroups = isRegex(searchValue) && /\)[*?]/.test(searchValue.source);
            if (!isFn || !hasCapturingGroups) {
                return str_replace.call(this, searchValue, replaceValue);
            } else {
                var wrappedReplaceValue = function(match) {
                    var length = arguments.length;
                    var originalLastIndex = searchValue.lastIndex;
                    searchValue.lastIndex = 0;
                    var args = searchValue.exec(match) || [];
                    searchValue.lastIndex = originalLastIndex;
                    args.push(arguments[length - 2], arguments[length - 1]);
                    return replaceValue.apply(this, args);
                };
                return str_replace.call(this, searchValue, wrappedReplaceValue);
            }
        };
    }
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = "".substr && "0b".substr(-1) !== "b";
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);
        }
    }, hasNegativeSubstrBug);
    var ws = "\t\n\v\f\r " + "\u2028" + "\u2029\ufeff";
    var zeroWidth = "";
    var wsRegexChars = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + wsRegexChars + wsRegexChars + "*");
    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + "*$");
    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
    defineProperties(StringPrototype, {
        trim: function trim() {
            if (typeof this === "undefined" || this === null) {
                throw new TypeError("can't convert " + this + " to object");
            }
            return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
        }
    }, hasTrimWhitespaceBug);
    if (parseInt(ws + "08") !== 8 || parseInt(ws + "0x16") !== 22) {
        parseInt = function(origParseInt) {
            var hexRegex = /^0[xX]/;
            return function parseIntES5(str, radix) {
                str = String(str).trim();
                if (!Number(radix)) {
                    radix = hexRegex.test(str) ? 16 : 10;
                }
                return origParseInt(str, radix);
            };
        }(parseInt);
    }
});

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery", "moment" ], factory);
    } else if (typeof exports === "object") {
        module.exports = factory(require("jquery"), require("moment"));
    } else {
        factory(jQuery, moment);
    }
})(function($, moment) {
    var FC = $.fullCalendar = {
        version: "3.0.1",
        internalApiVersion: 6
    };
    var fcViews = FC.views = {};
    $.fn.fullCalendar = function(options) {
        var args = Array.prototype.slice.call(arguments, 1);
        var res = this;
        this.each(function(i, _element) {
            var element = $(_element);
            var calendar = element.data("fullCalendar");
            var singleRes;
            if (typeof options === "string") {
                if (calendar && $.isFunction(calendar[options])) {
                    singleRes = calendar[options].apply(calendar, args);
                    if (!i) {
                        res = singleRes;
                    }
                    if (options === "destroy") {
                        element.removeData("fullCalendar");
                    }
                }
            } else if (!calendar) {
                calendar = new Calendar(element, options);
                element.data("fullCalendar", calendar);
                calendar.render();
            }
        });
        return res;
    };
    var complexOptions = [ "header", "buttonText", "buttonIcons", "themeButtonIcons" ];
    function mergeOptions(optionObjs) {
        return mergeProps(optionObjs, complexOptions);
    }
    FC.intersectRanges = intersectRanges;
    FC.applyAll = applyAll;
    FC.debounce = debounce;
    FC.isInt = isInt;
    FC.htmlEscape = htmlEscape;
    FC.cssToStr = cssToStr;
    FC.proxy = proxy;
    FC.capitaliseFirstLetter = capitaliseFirstLetter;
    function compensateScroll(rowEls, scrollbarWidths) {
        if (scrollbarWidths.left) {
            rowEls.css({
                "border-left-width": 1,
                "margin-left": scrollbarWidths.left - 1
            });
        }
        if (scrollbarWidths.right) {
            rowEls.css({
                "border-right-width": 1,
                "margin-right": scrollbarWidths.right - 1
            });
        }
    }
    function uncompensateScroll(rowEls) {
        rowEls.css({
            "margin-left": "",
            "margin-right": "",
            "border-left-width": "",
            "border-right-width": ""
        });
    }
    function disableCursor() {
        $("body").addClass("fc-not-allowed");
    }
    function enableCursor() {
        $("body").removeClass("fc-not-allowed");
    }
    function distributeHeight(els, availableHeight, shouldRedistribute) {
        var minOffset1 = Math.floor(availableHeight / els.length);
        var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1));
        var flexEls = [];
        var flexOffsets = [];
        var flexHeights = [];
        var usedHeight = 0;
        undistributeHeight(els);
        els.each(function(i, el) {
            var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
            var naturalOffset = $(el).outerHeight(true);
            if (naturalOffset < minOffset) {
                flexEls.push(el);
                flexOffsets.push(naturalOffset);
                flexHeights.push($(el).height());
            } else {
                usedHeight += naturalOffset;
            }
        });
        if (shouldRedistribute) {
            availableHeight -= usedHeight;
            minOffset1 = Math.floor(availableHeight / flexEls.length);
            minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1));
        }
        $(flexEls).each(function(i, el) {
            var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
            var naturalOffset = flexOffsets[i];
            var naturalHeight = flexHeights[i];
            var newHeight = minOffset - (naturalOffset - naturalHeight);
            if (naturalOffset < minOffset) {
                $(el).height(newHeight);
            }
        });
    }
    function undistributeHeight(els) {
        els.height("");
    }
    function matchCellWidths(els) {
        var maxInnerWidth = 0;
        els.find("> *").each(function(i, innerEl) {
            var innerWidth = $(innerEl).outerWidth();
            if (innerWidth > maxInnerWidth) {
                maxInnerWidth = innerWidth;
            }
        });
        maxInnerWidth++;
        els.width(maxInnerWidth);
        return maxInnerWidth;
    }
    function subtractInnerElHeight(outerEl, innerEl) {
        var both = outerEl.add(innerEl);
        var diff;
        both.css({
            position: "relative",
            left: -1
        });
        diff = outerEl.outerHeight() - innerEl.outerHeight();
        both.css({
            position: "",
            left: ""
        });
        return diff;
    }
    FC.getOuterRect = getOuterRect;
    FC.getClientRect = getClientRect;
    FC.getContentRect = getContentRect;
    FC.getScrollbarWidths = getScrollbarWidths;
    function getScrollParent(el) {
        var position = el.css("position"), scrollParent = el.parents().filter(function() {
            var parent = $(this);
            return /(auto|scroll)/.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
        }).eq(0);
        return position === "fixed" || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
    }
    function getOuterRect(el, origin) {
        var offset = el.offset();
        var left = offset.left - (origin ? origin.left : 0);
        var top = offset.top - (origin ? origin.top : 0);
        return {
            left: left,
            right: left + el.outerWidth(),
            top: top,
            bottom: top + el.outerHeight()
        };
    }
    function getClientRect(el, origin) {
        var offset = el.offset();
        var scrollbarWidths = getScrollbarWidths(el);
        var left = offset.left + getCssFloat(el, "border-left-width") + scrollbarWidths.left - (origin ? origin.left : 0);
        var top = offset.top + getCssFloat(el, "border-top-width") + scrollbarWidths.top - (origin ? origin.top : 0);
        return {
            left: left,
            right: left + el[0].clientWidth,
            top: top,
            bottom: top + el[0].clientHeight
        };
    }
    function getContentRect(el, origin) {
        var offset = el.offset();
        var left = offset.left + getCssFloat(el, "border-left-width") + getCssFloat(el, "padding-left") - (origin ? origin.left : 0);
        var top = offset.top + getCssFloat(el, "border-top-width") + getCssFloat(el, "padding-top") - (origin ? origin.top : 0);
        return {
            left: left,
            right: left + el.width(),
            top: top,
            bottom: top + el.height()
        };
    }
    function getScrollbarWidths(el) {
        var leftRightWidth = el.innerWidth() - el[0].clientWidth;
        var widths = {
            left: 0,
            right: 0,
            top: 0,
            bottom: el.innerHeight() - el[0].clientHeight
        };
        if (getIsLeftRtlScrollbars() && el.css("direction") == "rtl") {
            widths.left = leftRightWidth;
        } else {
            widths.right = leftRightWidth;
        }
        return widths;
    }
    var _isLeftRtlScrollbars = null;
    function getIsLeftRtlScrollbars() {
        if (_isLeftRtlScrollbars === null) {
            _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
        }
        return _isLeftRtlScrollbars;
    }
    function computeIsLeftRtlScrollbars() {
        var el = $("<div><div/></div>").css({
            position: "absolute",
            top: -1e3,
            left: 0,
            border: 0,
            padding: 0,
            overflow: "scroll",
            direction: "rtl"
        }).appendTo("body");
        var innerEl = el.children();
        var res = innerEl.offset().left > el.offset().left;
        el.remove();
        return res;
    }
    function getCssFloat(el, prop) {
        return parseFloat(el.css(prop)) || 0;
    }
    FC.preventDefault = preventDefault;
    function isPrimaryMouseButton(ev) {
        return ev.which == 1 && !ev.ctrlKey;
    }
    function getEvX(ev) {
        if (ev.pageX !== undefined) {
            return ev.pageX;
        }
        var touches = ev.originalEvent.touches;
        if (touches) {
            return touches[0].pageX;
        }
    }
    function getEvY(ev) {
        if (ev.pageY !== undefined) {
            return ev.pageY;
        }
        var touches = ev.originalEvent.touches;
        if (touches) {
            return touches[0].pageY;
        }
    }
    function getEvIsTouch(ev) {
        return /^touch/.test(ev.type);
    }
    function preventSelection(el) {
        el.addClass("fc-unselectable").on("selectstart", preventDefault);
    }
    function preventDefault(ev) {
        ev.preventDefault();
    }
    function bindAnyScroll(handler) {
        if (window.addEventListener) {
            window.addEventListener("scroll", handler, true);
            return true;
        }
        return false;
    }
    function unbindAnyScroll(handler) {
        if (window.removeEventListener) {
            window.removeEventListener("scroll", handler, true);
            return true;
        }
        return false;
    }
    FC.intersectRects = intersectRects;
    function intersectRects(rect1, rect2) {
        var res = {
            left: Math.max(rect1.left, rect2.left),
            right: Math.min(rect1.right, rect2.right),
            top: Math.max(rect1.top, rect2.top),
            bottom: Math.min(rect1.bottom, rect2.bottom)
        };
        if (res.left < res.right && res.top < res.bottom) {
            return res;
        }
        return false;
    }
    function constrainPoint(point, rect) {
        return {
            left: Math.min(Math.max(point.left, rect.left), rect.right),
            top: Math.min(Math.max(point.top, rect.top), rect.bottom)
        };
    }
    function getRectCenter(rect) {
        return {
            left: (rect.left + rect.right) / 2,
            top: (rect.top + rect.bottom) / 2
        };
    }
    function diffPoints(point1, point2) {
        return {
            left: point1.left - point2.left,
            top: point1.top - point2.top
        };
    }
    FC.parseFieldSpecs = parseFieldSpecs;
    FC.compareByFieldSpecs = compareByFieldSpecs;
    FC.compareByFieldSpec = compareByFieldSpec;
    FC.flexibleCompare = flexibleCompare;
    function parseFieldSpecs(input) {
        var specs = [];
        var tokens = [];
        var i, token;
        if (typeof input === "string") {
            tokens = input.split(/\s*,\s*/);
        } else if (typeof input === "function") {
            tokens = [ input ];
        } else if ($.isArray(input)) {
            tokens = input;
        }
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            if (typeof token === "string") {
                specs.push(token.charAt(0) == "-" ? {
                    field: token.substring(1),
                    order: -1
                } : {
                    field: token,
                    order: 1
                });
            } else if (typeof token === "function") {
                specs.push({
                    func: token
                });
            }
        }
        return specs;
    }
    function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
        var i;
        var cmp;
        for (i = 0; i < fieldSpecs.length; i++) {
            cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
            if (cmp) {
                return cmp;
            }
        }
        return 0;
    }
    function compareByFieldSpec(obj1, obj2, fieldSpec) {
        if (fieldSpec.func) {
            return fieldSpec.func(obj1, obj2);
        }
        return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) * (fieldSpec.order || 1);
    }
    function flexibleCompare(a, b) {
        if (!a && !b) {
            return 0;
        }
        if (b == null) {
            return -1;
        }
        if (a == null) {
            return 1;
        }
        if ($.type(a) === "string" || $.type(b) === "string") {
            return String(a).localeCompare(String(b));
        }
        return a - b;
    }
    function intersectRanges(subjectRange, constraintRange) {
        var subjectStart = subjectRange.start;
        var subjectEnd = subjectRange.end;
        var constraintStart = constraintRange.start;
        var constraintEnd = constraintRange.end;
        var segStart, segEnd;
        var isStart, isEnd;
        if (subjectEnd > constraintStart && subjectStart < constraintEnd) {
            if (subjectStart >= constraintStart) {
                segStart = subjectStart.clone();
                isStart = true;
            } else {
                segStart = constraintStart.clone();
                isStart = false;
            }
            if (subjectEnd <= constraintEnd) {
                segEnd = subjectEnd.clone();
                isEnd = true;
            } else {
                segEnd = constraintEnd.clone();
                isEnd = false;
            }
            return {
                start: segStart,
                end: segEnd,
                isStart: isStart,
                isEnd: isEnd
            };
        }
    }
    FC.computeIntervalUnit = computeIntervalUnit;
    FC.divideRangeByDuration = divideRangeByDuration;
    FC.divideDurationByDuration = divideDurationByDuration;
    FC.multiplyDuration = multiplyDuration;
    FC.durationHasTime = durationHasTime;
    var dayIDs = [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ];
    var intervalUnits = [ "year", "month", "week", "day", "hour", "minute", "second", "millisecond" ];
    function diffDayTime(a, b) {
        return moment.duration({
            days: a.clone().stripTime().diff(b.clone().stripTime(), "days"),
            ms: a.time() - b.time()
        });
    }
    function diffDay(a, b) {
        return moment.duration({
            days: a.clone().stripTime().diff(b.clone().stripTime(), "days")
        });
    }
    function diffByUnit(a, b, unit) {
        return moment.duration(Math.round(a.diff(b, unit, true)), unit);
    }
    function computeIntervalUnit(start, end) {
        var i, unit;
        var val;
        for (i = 0; i < intervalUnits.length; i++) {
            unit = intervalUnits[i];
            val = computeRangeAs(unit, start, end);
            if (val >= 1 && isInt(val)) {
                break;
            }
        }
        return unit;
    }
    function computeRangeAs(unit, start, end) {
        if (end != null) {
            return end.diff(start, unit, true);
        } else if (moment.isDuration(start)) {
            return start.as(unit);
        } else {
            return start.end.diff(start.start, unit, true);
        }
    }
    function divideRangeByDuration(start, end, dur) {
        var months;
        if (durationHasTime(dur)) {
            return (end - start) / dur;
        }
        months = dur.asMonths();
        if (Math.abs(months) >= 1 && isInt(months)) {
            return end.diff(start, "months", true) / months;
        }
        return end.diff(start, "days", true) / dur.asDays();
    }
    function divideDurationByDuration(dur1, dur2) {
        var months1, months2;
        if (durationHasTime(dur1) || durationHasTime(dur2)) {
            return dur1 / dur2;
        }
        months1 = dur1.asMonths();
        months2 = dur2.asMonths();
        if (Math.abs(months1) >= 1 && isInt(months1) && Math.abs(months2) >= 1 && isInt(months2)) {
            return months1 / months2;
        }
        return dur1.asDays() / dur2.asDays();
    }
    function multiplyDuration(dur, n) {
        var months;
        if (durationHasTime(dur)) {
            return moment.duration(dur * n);
        }
        months = dur.asMonths();
        if (Math.abs(months) >= 1 && isInt(months)) {
            return moment.duration({
                months: months * n
            });
        }
        return moment.duration({
            days: dur.asDays() * n
        });
    }
    function durationHasTime(dur) {
        return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
    }
    function isNativeDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date;
    }
    function isTimeString(str) {
        return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
    }
    FC.log = function() {
        var console = window.console;
        if (console && console.log) {
            return console.log.apply(console, arguments);
        }
    };
    FC.warn = function() {
        var console = window.console;
        if (console && console.warn) {
            return console.warn.apply(console, arguments);
        } else {
            return FC.log.apply(FC, arguments);
        }
    };
    var hasOwnPropMethod = {}.hasOwnProperty;
    function mergeProps(propObjs, complexProps) {
        var dest = {};
        var i, name;
        var complexObjs;
        var j, val;
        var props;
        if (complexProps) {
            for (i = 0; i < complexProps.length; i++) {
                name = complexProps[i];
                complexObjs = [];
                for (j = propObjs.length - 1; j >= 0; j--) {
                    val = propObjs[j][name];
                    if (typeof val === "object") {
                        complexObjs.unshift(val);
                    } else if (val !== undefined) {
                        dest[name] = val;
                        break;
                    }
                }
                if (complexObjs.length) {
                    dest[name] = mergeProps(complexObjs);
                }
            }
        }
        for (i = propObjs.length - 1; i >= 0; i--) {
            props = propObjs[i];
            for (name in props) {
                if (!(name in dest)) {
                    dest[name] = props[name];
                }
            }
        }
        return dest;
    }
    function createObject(proto) {
        var f = function() {};
        f.prototype = proto;
        return new f();
    }
    function copyOwnProps(src, dest) {
        for (var name in src) {
            if (hasOwnProp(src, name)) {
                dest[name] = src[name];
            }
        }
    }
    function hasOwnProp(obj, name) {
        return hasOwnPropMethod.call(obj, name);
    }
    function isAtomic(val) {
        return /undefined|null|boolean|number|string/.test($.type(val));
    }
    function applyAll(functions, thisObj, args) {
        if ($.isFunction(functions)) {
            functions = [ functions ];
        }
        if (functions) {
            var i;
            var ret;
            for (i = 0; i < functions.length; i++) {
                ret = functions[i].apply(thisObj, args) || ret;
            }
            return ret;
        }
    }
    function firstDefined() {
        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] !== undefined) {
                return arguments[i];
            }
        }
    }
    function htmlEscape(s) {
        return (s + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#039;").replace(/"/g, "&quot;").replace(/\n/g, "<br />");
    }
    function stripHtmlEntities(text) {
        return text.replace(/&.*?;/g, "");
    }
    function cssToStr(cssProps) {
        var statements = [];
        $.each(cssProps, function(name, val) {
            if (val != null) {
                statements.push(name + ":" + val);
            }
        });
        return statements.join(";");
    }
    function attrsToStr(attrs) {
        var parts = [];
        $.each(attrs, function(name, val) {
            if (val != null) {
                parts.push(name + '="' + htmlEscape(val) + '"');
            }
        });
        return parts.join(" ");
    }
    function capitaliseFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function compareNumbers(a, b) {
        return a - b;
    }
    function isInt(n) {
        return n % 1 === 0;
    }
    function proxy(obj, methodName) {
        var method = obj[methodName];
        return function() {
            return method.apply(obj, arguments);
        };
    }
    function debounce(func, wait, immediate) {
        var timeout, args, context, timestamp, result;
        var later = function() {
            var last = +new Date() - timestamp;
            if (last < wait) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    context = args = null;
                }
            }
        };
        return function() {
            context = this;
            args = arguments;
            timestamp = +new Date();
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }
            return result;
        };
    }
    function syncThen(promise, thenFunc) {
        if (!promise || !promise.then || promise.state() === "resolved") {
            return $.when(thenFunc());
        } else if (thenFunc) {
            return promise.then(thenFunc);
        }
    }
    var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
    var ambigTimeOrZoneRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
    var newMomentProto = moment.fn;
    var oldMomentProto = $.extend({}, newMomentProto);
    var momentProperties = moment.momentProperties;
    momentProperties.push("_fullCalendar");
    momentProperties.push("_ambigTime");
    momentProperties.push("_ambigZone");
    FC.moment = function() {
        return makeMoment(arguments);
    };
    FC.moment.utc = function() {
        var mom = makeMoment(arguments, true);
        if (mom.hasTime()) {
            mom.utc();
        }
        return mom;
    };
    FC.moment.parseZone = function() {
        return makeMoment(arguments, true, true);
    };
    function makeMoment(args, parseAsUTC, parseZone) {
        var input = args[0];
        var isSingleString = args.length == 1 && typeof input === "string";
        var isAmbigTime;
        var isAmbigZone;
        var ambigMatch;
        var mom;
        if (moment.isMoment(input) || isNativeDate(input) || input === undefined) {
            mom = moment.apply(null, args);
        } else {
            isAmbigTime = false;
            isAmbigZone = false;
            if (isSingleString) {
                if (ambigDateOfMonthRegex.test(input)) {
                    input += "-01";
                    args = [ input ];
                    isAmbigTime = true;
                    isAmbigZone = true;
                } else if (ambigMatch = ambigTimeOrZoneRegex.exec(input)) {
                    isAmbigTime = !ambigMatch[5];
                    isAmbigZone = true;
                }
            } else if ($.isArray(input)) {
                isAmbigZone = true;
            }
            if (parseAsUTC || isAmbigTime) {
                mom = moment.utc.apply(moment, args);
            } else {
                mom = moment.apply(null, args);
            }
            if (isAmbigTime) {
                mom._ambigTime = true;
                mom._ambigZone = true;
            } else if (parseZone) {
                if (isAmbigZone) {
                    mom._ambigZone = true;
                } else if (isSingleString) {
                    mom.utcOffset(input);
                }
            }
        }
        mom._fullCalendar = true;
        return mom;
    }
    newMomentProto.week = newMomentProto.weeks = function(input) {
        var weekCalc = this._locale._fullCalendar_weekCalc;
        if (input == null && typeof weekCalc === "function") {
            return weekCalc(this);
        } else if (weekCalc === "ISO") {
            return oldMomentProto.isoWeek.apply(this, arguments);
        }
        return oldMomentProto.week.apply(this, arguments);
    };
    newMomentProto.time = function(time) {
        if (!this._fullCalendar) {
            return oldMomentProto.time.apply(this, arguments);
        }
        if (time == null) {
            return moment.duration({
                hours: this.hours(),
                minutes: this.minutes(),
                seconds: this.seconds(),
                milliseconds: this.milliseconds()
            });
        } else {
            this._ambigTime = false;
            if (!moment.isDuration(time) && !moment.isMoment(time)) {
                time = moment.duration(time);
            }
            var dayHours = 0;
            if (moment.isDuration(time)) {
                dayHours = Math.floor(time.asDays()) * 24;
            }
            return this.hours(dayHours + time.hours()).minutes(time.minutes()).seconds(time.seconds()).milliseconds(time.milliseconds());
        }
    };
    newMomentProto.stripTime = function() {
        if (!this._ambigTime) {
            this.utc(true);
            this.set({
                hours: 0,
                minutes: 0,
                seconds: 0,
                ms: 0
            });
            this._ambigTime = true;
            this._ambigZone = true;
        }
        return this;
    };
    newMomentProto.hasTime = function() {
        return !this._ambigTime;
    };
    newMomentProto.stripZone = function() {
        var wasAmbigTime;
        if (!this._ambigZone) {
            wasAmbigTime = this._ambigTime;
            this.utc(true);
            this._ambigTime = wasAmbigTime || false;
            this._ambigZone = true;
        }
        return this;
    };
    newMomentProto.hasZone = function() {
        return !this._ambigZone;
    };
    newMomentProto.local = function(keepLocalTime) {
        oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);
        this._ambigTime = false;
        this._ambigZone = false;
        return this;
    };
    newMomentProto.utc = function(keepLocalTime) {
        oldMomentProto.utc.call(this, keepLocalTime);
        this._ambigTime = false;
        this._ambigZone = false;
        return this;
    };
    newMomentProto.utcOffset = function(tzo) {
        if (tzo != null) {
            this._ambigTime = false;
            this._ambigZone = false;
        }
        return oldMomentProto.utcOffset.apply(this, arguments);
    };
    newMomentProto.format = function() {
        if (this._fullCalendar && arguments[0]) {
            return formatDate(this, arguments[0]);
        }
        if (this._ambigTime) {
            return oldMomentFormat(this, "YYYY-MM-DD");
        }
        if (this._ambigZone) {
            return oldMomentFormat(this, "YYYY-MM-DD[T]HH:mm:ss");
        }
        return oldMomentProto.format.apply(this, arguments);
    };
    newMomentProto.toISOString = function() {
        if (this._ambigTime) {
            return oldMomentFormat(this, "YYYY-MM-DD");
        }
        if (this._ambigZone) {
            return oldMomentFormat(this, "YYYY-MM-DD[T]HH:mm:ss");
        }
        return oldMomentProto.toISOString.apply(this, arguments);
    };
    function oldMomentFormat(mom, formatStr) {
        return oldMomentProto.format.call(mom, formatStr);
    }
    function formatDate(date, formatStr) {
        return formatDateWithChunks(date, getFormatStringChunks(formatStr));
    }
    function formatDateWithChunks(date, chunks) {
        var s = "";
        var i;
        for (i = 0; i < chunks.length; i++) {
            s += formatDateWithChunk(date, chunks[i]);
        }
        return s;
    }
    var tokenOverrides = {
        t: function(date) {
            return oldMomentFormat(date, "a").charAt(0);
        },
        T: function(date) {
            return oldMomentFormat(date, "A").charAt(0);
        }
    };
    function formatDateWithChunk(date, chunk) {
        var token;
        var maybeStr;
        if (typeof chunk === "string") {
            return chunk;
        } else if (token = chunk.token) {
            if (tokenOverrides[token]) {
                return tokenOverrides[token](date);
            }
            return oldMomentFormat(date, token);
        } else if (chunk.maybe) {
            maybeStr = formatDateWithChunks(date, chunk.maybe);
            if (maybeStr.match(/[1-9]/)) {
                return maybeStr;
            }
        }
        return "";
    }
    function formatRange(date1, date2, formatStr, separator, isRTL) {
        var localeData;
        date1 = FC.moment.parseZone(date1);
        date2 = FC.moment.parseZone(date2);
        localeData = date1.localeData();
        formatStr = localeData.longDateFormat(formatStr) || formatStr;
        separator = separator || " - ";
        return formatRangeWithChunks(date1, date2, getFormatStringChunks(formatStr), separator, isRTL);
    }
    FC.formatRange = formatRange;
    function formatRangeWithChunks(date1, date2, chunks, separator, isRTL) {
        var unzonedDate1 = date1.clone().stripZone();
        var unzonedDate2 = date2.clone().stripZone();
        var chunkStr;
        var leftI;
        var leftStr = "";
        var rightI;
        var rightStr = "";
        var middleI;
        var middleStr1 = "";
        var middleStr2 = "";
        var middleStr = "";
        for (leftI = 0; leftI < chunks.length; leftI++) {
            chunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[leftI]);
            if (chunkStr === false) {
                break;
            }
            leftStr += chunkStr;
        }
        for (rightI = chunks.length - 1; rightI > leftI; rightI--) {
            chunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[rightI]);
            if (chunkStr === false) {
                break;
            }
            rightStr = chunkStr + rightStr;
        }
        for (middleI = leftI; middleI <= rightI; middleI++) {
            middleStr1 += formatDateWithChunk(date1, chunks[middleI]);
            middleStr2 += formatDateWithChunk(date2, chunks[middleI]);
        }
        if (middleStr1 || middleStr2) {
            if (isRTL) {
                middleStr = middleStr2 + separator + middleStr1;
            } else {
                middleStr = middleStr1 + separator + middleStr2;
            }
        }
        return leftStr + middleStr + rightStr;
    }
    var similarUnitMap = {
        Y: "year",
        M: "month",
        D: "day",
        d: "day",
        A: "second",
        a: "second",
        T: "second",
        t: "second",
        H: "second",
        h: "second",
        m: "second",
        s: "second"
    };
    function formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunk) {
        var token;
        var unit;
        if (typeof chunk === "string") {
            return chunk;
        } else if (token = chunk.token) {
            unit = similarUnitMap[token.charAt(0)];
            if (unit && unzonedDate1.isSame(unzonedDate2, unit)) {
                return oldMomentFormat(date1, token);
            }
        }
        return false;
    }
    var formatStringChunkCache = {};
    function getFormatStringChunks(formatStr) {
        if (formatStr in formatStringChunkCache) {
            return formatStringChunkCache[formatStr];
        }
        return formatStringChunkCache[formatStr] = chunkFormatString(formatStr);
    }
    function chunkFormatString(formatStr) {
        var chunks = [];
        var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;
        var match;
        while (match = chunker.exec(formatStr)) {
            if (match[1]) {
                chunks.push(match[1]);
            } else if (match[2]) {
                chunks.push({
                    maybe: chunkFormatString(match[2])
                });
            } else if (match[3]) {
                chunks.push({
                    token: match[3]
                });
            } else if (match[5]) {
                chunks.push(match[5]);
            }
        }
        return chunks;
    }
    var tokenGranularities = {
        Y: {
            value: 1,
            unit: "year"
        },
        M: {
            value: 2,
            unit: "month"
        },
        W: {
            value: 3,
            unit: "week"
        },
        w: {
            value: 3,
            unit: "week"
        },
        D: {
            value: 4,
            unit: "day"
        },
        d: {
            value: 4,
            unit: "day"
        }
    };
    FC.queryMostGranularFormatUnit = function(formatStr) {
        var chunks = getFormatStringChunks(formatStr);
        var i, chunk;
        var candidate;
        var best;
        for (i = 0; i < chunks.length; i++) {
            chunk = chunks[i];
            if (chunk.token) {
                candidate = tokenGranularities[chunk.token.charAt(0)];
                if (candidate) {
                    if (!best || candidate.value > best.value) {
                        best = candidate;
                    }
                }
            }
        }
        if (best) {
            return best.unit;
        }
        return null;
    };
    FC.Class = Class;
    function Class() {}
    Class.extend = function() {
        var len = arguments.length;
        var i;
        var members;
        for (i = 0; i < len; i++) {
            members = arguments[i];
            if (i < len - 1) {
                mixIntoClass(this, members);
            }
        }
        return extendClass(this, members || {});
    };
    Class.mixin = function(members) {
        mixIntoClass(this, members);
    };
    function extendClass(superClass, members) {
        var subClass;
        if (hasOwnProp(members, "constructor")) {
            subClass = members.constructor;
        }
        if (typeof subClass !== "function") {
            subClass = members.constructor = function() {
                superClass.apply(this, arguments);
            };
        }
        subClass.prototype = createObject(superClass.prototype);
        copyOwnProps(members, subClass.prototype);
        copyOwnProps(superClass, subClass);
        return subClass;
    }
    function mixIntoClass(theClass, members) {
        copyOwnProps(members, theClass.prototype);
    }
    var EmitterMixin = FC.EmitterMixin = {
        on: function(types, handler) {
            var intercept = function(ev, extra) {
                return handler.apply(extra.context || this, extra.args || []);
            };
            if (!handler.guid) {
                handler.guid = $.guid++;
            }
            intercept.guid = handler.guid;
            $(this).on(types, intercept);
            return this;
        },
        off: function(types, handler) {
            $(this).off(types, handler);
            return this;
        },
        trigger: function(types) {
            var args = Array.prototype.slice.call(arguments, 1);
            $(this).triggerHandler(types, {
                args: args
            });
            return this;
        },
        triggerWith: function(types, context, args) {
            $(this).triggerHandler(types, {
                context: context,
                args: args
            });
            return this;
        }
    };
    var ListenerMixin = FC.ListenerMixin = function() {
        var guid = 0;
        var ListenerMixin = {
            listenerId: null,
            listenTo: function(other, arg, callback) {
                if (typeof arg === "object") {
                    for (var eventName in arg) {
                        if (arg.hasOwnProperty(eventName)) {
                            this.listenTo(other, eventName, arg[eventName]);
                        }
                    }
                } else if (typeof arg === "string") {
                    other.on(arg + "." + this.getListenerNamespace(), $.proxy(callback, this));
                }
            },
            stopListeningTo: function(other, eventName) {
                other.off((eventName || "") + "." + this.getListenerNamespace());
            },
            getListenerNamespace: function() {
                if (this.listenerId == null) {
                    this.listenerId = guid++;
                }
                return "_listener" + this.listenerId;
            }
        };
        return ListenerMixin;
    }();
    var MouseIgnorerMixin = {
        isIgnoringMouse: false,
        delayUnignoreMouse: null,
        initMouseIgnoring: function(delay) {
            this.delayUnignoreMouse = debounce(proxy(this, "unignoreMouse"), delay || 1e3);
        },
        tempIgnoreMouse: function() {
            this.isIgnoringMouse = true;
            this.delayUnignoreMouse();
        },
        unignoreMouse: function() {
            this.isIgnoringMouse = false;
        }
    };
    var Popover = Class.extend(ListenerMixin, {
        isHidden: true,
        options: null,
        el: null,
        margin: 10,
        constructor: function(options) {
            this.options = options || {};
        },
        show: function() {
            if (this.isHidden) {
                if (!this.el) {
                    this.render();
                }
                this.el.show();
                this.position();
                this.isHidden = false;
                this.trigger("show");
            }
        },
        hide: function() {
            if (!this.isHidden) {
                this.el.hide();
                this.isHidden = true;
                this.trigger("hide");
            }
        },
        render: function() {
            var _this = this;
            var options = this.options;
            this.el = $('<div class="fc-popover"/>').addClass(options.className || "").css({
                top: 0,
                left: 0
            }).append(options.content).appendTo(options.parentEl);
            this.el.on("click", ".fc-close", function() {
                _this.hide();
            });
            if (options.autoHide) {
                this.listenTo($(document), "mousedown", this.documentMousedown);
            }
        },
        documentMousedown: function(ev) {
            if (this.el && !$(ev.target).closest(this.el).length) {
                this.hide();
            }
        },
        removeElement: function() {
            this.hide();
            if (this.el) {
                this.el.remove();
                this.el = null;
            }
            this.stopListeningTo($(document), "mousedown");
        },
        position: function() {
            var options = this.options;
            var origin = this.el.offsetParent().offset();
            var width = this.el.outerWidth();
            var height = this.el.outerHeight();
            var windowEl = $(window);
            var viewportEl = getScrollParent(this.el);
            var viewportTop;
            var viewportLeft;
            var viewportOffset;
            var top;
            var left;
            top = options.top || 0;
            if (options.left !== undefined) {
                left = options.left;
            } else if (options.right !== undefined) {
                left = options.right - width;
            } else {
                left = 0;
            }
            if (viewportEl.is(window) || viewportEl.is(document)) {
                viewportEl = windowEl;
                viewportTop = 0;
                viewportLeft = 0;
            } else {
                viewportOffset = viewportEl.offset();
                viewportTop = viewportOffset.top;
                viewportLeft = viewportOffset.left;
            }
            viewportTop += windowEl.scrollTop();
            viewportLeft += windowEl.scrollLeft();
            if (options.viewportConstrain !== false) {
                top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
                top = Math.max(top, viewportTop + this.margin);
                left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
                left = Math.max(left, viewportLeft + this.margin);
            }
            this.el.css({
                top: top - origin.top,
                left: left - origin.left
            });
        },
        trigger: function(name) {
            if (this.options[name]) {
                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
        }
    });
    var CoordCache = FC.CoordCache = Class.extend({
        els: null,
        forcedOffsetParentEl: null,
        origin: null,
        boundingRect: null,
        isHorizontal: false,
        isVertical: false,
        lefts: null,
        rights: null,
        tops: null,
        bottoms: null,
        constructor: function(options) {
            this.els = $(options.els);
            this.isHorizontal = options.isHorizontal;
            this.isVertical = options.isVertical;
            this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
        },
        build: function() {
            var offsetParentEl = this.forcedOffsetParentEl || this.els.eq(0).offsetParent();
            this.origin = offsetParentEl.offset();
            this.boundingRect = this.queryBoundingRect();
            if (this.isHorizontal) {
                this.buildElHorizontals();
            }
            if (this.isVertical) {
                this.buildElVerticals();
            }
        },
        clear: function() {
            this.origin = null;
            this.boundingRect = null;
            this.lefts = null;
            this.rights = null;
            this.tops = null;
            this.bottoms = null;
        },
        ensureBuilt: function() {
            if (!this.origin) {
                this.build();
            }
        },
        buildElHorizontals: function() {
            var lefts = [];
            var rights = [];
            this.els.each(function(i, node) {
                var el = $(node);
                var left = el.offset().left;
                var width = el.outerWidth();
                lefts.push(left);
                rights.push(left + width);
            });
            this.lefts = lefts;
            this.rights = rights;
        },
        buildElVerticals: function() {
            var tops = [];
            var bottoms = [];
            this.els.each(function(i, node) {
                var el = $(node);
                var top = el.offset().top;
                var height = el.outerHeight();
                tops.push(top);
                bottoms.push(top + height);
            });
            this.tops = tops;
            this.bottoms = bottoms;
        },
        getHorizontalIndex: function(leftOffset) {
            this.ensureBuilt();
            var lefts = this.lefts;
            var rights = this.rights;
            var len = lefts.length;
            var i;
            for (i = 0; i < len; i++) {
                if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
                    return i;
                }
            }
        },
        getVerticalIndex: function(topOffset) {
            this.ensureBuilt();
            var tops = this.tops;
            var bottoms = this.bottoms;
            var len = tops.length;
            var i;
            for (i = 0; i < len; i++) {
                if (topOffset >= tops[i] && topOffset < bottoms[i]) {
                    return i;
                }
            }
        },
        getLeftOffset: function(leftIndex) {
            this.ensureBuilt();
            return this.lefts[leftIndex];
        },
        getLeftPosition: function(leftIndex) {
            this.ensureBuilt();
            return this.lefts[leftIndex] - this.origin.left;
        },
        getRightOffset: function(leftIndex) {
            this.ensureBuilt();
            return this.rights[leftIndex];
        },
        getRightPosition: function(leftIndex) {
            this.ensureBuilt();
            return this.rights[leftIndex] - this.origin.left;
        },
        getWidth: function(leftIndex) {
            this.ensureBuilt();
            return this.rights[leftIndex] - this.lefts[leftIndex];
        },
        getTopOffset: function(topIndex) {
            this.ensureBuilt();
            return this.tops[topIndex];
        },
        getTopPosition: function(topIndex) {
            this.ensureBuilt();
            return this.tops[topIndex] - this.origin.top;
        },
        getBottomOffset: function(topIndex) {
            this.ensureBuilt();
            return this.bottoms[topIndex];
        },
        getBottomPosition: function(topIndex) {
            this.ensureBuilt();
            return this.bottoms[topIndex] - this.origin.top;
        },
        getHeight: function(topIndex) {
            this.ensureBuilt();
            return this.bottoms[topIndex] - this.tops[topIndex];
        },
        queryBoundingRect: function() {
            var scrollParentEl = getScrollParent(this.els.eq(0));
            if (!scrollParentEl.is(document)) {
                return getClientRect(scrollParentEl);
            }
        },
        isPointInBounds: function(leftOffset, topOffset) {
            return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
        },
        isLeftInBounds: function(leftOffset) {
            return !this.boundingRect || leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right;
        },
        isTopInBounds: function(topOffset) {
            return !this.boundingRect || topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom;
        }
    });
    var DragListener = FC.DragListener = Class.extend(ListenerMixin, MouseIgnorerMixin, {
        options: null,
        subjectEl: null,
        originX: null,
        originY: null,
        scrollEl: null,
        isInteracting: false,
        isDistanceSurpassed: false,
        isDelayEnded: false,
        isDragging: false,
        isTouch: false,
        delay: null,
        delayTimeoutId: null,
        minDistance: null,
        handleTouchScrollProxy: null,
        constructor: function(options) {
            this.options = options || {};
            this.handleTouchScrollProxy = proxy(this, "handleTouchScroll");
            this.initMouseIgnoring(500);
        },
        startInteraction: function(ev, extraOptions) {
            var isTouch = getEvIsTouch(ev);
            if (ev.type === "mousedown") {
                if (this.isIgnoringMouse) {
                    return;
                } else if (!isPrimaryMouseButton(ev)) {
                    return;
                } else {
                    ev.preventDefault();
                }
            }
            if (!this.isInteracting) {
                extraOptions = extraOptions || {};
                this.delay = firstDefined(extraOptions.delay, this.options.delay, 0);
                this.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);
                this.subjectEl = this.options.subjectEl;
                this.isInteracting = true;
                this.isTouch = isTouch;
                this.isDelayEnded = false;
                this.isDistanceSurpassed = false;
                this.originX = getEvX(ev);
                this.originY = getEvY(ev);
                this.scrollEl = getScrollParent($(ev.target));
                this.bindHandlers();
                this.initAutoScroll();
                this.handleInteractionStart(ev);
                this.startDelay(ev);
                if (!this.minDistance) {
                    this.handleDistanceSurpassed(ev);
                }
            }
        },
        handleInteractionStart: function(ev) {
            this.trigger("interactionStart", ev);
        },
        endInteraction: function(ev, isCancelled) {
            if (this.isInteracting) {
                this.endDrag(ev);
                if (this.delayTimeoutId) {
                    clearTimeout(this.delayTimeoutId);
                    this.delayTimeoutId = null;
                }
                this.destroyAutoScroll();
                this.unbindHandlers();
                this.isInteracting = false;
                this.handleInteractionEnd(ev, isCancelled);
                if (this.isTouch) {
                    this.tempIgnoreMouse();
                }
            }
        },
        handleInteractionEnd: function(ev, isCancelled) {
            this.trigger("interactionEnd", ev, isCancelled || false);
        },
        bindHandlers: function() {
            var _this = this;
            var touchStartIgnores = 1;
            if (this.isTouch) {
                this.listenTo($(document), {
                    touchmove: this.handleTouchMove,
                    touchend: this.endInteraction,
                    touchcancel: this.endInteraction,
                    touchstart: function(ev) {
                        if (touchStartIgnores) {
                            touchStartIgnores--;
                        } else {
                            _this.endInteraction(ev, true);
                        }
                    }
                });
                if (!bindAnyScroll(this.handleTouchScrollProxy) && this.scrollEl) {
                    this.listenTo(this.scrollEl, "scroll", this.handleTouchScroll);
                }
            } else {
                this.listenTo($(document), {
                    mousemove: this.handleMouseMove,
                    mouseup: this.endInteraction
                });
            }
            this.listenTo($(document), {
                selectstart: preventDefault,
                contextmenu: preventDefault
            });
        },
        unbindHandlers: function() {
            this.stopListeningTo($(document));
            unbindAnyScroll(this.handleTouchScrollProxy);
            if (this.scrollEl) {
                this.stopListeningTo(this.scrollEl, "scroll");
            }
        },
        startDrag: function(ev, extraOptions) {
            this.startInteraction(ev, extraOptions);
            if (!this.isDragging) {
                this.isDragging = true;
                this.handleDragStart(ev);
            }
        },
        handleDragStart: function(ev) {
            this.trigger("dragStart", ev);
        },
        handleMove: function(ev) {
            var dx = getEvX(ev) - this.originX;
            var dy = getEvY(ev) - this.originY;
            var minDistance = this.minDistance;
            var distanceSq;
            if (!this.isDistanceSurpassed) {
                distanceSq = dx * dx + dy * dy;
                if (distanceSq >= minDistance * minDistance) {
                    this.handleDistanceSurpassed(ev);
                }
            }
            if (this.isDragging) {
                this.handleDrag(dx, dy, ev);
            }
        },
        handleDrag: function(dx, dy, ev) {
            this.trigger("drag", dx, dy, ev);
            this.updateAutoScroll(ev);
        },
        endDrag: function(ev) {
            if (this.isDragging) {
                this.isDragging = false;
                this.handleDragEnd(ev);
            }
        },
        handleDragEnd: function(ev) {
            this.trigger("dragEnd", ev);
        },
        startDelay: function(initialEv) {
            var _this = this;
            if (this.delay) {
                this.delayTimeoutId = setTimeout(function() {
                    _this.handleDelayEnd(initialEv);
                }, this.delay);
            } else {
                this.handleDelayEnd(initialEv);
            }
        },
        handleDelayEnd: function(initialEv) {
            this.isDelayEnded = true;
            if (this.isDistanceSurpassed) {
                this.startDrag(initialEv);
            }
        },
        handleDistanceSurpassed: function(ev) {
            this.isDistanceSurpassed = true;
            if (this.isDelayEnded) {
                this.startDrag(ev);
            }
        },
        handleTouchMove: function(ev) {
            if (this.isDragging) {
                ev.preventDefault();
            }
            this.handleMove(ev);
        },
        handleMouseMove: function(ev) {
            this.handleMove(ev);
        },
        handleTouchScroll: function(ev) {
            if (!this.isDragging) {
                this.endInteraction(ev, true);
            }
        },
        trigger: function(name) {
            if (this.options[name]) {
                this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
            if (this["_" + name]) {
                this["_" + name].apply(this, Array.prototype.slice.call(arguments, 1));
            }
        }
    });
    DragListener.mixin({
        isAutoScroll: false,
        scrollBounds: null,
        scrollTopVel: null,
        scrollLeftVel: null,
        scrollIntervalId: null,
        scrollSensitivity: 30,
        scrollSpeed: 200,
        scrollIntervalMs: 50,
        initAutoScroll: function() {
            var scrollEl = this.scrollEl;
            this.isAutoScroll = this.options.scroll && scrollEl && !scrollEl.is(window) && !scrollEl.is(document);
            if (this.isAutoScroll) {
                this.listenTo(scrollEl, "scroll", debounce(this.handleDebouncedScroll, 100));
            }
        },
        destroyAutoScroll: function() {
            this.endAutoScroll();
            if (this.isAutoScroll) {
                this.stopListeningTo(this.scrollEl, "scroll");
            }
        },
        computeScrollBounds: function() {
            if (this.isAutoScroll) {
                this.scrollBounds = getOuterRect(this.scrollEl);
            }
        },
        updateAutoScroll: function(ev) {
            var sensitivity = this.scrollSensitivity;
            var bounds = this.scrollBounds;
            var topCloseness, bottomCloseness;
            var leftCloseness, rightCloseness;
            var topVel = 0;
            var leftVel = 0;
            if (bounds) {
                topCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;
                bottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;
                leftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;
                rightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;
                if (topCloseness >= 0 && topCloseness <= 1) {
                    topVel = topCloseness * this.scrollSpeed * -1;
                } else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
                    topVel = bottomCloseness * this.scrollSpeed;
                }
                if (leftCloseness >= 0 && leftCloseness <= 1) {
                    leftVel = leftCloseness * this.scrollSpeed * -1;
                } else if (rightCloseness >= 0 && rightCloseness <= 1) {
                    leftVel = rightCloseness * this.scrollSpeed;
                }
            }
            this.setScrollVel(topVel, leftVel);
        },
        setScrollVel: function(topVel, leftVel) {
            this.scrollTopVel = topVel;
            this.scrollLeftVel = leftVel;
            this.constrainScrollVel();
            if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
                this.scrollIntervalId = setInterval(proxy(this, "scrollIntervalFunc"), this.scrollIntervalMs);
            }
        },
        constrainScrollVel: function() {
            var el = this.scrollEl;
            if (this.scrollTopVel < 0) {
                if (el.scrollTop() <= 0) {
                    this.scrollTopVel = 0;
                }
            } else if (this.scrollTopVel > 0) {
                if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {
                    this.scrollTopVel = 0;
                }
            }
            if (this.scrollLeftVel < 0) {
                if (el.scrollLeft() <= 0) {
                    this.scrollLeftVel = 0;
                }
            } else if (this.scrollLeftVel > 0) {
                if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {
                    this.scrollLeftVel = 0;
                }
            }
        },
        scrollIntervalFunc: function() {
            var el = this.scrollEl;
            var frac = this.scrollIntervalMs / 1e3;
            if (this.scrollTopVel) {
                el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
            }
            if (this.scrollLeftVel) {
                el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
            }
            this.constrainScrollVel();
            if (!this.scrollTopVel && !this.scrollLeftVel) {
                this.endAutoScroll();
            }
        },
        endAutoScroll: function() {
            if (this.scrollIntervalId) {
                clearInterval(this.scrollIntervalId);
                this.scrollIntervalId = null;
                this.handleScrollEnd();
            }
        },
        handleDebouncedScroll: function() {
            if (!this.scrollIntervalId) {
                this.handleScrollEnd();
            }
        },
        handleScrollEnd: function() {}
    });
    var HitDragListener = DragListener.extend({
        component: null,
        origHit: null,
        hit: null,
        coordAdjust: null,
        constructor: function(component, options) {
            DragListener.call(this, options);
            this.component = component;
        },
        handleInteractionStart: function(ev) {
            var subjectEl = this.subjectEl;
            var subjectRect;
            var origPoint;
            var point;
            this.computeCoords();
            if (ev) {
                origPoint = {
                    left: getEvX(ev),
                    top: getEvY(ev)
                };
                point = origPoint;
                if (subjectEl) {
                    subjectRect = getOuterRect(subjectEl);
                    point = constrainPoint(point, subjectRect);
                }
                this.origHit = this.queryHit(point.left, point.top);
                if (subjectEl && this.options.subjectCenter) {
                    if (this.origHit) {
                        subjectRect = intersectRects(this.origHit, subjectRect) || subjectRect;
                    }
                    point = getRectCenter(subjectRect);
                }
                this.coordAdjust = diffPoints(point, origPoint);
            } else {
                this.origHit = null;
                this.coordAdjust = null;
            }
            DragListener.prototype.handleInteractionStart.apply(this, arguments);
        },
        computeCoords: function() {
            this.component.prepareHits();
            this.computeScrollBounds();
        },
        handleDragStart: function(ev) {
            var hit;
            DragListener.prototype.handleDragStart.apply(this, arguments);
            hit = this.queryHit(getEvX(ev), getEvY(ev));
            if (hit) {
                this.handleHitOver(hit);
            }
        },
        handleDrag: function(dx, dy, ev) {
            var hit;
            DragListener.prototype.handleDrag.apply(this, arguments);
            hit = this.queryHit(getEvX(ev), getEvY(ev));
            if (!isHitsEqual(hit, this.hit)) {
                if (this.hit) {
                    this.handleHitOut();
                }
                if (hit) {
                    this.handleHitOver(hit);
                }
            }
        },
        handleDragEnd: function() {
            this.handleHitDone();
            DragListener.prototype.handleDragEnd.apply(this, arguments);
        },
        handleHitOver: function(hit) {
            var isOrig = isHitsEqual(hit, this.origHit);
            this.hit = hit;
            this.trigger("hitOver", this.hit, isOrig, this.origHit);
        },
        handleHitOut: function() {
            if (this.hit) {
                this.trigger("hitOut", this.hit);
                this.handleHitDone();
                this.hit = null;
            }
        },
        handleHitDone: function() {
            if (this.hit) {
                this.trigger("hitDone", this.hit);
            }
        },
        handleInteractionEnd: function() {
            DragListener.prototype.handleInteractionEnd.apply(this, arguments);
            this.origHit = null;
            this.hit = null;
            this.component.releaseHits();
        },
        handleScrollEnd: function() {
            DragListener.prototype.handleScrollEnd.apply(this, arguments);
            this.computeCoords();
        },
        queryHit: function(left, top) {
            if (this.coordAdjust) {
                left += this.coordAdjust.left;
                top += this.coordAdjust.top;
            }
            return this.component.queryHit(left, top);
        }
    });
    function isHitsEqual(hit0, hit1) {
        if (!hit0 && !hit1) {
            return true;
        }
        if (hit0 && hit1) {
            return hit0.component === hit1.component && isHitPropsWithin(hit0, hit1) && isHitPropsWithin(hit1, hit0);
        }
        return false;
    }
    function isHitPropsWithin(subHit, superHit) {
        for (var propName in subHit) {
            if (!/^(component|left|right|top|bottom)$/.test(propName)) {
                if (subHit[propName] !== superHit[propName]) {
                    return false;
                }
            }
        }
        return true;
    }
    var MouseFollower = Class.extend(ListenerMixin, {
        options: null,
        sourceEl: null,
        el: null,
        parentEl: null,
        top0: null,
        left0: null,
        y0: null,
        x0: null,
        topDelta: null,
        leftDelta: null,
        isFollowing: false,
        isHidden: false,
        isAnimating: false,
        constructor: function(sourceEl, options) {
            this.options = options = options || {};
            this.sourceEl = sourceEl;
            this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent();
        },
        start: function(ev) {
            if (!this.isFollowing) {
                this.isFollowing = true;
                this.y0 = getEvY(ev);
                this.x0 = getEvX(ev);
                this.topDelta = 0;
                this.leftDelta = 0;
                if (!this.isHidden) {
                    this.updatePosition();
                }
                if (getEvIsTouch(ev)) {
                    this.listenTo($(document), "touchmove", this.handleMove);
                } else {
                    this.listenTo($(document), "mousemove", this.handleMove);
                }
            }
        },
        stop: function(shouldRevert, callback) {
            var _this = this;
            var revertDuration = this.options.revertDuration;
            function complete() {
                _this.isAnimating = false;
                _this.removeElement();
                _this.top0 = _this.left0 = null;
                if (callback) {
                    callback();
                }
            }
            if (this.isFollowing && !this.isAnimating) {
                this.isFollowing = false;
                this.stopListeningTo($(document));
                if (shouldRevert && revertDuration && !this.isHidden) {
                    this.isAnimating = true;
                    this.el.animate({
                        top: this.top0,
                        left: this.left0
                    }, {
                        duration: revertDuration,
                        complete: complete
                    });
                } else {
                    complete();
                }
            }
        },
        getEl: function() {
            var el = this.el;
            if (!el) {
                el = this.el = this.sourceEl.clone().addClass(this.options.additionalClass || "").css({
                    position: "absolute",
                    visibility: "",
                    display: this.isHidden ? "none" : "",
                    margin: 0,
                    right: "auto",
                    bottom: "auto",
                    width: this.sourceEl.width(),
                    height: this.sourceEl.height(),
                    opacity: this.options.opacity || "",
                    zIndex: this.options.zIndex
                });
                el.addClass("fc-unselectable");
                el.appendTo(this.parentEl);
            }
            return el;
        },
        removeElement: function() {
            if (this.el) {
                this.el.remove();
                this.el = null;
            }
        },
        updatePosition: function() {
            var sourceOffset;
            var origin;
            this.getEl();
            if (this.top0 === null) {
                sourceOffset = this.sourceEl.offset();
                origin = this.el.offsetParent().offset();
                this.top0 = sourceOffset.top - origin.top;
                this.left0 = sourceOffset.left - origin.left;
            }
            this.el.css({
                top: this.top0 + this.topDelta,
                left: this.left0 + this.leftDelta
            });
        },
        handleMove: function(ev) {
            this.topDelta = getEvY(ev) - this.y0;
            this.leftDelta = getEvX(ev) - this.x0;
            if (!this.isHidden) {
                this.updatePosition();
            }
        },
        hide: function() {
            if (!this.isHidden) {
                this.isHidden = true;
                if (this.el) {
                    this.el.hide();
                }
            }
        },
        show: function() {
            if (this.isHidden) {
                this.isHidden = false;
                this.updatePosition();
                this.getEl().show();
            }
        }
    });
    var Grid = FC.Grid = Class.extend(ListenerMixin, MouseIgnorerMixin, {
        hasDayInteractions: true,
        view: null,
        isRTL: null,
        start: null,
        end: null,
        el: null,
        elsByFill: null,
        eventTimeFormat: null,
        displayEventTime: null,
        displayEventEnd: null,
        minResizeDuration: null,
        largeUnit: null,
        dayDragListener: null,
        segDragListener: null,
        segResizeListener: null,
        externalDragListener: null,
        constructor: function(view) {
            this.view = view;
            this.isRTL = view.opt("isRTL");
            this.elsByFill = {};
            this.dayDragListener = this.buildDayDragListener();
            this.initMouseIgnoring();
        },
        computeEventTimeFormat: function() {
            return this.view.opt("smallTimeFormat");
        },
        computeDisplayEventTime: function() {
            return true;
        },
        computeDisplayEventEnd: function() {
            return true;
        },
        setRange: function(range) {
            this.start = range.start.clone();
            this.end = range.end.clone();
            this.rangeUpdated();
            this.processRangeOptions();
        },
        rangeUpdated: function() {},
        processRangeOptions: function() {
            var view = this.view;
            var displayEventTime;
            var displayEventEnd;
            this.eventTimeFormat = view.opt("eventTimeFormat") || view.opt("timeFormat") || this.computeEventTimeFormat();
            displayEventTime = view.opt("displayEventTime");
            if (displayEventTime == null) {
                displayEventTime = this.computeDisplayEventTime();
            }
            displayEventEnd = view.opt("displayEventEnd");
            if (displayEventEnd == null) {
                displayEventEnd = this.computeDisplayEventEnd();
            }
            this.displayEventTime = displayEventTime;
            this.displayEventEnd = displayEventEnd;
        },
        spanToSegs: function(span) {},
        diffDates: function(a, b) {
            if (this.largeUnit) {
                return diffByUnit(a, b, this.largeUnit);
            } else {
                return diffDayTime(a, b);
            }
        },
        prepareHits: function() {},
        releaseHits: function() {},
        queryHit: function(leftOffset, topOffset) {},
        getHitSpan: function(hit) {},
        getHitEl: function(hit) {},
        setElement: function(el) {
            this.el = el;
            if (this.hasDayInteractions) {
                preventSelection(el);
                this.bindDayHandler("touchstart", this.dayTouchStart);
                this.bindDayHandler("mousedown", this.dayMousedown);
            }
            this.bindSegHandlers();
            this.bindGlobalHandlers();
        },
        bindDayHandler: function(name, handler) {
            var _this = this;
            this.el.on(name, function(ev) {
                if (!$(ev.target).is(_this.segSelector + "," + _this.segSelector + " *," + ".fc-more," + "a[data-goto]")) {
                    return handler.call(_this, ev);
                }
            });
        },
        removeElement: function() {
            this.unbindGlobalHandlers();
            this.clearDragListeners();
            this.el.remove();
        },
        renderSkeleton: function() {},
        renderDates: function() {},
        unrenderDates: function() {},
        bindGlobalHandlers: function() {
            this.listenTo($(document), {
                dragstart: this.externalDragStart,
                sortstart: this.externalDragStart
            });
        },
        unbindGlobalHandlers: function() {
            this.stopListeningTo($(document));
        },
        dayMousedown: function(ev) {
            if (!this.isIgnoringMouse) {
                this.dayDragListener.startInteraction(ev, {});
            }
        },
        dayTouchStart: function(ev) {
            var view = this.view;
            if (view.isSelected || view.selectedEvent) {
                this.tempIgnoreMouse();
            }
            this.dayDragListener.startInteraction(ev, {
                delay: this.view.opt("longPressDelay")
            });
        },
        buildDayDragListener: function() {
            var _this = this;
            var view = this.view;
            var isSelectable = view.opt("selectable");
            var dayClickHit;
            var selectionSpan;
            var dragListener = new HitDragListener(this, {
                scroll: view.opt("dragScroll"),
                interactionStart: function() {
                    dayClickHit = dragListener.origHit;
                    selectionSpan = null;
                },
                dragStart: function() {
                    view.unselect();
                },
                hitOver: function(hit, isOrig, origHit) {
                    if (origHit) {
                        if (!isOrig) {
                            dayClickHit = null;
                        }
                        if (isSelectable) {
                            selectionSpan = _this.computeSelection(_this.getHitSpan(origHit), _this.getHitSpan(hit));
                            if (selectionSpan) {
                                _this.renderSelection(selectionSpan);
                            } else if (selectionSpan === false) {
                                disableCursor();
                            }
                        }
                    }
                },
                hitOut: function() {
                    dayClickHit = null;
                    selectionSpan = null;
                    _this.unrenderSelection();
                },
                hitDone: function() {
                    enableCursor();
                },
                interactionEnd: function(ev, isCancelled) {
                    if (!isCancelled) {
                        if (dayClickHit && !_this.isIgnoringMouse) {
                            view.triggerDayClick(_this.getHitSpan(dayClickHit), _this.getHitEl(dayClickHit), ev);
                        }
                        if (selectionSpan) {
                            view.reportSelection(selectionSpan, ev);
                        }
                    }
                }
            });
            return dragListener;
        },
        clearDragListeners: function() {
            this.dayDragListener.endInteraction();
            if (this.segDragListener) {
                this.segDragListener.endInteraction();
            }
            if (this.segResizeListener) {
                this.segResizeListener.endInteraction();
            }
            if (this.externalDragListener) {
                this.externalDragListener.endInteraction();
            }
        },
        renderEventLocationHelper: function(eventLocation, sourceSeg) {
            var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);
            return this.renderHelper(fakeEvent, sourceSeg);
        },
        fabricateHelperEvent: function(eventLocation, sourceSeg) {
            var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {};
            fakeEvent.start = eventLocation.start.clone();
            fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;
            fakeEvent.allDay = null;
            this.view.calendar.normalizeEventDates(fakeEvent);
            fakeEvent.className = (fakeEvent.className || []).concat("fc-helper");
            if (!sourceSeg) {
                fakeEvent.editable = false;
            }
            return fakeEvent;
        },
        renderHelper: function(eventLocation, sourceSeg) {},
        unrenderHelper: function() {},
        renderSelection: function(span) {
            this.renderHighlight(span);
        },
        unrenderSelection: function() {
            this.unrenderHighlight();
        },
        computeSelection: function(span0, span1) {
            var span = this.computeSelectionSpan(span0, span1);
            if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {
                return false;
            }
            return span;
        },
        computeSelectionSpan: function(span0, span1) {
            var dates = [ span0.start, span0.end, span1.start, span1.end ];
            dates.sort(compareNumbers);
            return {
                start: dates[0].clone(),
                end: dates[3].clone()
            };
        },
        renderHighlight: function(span) {
            this.renderFill("highlight", this.spanToSegs(span));
        },
        unrenderHighlight: function() {
            this.unrenderFill("highlight");
        },
        highlightSegClasses: function() {
            return [ "fc-highlight" ];
        },
        renderBusinessHours: function() {},
        unrenderBusinessHours: function() {},
        getNowIndicatorUnit: function() {},
        renderNowIndicator: function(date) {},
        unrenderNowIndicator: function() {},
        renderFill: function(type, segs) {},
        unrenderFill: function(type) {
            var el = this.elsByFill[type];
            if (el) {
                el.remove();
                delete this.elsByFill[type];
            }
        },
        renderFillSegEls: function(type, segs) {
            var _this = this;
            var segElMethod = this[type + "SegEl"];
            var html = "";
            var renderedSegs = [];
            var i;
            if (segs.length) {
                for (i = 0; i < segs.length; i++) {
                    html += this.fillSegHtml(type, segs[i]);
                }
                $(html).each(function(i, node) {
                    var seg = segs[i];
                    var el = $(node);
                    if (segElMethod) {
                        el = segElMethod.call(_this, seg, el);
                    }
                    if (el) {
                        el = $(el);
                        if (el.is(_this.fillSegTag)) {
                            seg.el = el;
                            renderedSegs.push(seg);
                        }
                    }
                });
            }
            return renderedSegs;
        },
        fillSegTag: "div",
        fillSegHtml: function(type, seg) {
            var classesMethod = this[type + "SegClasses"];
            var cssMethod = this[type + "SegCss"];
            var classes = classesMethod ? classesMethod.call(this, seg) : [];
            var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});
            return "<" + this.fillSegTag + (classes.length ? ' class="' + classes.join(" ") + '"' : "") + (css ? ' style="' + css + '"' : "") + " />";
        },
        getDayClasses: function(date) {
            var view = this.view;
            var today = view.calendar.getNow();
            var classes = [ "fc-" + dayIDs[date.day()] ];
            if (view.intervalDuration.as("months") == 1 && date.month() != view.intervalStart.month()) {
                classes.push("fc-other-month");
            }
            if (date.isSame(today, "day")) {
                classes.push("fc-today", view.highlightStateClass);
            } else if (date < today) {
                classes.push("fc-past");
            } else {
                classes.push("fc-future");
            }
            return classes;
        }
    });
    Grid.mixin({
        segSelector: ".fc-event-container > *",
        mousedOverSeg: null,
        isDraggingSeg: false,
        isResizingSeg: false,
        isDraggingExternal: false,
        segs: null,
        renderEvents: function(events) {
            var bgEvents = [];
            var fgEvents = [];
            var i;
            for (i = 0; i < events.length; i++) {
                (isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);
            }
            this.segs = [].concat(this.renderBgEvents(bgEvents), this.renderFgEvents(fgEvents));
        },
        renderBgEvents: function(events) {
            var segs = this.eventsToSegs(events);
            return this.renderBgSegs(segs) || segs;
        },
        renderFgEvents: function(events) {
            var segs = this.eventsToSegs(events);
            return this.renderFgSegs(segs) || segs;
        },
        unrenderEvents: function() {
            this.handleSegMouseout();
            this.clearDragListeners();
            this.unrenderFgSegs();
            this.unrenderBgSegs();
            this.segs = null;
        },
        getEventSegs: function() {
            return this.segs || [];
        },
        renderFgSegs: function(segs) {},
        unrenderFgSegs: function() {},
        renderFgSegEls: function(segs, disableResizing) {
            var view = this.view;
            var html = "";
            var renderedSegs = [];
            var i;
            if (segs.length) {
                for (i = 0; i < segs.length; i++) {
                    html += this.fgSegHtml(segs[i], disableResizing);
                }
                $(html).each(function(i, node) {
                    var seg = segs[i];
                    var el = view.resolveEventEl(seg.event, $(node));
                    if (el) {
                        el.data("fc-seg", seg);
                        seg.el = el;
                        renderedSegs.push(seg);
                    }
                });
            }
            return renderedSegs;
        },
        fgSegHtml: function(seg, disableResizing) {},
        renderBgSegs: function(segs) {
            return this.renderFill("bgEvent", segs);
        },
        unrenderBgSegs: function() {
            this.unrenderFill("bgEvent");
        },
        bgEventSegEl: function(seg, el) {
            return this.view.resolveEventEl(seg.event, el);
        },
        bgEventSegClasses: function(seg) {
            var event = seg.event;
            var source = event.source || {};
            return [ "fc-bgevent" ].concat(event.className, source.className || []);
        },
        bgEventSegCss: function(seg) {
            return {
                "background-color": this.getSegSkinCss(seg)["background-color"]
            };
        },
        businessHoursSegClasses: function(seg) {
            return [ "fc-nonbusiness", "fc-bgevent" ];
        },
        buildBusinessHourSegs: function(wholeDay) {
            var events = this.view.calendar.getCurrentBusinessHourEvents(wholeDay);
            if (!events.length && this.view.calendar.options.businessHours) {
                events = [ $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {
                    start: this.view.end,
                    end: this.view.end,
                    dow: null
                }) ];
            }
            return this.eventsToSegs(events);
        },
        bindSegHandlers: function() {
            this.bindSegHandlersToEl(this.el);
        },
        bindSegHandlersToEl: function(el) {
            this.bindSegHandlerToEl(el, "touchstart", this.handleSegTouchStart);
            this.bindSegHandlerToEl(el, "touchend", this.handleSegTouchEnd);
            this.bindSegHandlerToEl(el, "mouseenter", this.handleSegMouseover);
            this.bindSegHandlerToEl(el, "mouseleave", this.handleSegMouseout);
            this.bindSegHandlerToEl(el, "mousedown", this.handleSegMousedown);
            this.bindSegHandlerToEl(el, "click", this.handleSegClick);
        },
        bindSegHandlerToEl: function(el, name, handler) {
            var _this = this;
            el.on(name, this.segSelector, function(ev) {
                var seg = $(this).data("fc-seg");
                if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
                    return handler.call(_this, seg, ev);
                }
            });
        },
        handleSegClick: function(seg, ev) {
            var res = this.view.trigger("eventClick", seg.el[0], seg.event, ev);
            if (res === false) {
                ev.preventDefault();
            }
        },
        handleSegMouseover: function(seg, ev) {
            if (!this.isIgnoringMouse && !this.mousedOverSeg) {
                this.mousedOverSeg = seg;
                if (this.view.isEventResizable(seg.event)) {
                    seg.el.addClass("fc-allow-mouse-resize");
                }
                this.view.trigger("eventMouseover", seg.el[0], seg.event, ev);
            }
        },
        handleSegMouseout: function(seg, ev) {
            ev = ev || {};
            if (this.mousedOverSeg) {
                seg = seg || this.mousedOverSeg;
                this.mousedOverSeg = null;
                if (this.view.isEventResizable(seg.event)) {
                    seg.el.removeClass("fc-allow-mouse-resize");
                }
                this.view.trigger("eventMouseout", seg.el[0], seg.event, ev);
            }
        },
        handleSegMousedown: function(seg, ev) {
            var isResizing = this.startSegResize(seg, ev, {
                distance: 5
            });
            if (!isResizing && this.view.isEventDraggable(seg.event)) {
                this.buildSegDragListener(seg).startInteraction(ev, {
                    distance: 5
                });
            }
        },
        handleSegTouchStart: function(seg, ev) {
            var view = this.view;
            var event = seg.event;
            var isSelected = view.isEventSelected(event);
            var isDraggable = view.isEventDraggable(event);
            var isResizable = view.isEventResizable(event);
            var isResizing = false;
            var dragListener;
            if (isSelected && isResizable) {
                isResizing = this.startSegResize(seg, ev);
            }
            if (!isResizing && (isDraggable || isResizable)) {
                dragListener = isDraggable ? this.buildSegDragListener(seg) : this.buildSegSelectListener(seg);
                dragListener.startInteraction(ev, {
                    delay: isSelected ? 0 : this.view.opt("longPressDelay")
                });
            }
            this.tempIgnoreMouse();
        },
        handleSegTouchEnd: function(seg, ev) {
            this.tempIgnoreMouse();
        },
        startSegResize: function(seg, ev, dragOptions) {
            if ($(ev.target).is(".fc-resizer")) {
                this.buildSegResizeListener(seg, $(ev.target).is(".fc-start-resizer")).startInteraction(ev, dragOptions);
                return true;
            }
            return false;
        },
        buildSegDragListener: function(seg) {
            var _this = this;
            var view = this.view;
            var calendar = view.calendar;
            var el = seg.el;
            var event = seg.event;
            var isDragging;
            var mouseFollower;
            var dropLocation;
            if (this.segDragListener) {
                return this.segDragListener;
            }
            var dragListener = this.segDragListener = new HitDragListener(view, {
                scroll: view.opt("dragScroll"),
                subjectEl: el,
                subjectCenter: true,
                interactionStart: function(ev) {
                    seg.component = _this;
                    isDragging = false;
                    mouseFollower = new MouseFollower(seg.el, {
                        additionalClass: "fc-dragging",
                        parentEl: view.el,
                        opacity: dragListener.isTouch ? null : view.opt("dragOpacity"),
                        revertDuration: view.opt("dragRevertDuration"),
                        zIndex: 2
                    });
                    mouseFollower.hide();
                    mouseFollower.start(ev);
                },
                dragStart: function(ev) {
                    if (dragListener.isTouch && !view.isEventSelected(event)) {
                        view.selectEvent(event);
                    }
                    isDragging = true;
                    _this.handleSegMouseout(seg, ev);
                    _this.segDragStart(seg, ev);
                    view.hideEvent(event);
                },
                hitOver: function(hit, isOrig, origHit) {
                    var dragHelperEls;
                    if (seg.hit) {
                        origHit = seg.hit;
                    }
                    dropLocation = _this.computeEventDrop(origHit.component.getHitSpan(origHit), hit.component.getHitSpan(hit), event);
                    if (dropLocation && !calendar.isEventSpanAllowed(_this.eventToSpan(dropLocation), event)) {
                        disableCursor();
                        dropLocation = null;
                    }
                    if (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {
                        dragHelperEls.addClass("fc-dragging");
                        if (!dragListener.isTouch) {
                            _this.applyDragOpacity(dragHelperEls);
                        }
                        mouseFollower.hide();
                    } else {
                        mouseFollower.show();
                    }
                    if (isOrig) {
                        dropLocation = null;
                    }
                },
                hitOut: function() {
                    view.unrenderDrag();
                    mouseFollower.show();
                    dropLocation = null;
                },
                hitDone: function() {
                    enableCursor();
                },
                interactionEnd: function(ev) {
                    delete seg.component;
                    mouseFollower.stop(!dropLocation, function() {
                        if (isDragging) {
                            view.unrenderDrag();
                            view.showEvent(event);
                            _this.segDragStop(seg, ev);
                        }
                        if (dropLocation) {
                            view.reportEventDrop(event, dropLocation, this.largeUnit, el, ev);
                        }
                    });
                    _this.segDragListener = null;
                }
            });
            return dragListener;
        },
        buildSegSelectListener: function(seg) {
            var _this = this;
            var view = this.view;
            var event = seg.event;
            if (this.segDragListener) {
                return this.segDragListener;
            }
            var dragListener = this.segDragListener = new DragListener({
                dragStart: function(ev) {
                    if (dragListener.isTouch && !view.isEventSelected(event)) {
                        view.selectEvent(event);
                    }
                },
                interactionEnd: function(ev) {
                    _this.segDragListener = null;
                }
            });
            return dragListener;
        },
        segDragStart: function(seg, ev) {
            this.isDraggingSeg = true;
            this.view.trigger("eventDragStart", seg.el[0], seg.event, ev, {});
        },
        segDragStop: function(seg, ev) {
            this.isDraggingSeg = false;
            this.view.trigger("eventDragStop", seg.el[0], seg.event, ev, {});
        },
        computeEventDrop: function(startSpan, endSpan, event) {
            var calendar = this.view.calendar;
            var dragStart = startSpan.start;
            var dragEnd = endSpan.start;
            var delta;
            var dropLocation;
            if (dragStart.hasTime() === dragEnd.hasTime()) {
                delta = this.diffDates(dragEnd, dragStart);
                if (event.allDay && durationHasTime(delta)) {
                    dropLocation = {
                        start: event.start.clone(),
                        end: calendar.getEventEnd(event),
                        allDay: false
                    };
                    calendar.normalizeEventTimes(dropLocation);
                } else {
                    dropLocation = pluckEventDateProps(event);
                }
                dropLocation.start.add(delta);
                if (dropLocation.end) {
                    dropLocation.end.add(delta);
                }
            } else {
                dropLocation = {
                    start: dragEnd.clone(),
                    end: null,
                    allDay: !dragEnd.hasTime()
                };
            }
            return dropLocation;
        },
        applyDragOpacity: function(els) {
            var opacity = this.view.opt("dragOpacity");
            if (opacity != null) {
                els.css("opacity", opacity);
            }
        },
        externalDragStart: function(ev, ui) {
            var view = this.view;
            var el;
            var accept;
            if (view.opt("droppable")) {
                el = $((ui ? ui.item : null) || ev.target);
                accept = view.opt("dropAccept");
                if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
                    if (!this.isDraggingExternal) {
                        this.listenToExternalDrag(el, ev, ui);
                    }
                }
            }
        },
        listenToExternalDrag: function(el, ev, ui) {
            var _this = this;
            var calendar = this.view.calendar;
            var meta = getDraggedElMeta(el);
            var dropLocation;
            var dragListener = _this.externalDragListener = new HitDragListener(this, {
                interactionStart: function() {
                    _this.isDraggingExternal = true;
                },
                hitOver: function(hit) {
                    dropLocation = _this.computeExternalDrop(hit.component.getHitSpan(hit), meta);
                    if (dropLocation && !calendar.isExternalSpanAllowed(_this.eventToSpan(dropLocation), dropLocation, meta.eventProps)) {
                        disableCursor();
                        dropLocation = null;
                    }
                    if (dropLocation) {
                        _this.renderDrag(dropLocation);
                    }
                },
                hitOut: function() {
                    dropLocation = null;
                },
                hitDone: function() {
                    enableCursor();
                    _this.unrenderDrag();
                },
                interactionEnd: function(ev) {
                    if (dropLocation) {
                        _this.view.reportExternalDrop(meta, dropLocation, el, ev, ui);
                    }
                    _this.isDraggingExternal = false;
                    _this.externalDragListener = null;
                }
            });
            dragListener.startDrag(ev);
        },
        computeExternalDrop: function(span, meta) {
            var calendar = this.view.calendar;
            var dropLocation = {
                start: calendar.applyTimezone(span.start),
                end: null
            };
            if (meta.startTime && !dropLocation.start.hasTime()) {
                dropLocation.start.time(meta.startTime);
            }
            if (meta.duration) {
                dropLocation.end = dropLocation.start.clone().add(meta.duration);
            }
            return dropLocation;
        },
        renderDrag: function(dropLocation, seg) {},
        unrenderDrag: function() {},
        buildSegResizeListener: function(seg, isStart) {
            var _this = this;
            var view = this.view;
            var calendar = view.calendar;
            var el = seg.el;
            var event = seg.event;
            var eventEnd = calendar.getEventEnd(event);
            var isDragging;
            var resizeLocation;
            var dragListener = this.segResizeListener = new HitDragListener(this, {
                scroll: view.opt("dragScroll"),
                subjectEl: el,
                interactionStart: function() {
                    isDragging = false;
                },
                dragStart: function(ev) {
                    isDragging = true;
                    _this.handleSegMouseout(seg, ev);
                    _this.segResizeStart(seg, ev);
                },
                hitOver: function(hit, isOrig, origHit) {
                    var origHitSpan = _this.getHitSpan(origHit);
                    var hitSpan = _this.getHitSpan(hit);
                    resizeLocation = isStart ? _this.computeEventStartResize(origHitSpan, hitSpan, event) : _this.computeEventEndResize(origHitSpan, hitSpan, event);
                    if (resizeLocation) {
                        if (!calendar.isEventSpanAllowed(_this.eventToSpan(resizeLocation), event)) {
                            disableCursor();
                            resizeLocation = null;
                        } else if (resizeLocation.start.isSame(event.start.clone().stripZone()) && resizeLocation.end.isSame(eventEnd.clone().stripZone())) {
                            resizeLocation = null;
                        }
                    }
                    if (resizeLocation) {
                        view.hideEvent(event);
                        _this.renderEventResize(resizeLocation, seg);
                    }
                },
                hitOut: function() {
                    resizeLocation = null;
                },
                hitDone: function() {
                    _this.unrenderEventResize();
                    view.showEvent(event);
                    enableCursor();
                },
                interactionEnd: function(ev) {
                    if (isDragging) {
                        _this.segResizeStop(seg, ev);
                    }
                    if (resizeLocation) {
                        view.reportEventResize(event, resizeLocation, this.largeUnit, el, ev);
                    }
                    _this.segResizeListener = null;
                }
            });
            return dragListener;
        },
        segResizeStart: function(seg, ev) {
            this.isResizingSeg = true;
            this.view.trigger("eventResizeStart", seg.el[0], seg.event, ev, {});
        },
        segResizeStop: function(seg, ev) {
            this.isResizingSeg = false;
            this.view.trigger("eventResizeStop", seg.el[0], seg.event, ev, {});
        },
        computeEventStartResize: function(startSpan, endSpan, event) {
            return this.computeEventResize("start", startSpan, endSpan, event);
        },
        computeEventEndResize: function(startSpan, endSpan, event) {
            return this.computeEventResize("end", startSpan, endSpan, event);
        },
        computeEventResize: function(type, startSpan, endSpan, event) {
            var calendar = this.view.calendar;
            var delta = this.diffDates(endSpan[type], startSpan[type]);
            var resizeLocation;
            var defaultDuration;
            resizeLocation = {
                start: event.start.clone(),
                end: calendar.getEventEnd(event),
                allDay: event.allDay
            };
            if (resizeLocation.allDay && durationHasTime(delta)) {
                resizeLocation.allDay = false;
                calendar.normalizeEventTimes(resizeLocation);
            }
            resizeLocation[type].add(delta);
            if (!resizeLocation.start.isBefore(resizeLocation.end)) {
                defaultDuration = this.minResizeDuration || (event.allDay ? calendar.defaultAllDayEventDuration : calendar.defaultTimedEventDuration);
                if (type == "start") {
                    resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);
                } else {
                    resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);
                }
            }
            return resizeLocation;
        },
        renderEventResize: function(range, seg) {},
        unrenderEventResize: function() {},
        getEventTimeText: function(range, formatStr, displayEnd) {
            if (formatStr == null) {
                formatStr = this.eventTimeFormat;
            }
            if (displayEnd == null) {
                displayEnd = this.displayEventEnd;
            }
            if (this.displayEventTime && range.start.hasTime()) {
                if (displayEnd && range.end) {
                    return this.view.formatRange(range, formatStr);
                } else {
                    return range.start.format(formatStr);
                }
            }
            return "";
        },
        getSegClasses: function(seg, isDraggable, isResizable) {
            var view = this.view;
            var classes = [ "fc-event", seg.isStart ? "fc-start" : "fc-not-start", seg.isEnd ? "fc-end" : "fc-not-end" ].concat(this.getSegCustomClasses(seg));
            if (isDraggable) {
                classes.push("fc-draggable");
            }
            if (isResizable) {
                classes.push("fc-resizable");
            }
            if (view.isEventSelected(seg.event)) {
                classes.push("fc-selected");
            }
            return classes;
        },
        getSegCustomClasses: function(seg) {
            var event = seg.event;
            return [].concat(event.className, event.source ? event.source.className : []);
        },
        getSegSkinCss: function(seg) {
            return {
                "background-color": this.getSegBackgroundColor(seg),
                "border-color": this.getSegBorderColor(seg),
                color: this.getSegTextColor(seg)
            };
        },
        getSegBackgroundColor: function(seg) {
            return seg.event.backgroundColor || seg.event.color || this.getSegDefaultBackgroundColor(seg);
        },
        getSegDefaultBackgroundColor: function(seg) {
            var source = seg.event.source || {};
            return source.backgroundColor || source.color || this.view.opt("eventBackgroundColor") || this.view.opt("eventColor");
        },
        getSegBorderColor: function(seg) {
            return seg.event.borderColor || seg.event.color || this.getSegDefaultBorderColor(seg);
        },
        getSegDefaultBorderColor: function(seg) {
            var source = seg.event.source || {};
            return source.borderColor || source.color || this.view.opt("eventBorderColor") || this.view.opt("eventColor");
        },
        getSegTextColor: function(seg) {
            return seg.event.textColor || this.getSegDefaultTextColor(seg);
        },
        getSegDefaultTextColor: function(seg) {
            var source = seg.event.source || {};
            return source.textColor || this.view.opt("eventTextColor");
        },
        eventToSegs: function(event) {
            return this.eventsToSegs([ event ]);
        },
        eventToSpan: function(event) {
            return this.eventToSpans(event)[0];
        },
        eventToSpans: function(event) {
            var range = this.eventToRange(event);
            return this.eventRangeToSpans(range, event);
        },
        eventsToSegs: function(allEvents, segSliceFunc) {
            var _this = this;
            var eventsById = groupEventsById(allEvents);
            var segs = [];
            $.each(eventsById, function(id, events) {
                var ranges = [];
                var i;
                for (i = 0; i < events.length; i++) {
                    ranges.push(_this.eventToRange(events[i]));
                }
                if (isInverseBgEvent(events[0])) {
                    ranges = _this.invertRanges(ranges);
                    for (i = 0; i < ranges.length; i++) {
                        segs.push.apply(segs, _this.eventRangeToSegs(ranges[i], events[0], segSliceFunc));
                    }
                } else {
                    for (i = 0; i < ranges.length; i++) {
                        segs.push.apply(segs, _this.eventRangeToSegs(ranges[i], events[i], segSliceFunc));
                    }
                }
            });
            return segs;
        },
        eventToRange: function(event) {
            var calendar = this.view.calendar;
            var start = event.start.clone().stripZone();
            var end = (event.end ? event.end.clone() : calendar.getDefaultEventEnd(event.allDay != null ? event.allDay : !event.start.hasTime(), event.start)).stripZone();
            calendar.localizeMoment(start);
            calendar.localizeMoment(end);
            return {
                start: start,
                end: end
            };
        },
        eventRangeToSegs: function(range, event, segSliceFunc) {
            var spans = this.eventRangeToSpans(range, event);
            var segs = [];
            var i;
            for (i = 0; i < spans.length; i++) {
                segs.push.apply(segs, this.eventSpanToSegs(spans[i], event, segSliceFunc));
            }
            return segs;
        },
        eventRangeToSpans: function(range, event) {
            return [ $.extend({}, range) ];
        },
        eventSpanToSegs: function(span, event, segSliceFunc) {
            var segs = segSliceFunc ? segSliceFunc(span) : this.spanToSegs(span);
            var i, seg;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                seg.event = event;
                seg.eventStartMS = +span.start;
                seg.eventDurationMS = span.end - span.start;
            }
            return segs;
        },
        invertRanges: function(ranges) {
            var view = this.view;
            var viewStart = view.start.clone();
            var viewEnd = view.end.clone();
            var inverseRanges = [];
            var start = viewStart;
            var i, range;
            ranges.sort(compareRanges);
            for (i = 0; i < ranges.length; i++) {
                range = ranges[i];
                if (range.start > start) {
                    inverseRanges.push({
                        start: start,
                        end: range.start
                    });
                }
                start = range.end;
            }
            if (start < viewEnd) {
                inverseRanges.push({
                    start: start,
                    end: viewEnd
                });
            }
            return inverseRanges;
        },
        sortEventSegs: function(segs) {
            segs.sort(proxy(this, "compareEventSegs"));
        },
        compareEventSegs: function(seg1, seg2) {
            return seg1.eventStartMS - seg2.eventStartMS || seg2.eventDurationMS - seg1.eventDurationMS || seg2.event.allDay - seg1.event.allDay || compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
        }
    });
    function pluckEventDateProps(event) {
        return {
            start: event.start.clone(),
            end: event.end ? event.end.clone() : null,
            allDay: event.allDay
        };
    }
    FC.pluckEventDateProps = pluckEventDateProps;
    function isBgEvent(event) {
        var rendering = getEventRendering(event);
        return rendering === "background" || rendering === "inverse-background";
    }
    FC.isBgEvent = isBgEvent;
    function isInverseBgEvent(event) {
        return getEventRendering(event) === "inverse-background";
    }
    function getEventRendering(event) {
        return firstDefined((event.source || {}).rendering, event.rendering);
    }
    function groupEventsById(events) {
        var eventsById = {};
        var i, event;
        for (i = 0; i < events.length; i++) {
            event = events[i];
            (eventsById[event._id] || (eventsById[event._id] = [])).push(event);
        }
        return eventsById;
    }
    function compareRanges(range1, range2) {
        return range1.start - range2.start;
    }
    FC.dataAttrPrefix = "";
    function getDraggedElMeta(el) {
        var prefix = FC.dataAttrPrefix;
        var eventProps;
        var startTime;
        var duration;
        var stick;
        if (prefix) {
            prefix += "-";
        }
        eventProps = el.data(prefix + "event") || null;
        if (eventProps) {
            if (typeof eventProps === "object") {
                eventProps = $.extend({}, eventProps);
            } else {
                eventProps = {};
            }
            startTime = eventProps.start;
            if (startTime == null) {
                startTime = eventProps.time;
            }
            duration = eventProps.duration;
            stick = eventProps.stick;
            delete eventProps.start;
            delete eventProps.time;
            delete eventProps.duration;
            delete eventProps.stick;
        }
        if (startTime == null) {
            startTime = el.data(prefix + "start");
        }
        if (startTime == null) {
            startTime = el.data(prefix + "time");
        }
        if (duration == null) {
            duration = el.data(prefix + "duration");
        }
        if (stick == null) {
            stick = el.data(prefix + "stick");
        }
        startTime = startTime != null ? moment.duration(startTime) : null;
        duration = duration != null ? moment.duration(duration) : null;
        stick = Boolean(stick);
        return {
            eventProps: eventProps,
            startTime: startTime,
            duration: duration,
            stick: stick
        };
    }
    var DayTableMixin = FC.DayTableMixin = {
        breakOnWeeks: false,
        dayDates: null,
        dayIndices: null,
        daysPerRow: null,
        rowCnt: null,
        colCnt: null,
        colHeadFormat: null,
        updateDayTable: function() {
            var view = this.view;
            var date = this.start.clone();
            var dayIndex = -1;
            var dayIndices = [];
            var dayDates = [];
            var daysPerRow;
            var firstDay;
            var rowCnt;
            while (date.isBefore(this.end)) {
                if (view.isHiddenDay(date)) {
                    dayIndices.push(dayIndex + .5);
                } else {
                    dayIndex++;
                    dayIndices.push(dayIndex);
                    dayDates.push(date.clone());
                }
                date.add(1, "days");
            }
            if (this.breakOnWeeks) {
                firstDay = dayDates[0].day();
                for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
                    if (dayDates[daysPerRow].day() == firstDay) {
                        break;
                    }
                }
                rowCnt = Math.ceil(dayDates.length / daysPerRow);
            } else {
                rowCnt = 1;
                daysPerRow = dayDates.length;
            }
            this.dayDates = dayDates;
            this.dayIndices = dayIndices;
            this.daysPerRow = daysPerRow;
            this.rowCnt = rowCnt;
            this.updateDayTableCols();
        },
        updateDayTableCols: function() {
            this.colCnt = this.computeColCnt();
            this.colHeadFormat = this.view.opt("columnFormat") || this.computeColHeadFormat();
        },
        computeColCnt: function() {
            return this.daysPerRow;
        },
        getCellDate: function(row, col) {
            return this.dayDates[this.getCellDayIndex(row, col)].clone();
        },
        getCellRange: function(row, col) {
            var start = this.getCellDate(row, col);
            var end = start.clone().add(1, "days");
            return {
                start: start,
                end: end
            };
        },
        getCellDayIndex: function(row, col) {
            return row * this.daysPerRow + this.getColDayIndex(col);
        },
        getColDayIndex: function(col) {
            if (this.isRTL) {
                return this.colCnt - 1 - col;
            } else {
                return col;
            }
        },
        getDateDayIndex: function(date) {
            var dayIndices = this.dayIndices;
            var dayOffset = date.diff(this.start, "days");
            if (dayOffset < 0) {
                return dayIndices[0] - 1;
            } else if (dayOffset >= dayIndices.length) {
                return dayIndices[dayIndices.length - 1] + 1;
            } else {
                return dayIndices[dayOffset];
            }
        },
        computeColHeadFormat: function() {
            if (this.rowCnt > 1 || this.colCnt > 10) {
                return "ddd";
            } else if (this.colCnt > 1) {
                return this.view.opt("dayOfMonthFormat");
            } else {
                return "dddd";
            }
        },
        sliceRangeByRow: function(range) {
            var daysPerRow = this.daysPerRow;
            var normalRange = this.view.computeDayRange(range);
            var rangeFirst = this.getDateDayIndex(normalRange.start);
            var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, "days"));
            var segs = [];
            var row;
            var rowFirst, rowLast;
            var segFirst, segLast;
            for (row = 0; row < this.rowCnt; row++) {
                rowFirst = row * daysPerRow;
                rowLast = rowFirst + daysPerRow - 1;
                segFirst = Math.max(rangeFirst, rowFirst);
                segLast = Math.min(rangeLast, rowLast);
                segFirst = Math.ceil(segFirst);
                segLast = Math.floor(segLast);
                if (segFirst <= segLast) {
                    segs.push({
                        row: row,
                        firstRowDayIndex: segFirst - rowFirst,
                        lastRowDayIndex: segLast - rowFirst,
                        isStart: segFirst === rangeFirst,
                        isEnd: segLast === rangeLast
                    });
                }
            }
            return segs;
        },
        sliceRangeByDay: function(range) {
            var daysPerRow = this.daysPerRow;
            var normalRange = this.view.computeDayRange(range);
            var rangeFirst = this.getDateDayIndex(normalRange.start);
            var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, "days"));
            var segs = [];
            var row;
            var rowFirst, rowLast;
            var i;
            var segFirst, segLast;
            for (row = 0; row < this.rowCnt; row++) {
                rowFirst = row * daysPerRow;
                rowLast = rowFirst + daysPerRow - 1;
                for (i = rowFirst; i <= rowLast; i++) {
                    segFirst = Math.max(rangeFirst, i);
                    segLast = Math.min(rangeLast, i);
                    segFirst = Math.ceil(segFirst);
                    segLast = Math.floor(segLast);
                    if (segFirst <= segLast) {
                        segs.push({
                            row: row,
                            firstRowDayIndex: segFirst - rowFirst,
                            lastRowDayIndex: segLast - rowFirst,
                            isStart: segFirst === rangeFirst,
                            isEnd: segLast === rangeLast
                        });
                    }
                }
            }
            return segs;
        },
        renderHeadHtml: function() {
            var view = this.view;
            return "" + '<div class="fc-row ' + view.widgetHeaderClass + '">' + "<table>" + "<thead>" + this.renderHeadTrHtml() + "</thead>" + "</table>" + "</div>";
        },
        renderHeadIntroHtml: function() {
            return this.renderIntroHtml();
        },
        renderHeadTrHtml: function() {
            return "" + "<tr>" + (this.isRTL ? "" : this.renderHeadIntroHtml()) + this.renderHeadDateCellsHtml() + (this.isRTL ? this.renderHeadIntroHtml() : "") + "</tr>";
        },
        renderHeadDateCellsHtml: function() {
            var htmls = [];
            var col, date;
            for (col = 0; col < this.colCnt; col++) {
                date = this.getCellDate(0, col);
                htmls.push(this.renderHeadDateCellHtml(date));
            }
            return htmls.join("");
        },
        renderHeadDateCellHtml: function(date, colspan, otherAttrs) {
            var view = this.view;
            return "" + '<th class="fc-day-header ' + view.widgetHeaderClass + " fc-" + dayIDs[date.day()] + '"' + (this.rowCnt === 1 ? ' data-date="' + date.format("YYYY-MM-DD") + '"' : "") + (colspan > 1 ? ' colspan="' + colspan + '"' : "") + (otherAttrs ? " " + otherAttrs : "") + ">" + view.buildGotoAnchorHtml({
                date: date,
                forceOff: this.rowCnt > 1 || this.colCnt === 1
            }, htmlEscape(date.format(this.colHeadFormat))) + "</th>";
        },
        renderBgTrHtml: function(row) {
            return "" + "<tr>" + (this.isRTL ? "" : this.renderBgIntroHtml(row)) + this.renderBgCellsHtml(row) + (this.isRTL ? this.renderBgIntroHtml(row) : "") + "</tr>";
        },
        renderBgIntroHtml: function(row) {
            return this.renderIntroHtml();
        },
        renderBgCellsHtml: function(row) {
            var htmls = [];
            var col, date;
            for (col = 0; col < this.colCnt; col++) {
                date = this.getCellDate(row, col);
                htmls.push(this.renderBgCellHtml(date));
            }
            return htmls.join("");
        },
        renderBgCellHtml: function(date, otherAttrs) {
            var view = this.view;
            var classes = this.getDayClasses(date);
            classes.unshift("fc-day", view.widgetContentClass);
            return '<td class="' + classes.join(" ") + '"' + ' data-date="' + date.format("YYYY-MM-DD") + '"' + (otherAttrs ? " " + otherAttrs : "") + "></td>";
        },
        renderIntroHtml: function() {},
        bookendCells: function(trEl) {
            var introHtml = this.renderIntroHtml();
            if (introHtml) {
                if (this.isRTL) {
                    trEl.append(introHtml);
                } else {
                    trEl.prepend(introHtml);
                }
            }
        }
    };
    var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {
        numbersVisible: false,
        bottomCoordPadding: 0,
        rowEls: null,
        cellEls: null,
        helperEls: null,
        rowCoordCache: null,
        colCoordCache: null,
        renderDates: function(isRigid) {
            var view = this.view;
            var rowCnt = this.rowCnt;
            var colCnt = this.colCnt;
            var html = "";
            var row;
            var col;
            for (row = 0; row < rowCnt; row++) {
                html += this.renderDayRowHtml(row, isRigid);
            }
            this.el.html(html);
            this.rowEls = this.el.find(".fc-row");
            this.cellEls = this.el.find(".fc-day");
            this.rowCoordCache = new CoordCache({
                els: this.rowEls,
                isVertical: true
            });
            this.colCoordCache = new CoordCache({
                els: this.cellEls.slice(0, this.colCnt),
                isHorizontal: true
            });
            for (row = 0; row < rowCnt; row++) {
                for (col = 0; col < colCnt; col++) {
                    view.trigger("dayRender", null, this.getCellDate(row, col), this.getCellEl(row, col));
                }
            }
        },
        unrenderDates: function() {
            this.removeSegPopover();
        },
        renderBusinessHours: function() {
            var segs = this.buildBusinessHourSegs(true);
            this.renderFill("businessHours", segs, "bgevent");
        },
        unrenderBusinessHours: function() {
            this.unrenderFill("businessHours");
        },
        renderDayRowHtml: function(row, isRigid) {
            var view = this.view;
            var classes = [ "fc-row", "fc-week", view.widgetContentClass ];
            if (isRigid) {
                classes.push("fc-rigid");
            }
            return "" + '<div class="' + classes.join(" ") + '">' + '<div class="fc-bg">' + "<table>" + this.renderBgTrHtml(row) + "</table>" + "</div>" + '<div class="fc-content-skeleton">' + "<table>" + (this.numbersVisible ? "<thead>" + this.renderNumberTrHtml(row) + "</thead>" : "") + "</table>" + "</div>" + "</div>";
        },
        renderNumberTrHtml: function(row) {
            return "" + "<tr>" + (this.isRTL ? "" : this.renderNumberIntroHtml(row)) + this.renderNumberCellsHtml(row) + (this.isRTL ? this.renderNumberIntroHtml(row) : "") + "</tr>";
        },
        renderNumberIntroHtml: function(row) {
            return this.renderIntroHtml();
        },
        renderNumberCellsHtml: function(row) {
            var htmls = [];
            var col, date;
            for (col = 0; col < this.colCnt; col++) {
                date = this.getCellDate(row, col);
                htmls.push(this.renderNumberCellHtml(date));
            }
            return htmls.join("");
        },
        renderNumberCellHtml: function(date) {
            var html = "";
            var classes;
            var weekCalcFirstDoW;
            if (!this.view.dayNumbersVisible && !this.view.cellWeekNumbersVisible) {
                return "<td/>";
            }
            classes = this.getDayClasses(date);
            classes.unshift("fc-day-top");
            if (this.view.cellWeekNumbersVisible) {
                if (date._locale._fullCalendar_weekCalc === "ISO") {
                    weekCalcFirstDoW = 1;
                } else {
                    weekCalcFirstDoW = date._locale.firstDayOfWeek();
                }
            }
            html += '<td class="' + classes.join(" ") + '" data-date="' + date.format() + '">';
            if (this.view.cellWeekNumbersVisible && date.day() == weekCalcFirstDoW) {
                html += this.view.buildGotoAnchorHtml({
                    date: date,
                    type: "week"
                }, {
                    class: "fc-week-number"
                }, date.format("w"));
            }
            if (this.view.dayNumbersVisible) {
                html += this.view.buildGotoAnchorHtml(date, {
                    class: "fc-day-number"
                }, date.date());
            }
            html += "</td>";
            return html;
        },
        computeEventTimeFormat: function() {
            return this.view.opt("extraSmallTimeFormat");
        },
        computeDisplayEventEnd: function() {
            return this.colCnt == 1;
        },
        rangeUpdated: function() {
            this.updateDayTable();
        },
        spanToSegs: function(span) {
            var segs = this.sliceRangeByRow(span);
            var i, seg;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                if (this.isRTL) {
                    seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
                    seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
                } else {
                    seg.leftCol = seg.firstRowDayIndex;
                    seg.rightCol = seg.lastRowDayIndex;
                }
            }
            return segs;
        },
        prepareHits: function() {
            this.colCoordCache.build();
            this.rowCoordCache.build();
            this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding;
        },
        releaseHits: function() {
            this.colCoordCache.clear();
            this.rowCoordCache.clear();
        },
        queryHit: function(leftOffset, topOffset) {
            if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
                var col = this.colCoordCache.getHorizontalIndex(leftOffset);
                var row = this.rowCoordCache.getVerticalIndex(topOffset);
                if (row != null && col != null) {
                    return this.getCellHit(row, col);
                }
            }
        },
        getHitSpan: function(hit) {
            return this.getCellRange(hit.row, hit.col);
        },
        getHitEl: function(hit) {
            return this.getCellEl(hit.row, hit.col);
        },
        getCellHit: function(row, col) {
            return {
                row: row,
                col: col,
                component: this,
                left: this.colCoordCache.getLeftOffset(col),
                right: this.colCoordCache.getRightOffset(col),
                top: this.rowCoordCache.getTopOffset(row),
                bottom: this.rowCoordCache.getBottomOffset(row)
            };
        },
        getCellEl: function(row, col) {
            return this.cellEls.eq(row * this.colCnt + col);
        },
        renderDrag: function(eventLocation, seg) {
            this.renderHighlight(this.eventToSpan(eventLocation));
            if (seg && seg.component !== this) {
                return this.renderEventLocationHelper(eventLocation, seg);
            }
        },
        unrenderDrag: function() {
            this.unrenderHighlight();
            this.unrenderHelper();
        },
        renderEventResize: function(eventLocation, seg) {
            this.renderHighlight(this.eventToSpan(eventLocation));
            return this.renderEventLocationHelper(eventLocation, seg);
        },
        unrenderEventResize: function() {
            this.unrenderHighlight();
            this.unrenderHelper();
        },
        renderHelper: function(event, sourceSeg) {
            var helperNodes = [];
            var segs = this.eventToSegs(event);
            var rowStructs;
            segs = this.renderFgSegEls(segs);
            rowStructs = this.renderSegRows(segs);
            this.rowEls.each(function(row, rowNode) {
                var rowEl = $(rowNode);
                var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>');
                var skeletonTop;
                if (sourceSeg && sourceSeg.row === row) {
                    skeletonTop = sourceSeg.el.position().top;
                } else {
                    skeletonTop = rowEl.find(".fc-content-skeleton tbody").position().top;
                }
                skeletonEl.css("top", skeletonTop).find("table").append(rowStructs[row].tbodyEl);
                rowEl.append(skeletonEl);
                helperNodes.push(skeletonEl[0]);
            });
            return this.helperEls = $(helperNodes);
        },
        unrenderHelper: function() {
            if (this.helperEls) {
                this.helperEls.remove();
                this.helperEls = null;
            }
        },
        fillSegTag: "td",
        renderFill: function(type, segs, className) {
            var nodes = [];
            var i, seg;
            var skeletonEl;
            segs = this.renderFillSegEls(type, segs);
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                skeletonEl = this.renderFillRow(type, seg, className);
                this.rowEls.eq(seg.row).append(skeletonEl);
                nodes.push(skeletonEl[0]);
            }
            this.elsByFill[type] = $(nodes);
            return segs;
        },
        renderFillRow: function(type, seg, className) {
            var colCnt = this.colCnt;
            var startCol = seg.leftCol;
            var endCol = seg.rightCol + 1;
            var skeletonEl;
            var trEl;
            className = className || type.toLowerCase();
            skeletonEl = $('<div class="fc-' + className + '-skeleton">' + "<table><tr/></table>" + "</div>");
            trEl = skeletonEl.find("tr");
            if (startCol > 0) {
                trEl.append('<td colspan="' + startCol + '"/>');
            }
            trEl.append(seg.el.attr("colspan", endCol - startCol));
            if (endCol < colCnt) {
                trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
            }
            this.bookendCells(trEl);
            return skeletonEl;
        }
    });
    DayGrid.mixin({
        rowStructs: null,
        unrenderEvents: function() {
            this.removeSegPopover();
            Grid.prototype.unrenderEvents.apply(this, arguments);
        },
        getEventSegs: function() {
            return Grid.prototype.getEventSegs.call(this).concat(this.popoverSegs || []);
        },
        renderBgSegs: function(segs) {
            var allDaySegs = $.grep(segs, function(seg) {
                return seg.event.allDay;
            });
            return Grid.prototype.renderBgSegs.call(this, allDaySegs);
        },
        renderFgSegs: function(segs) {
            var rowStructs;
            segs = this.renderFgSegEls(segs);
            rowStructs = this.rowStructs = this.renderSegRows(segs);
            this.rowEls.each(function(i, rowNode) {
                $(rowNode).find(".fc-content-skeleton > table").append(rowStructs[i].tbodyEl);
            });
            return segs;
        },
        unrenderFgSegs: function() {
            var rowStructs = this.rowStructs || [];
            var rowStruct;
            while (rowStruct = rowStructs.pop()) {
                rowStruct.tbodyEl.remove();
            }
            this.rowStructs = null;
        },
        renderSegRows: function(segs) {
            var rowStructs = [];
            var segRows;
            var row;
            segRows = this.groupSegRows(segs);
            for (row = 0; row < segRows.length; row++) {
                rowStructs.push(this.renderSegRow(row, segRows[row]));
            }
            return rowStructs;
        },
        fgSegHtml: function(seg, disableResizing) {
            var view = this.view;
            var event = seg.event;
            var isDraggable = view.isEventDraggable(event);
            var isResizableFromStart = !disableResizing && event.allDay && seg.isStart && view.isEventResizableFromStart(event);
            var isResizableFromEnd = !disableResizing && event.allDay && seg.isEnd && view.isEventResizableFromEnd(event);
            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
            var skinCss = cssToStr(this.getSegSkinCss(seg));
            var timeHtml = "";
            var timeText;
            var titleHtml;
            classes.unshift("fc-day-grid-event", "fc-h-event");
            if (seg.isStart) {
                timeText = this.getEventTimeText(event);
                if (timeText) {
                    timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + "</span>";
                }
            }
            titleHtml = '<span class="fc-title">' + (htmlEscape(event.title || "") || "&nbsp;") + "</span>";
            return '<a class="' + classes.join(" ") + '"' + (event.url ? ' href="' + htmlEscape(event.url) + '"' : "") + (skinCss ? ' style="' + skinCss + '"' : "") + ">" + '<div class="fc-content">' + (this.isRTL ? titleHtml + " " + timeHtml : timeHtml + " " + titleHtml) + "</div>" + (isResizableFromStart ? '<div class="fc-resizer fc-start-resizer" />' : "") + (isResizableFromEnd ? '<div class="fc-resizer fc-end-resizer" />' : "") + "</a>";
        },
        renderSegRow: function(row, rowSegs) {
            var colCnt = this.colCnt;
            var segLevels = this.buildSegLevels(rowSegs);
            var levelCnt = Math.max(1, segLevels.length);
            var tbody = $("<tbody/>");
            var segMatrix = [];
            var cellMatrix = [];
            var loneCellMatrix = [];
            var i, levelSegs;
            var col;
            var tr;
            var j, seg;
            var td;
            function emptyCellsUntil(endCol) {
                while (col < endCol) {
                    td = (loneCellMatrix[i - 1] || [])[col];
                    if (td) {
                        td.attr("rowspan", parseInt(td.attr("rowspan") || 1, 10) + 1);
                    } else {
                        td = $("<td/>");
                        tr.append(td);
                    }
                    cellMatrix[i][col] = td;
                    loneCellMatrix[i][col] = td;
                    col++;
                }
            }
            for (i = 0; i < levelCnt; i++) {
                levelSegs = segLevels[i];
                col = 0;
                tr = $("<tr/>");
                segMatrix.push([]);
                cellMatrix.push([]);
                loneCellMatrix.push([]);
                if (levelSegs) {
                    for (j = 0; j < levelSegs.length; j++) {
                        seg = levelSegs[j];
                        emptyCellsUntil(seg.leftCol);
                        td = $('<td class="fc-event-container"/>').append(seg.el);
                        if (seg.leftCol != seg.rightCol) {
                            td.attr("colspan", seg.rightCol - seg.leftCol + 1);
                        } else {
                            loneCellMatrix[i][col] = td;
                        }
                        while (col <= seg.rightCol) {
                            cellMatrix[i][col] = td;
                            segMatrix[i][col] = seg;
                            col++;
                        }
                        tr.append(td);
                    }
                }
                emptyCellsUntil(colCnt);
                this.bookendCells(tr);
                tbody.append(tr);
            }
            return {
                row: row,
                tbodyEl: tbody,
                cellMatrix: cellMatrix,
                segMatrix: segMatrix,
                segLevels: segLevels,
                segs: rowSegs
            };
        },
        buildSegLevels: function(segs) {
            var levels = [];
            var i, seg;
            var j;
            this.sortEventSegs(segs);
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                for (j = 0; j < levels.length; j++) {
                    if (!isDaySegCollision(seg, levels[j])) {
                        break;
                    }
                }
                seg.level = j;
                (levels[j] || (levels[j] = [])).push(seg);
            }
            for (j = 0; j < levels.length; j++) {
                levels[j].sort(compareDaySegCols);
            }
            return levels;
        },
        groupSegRows: function(segs) {
            var segRows = [];
            var i;
            for (i = 0; i < this.rowCnt; i++) {
                segRows.push([]);
            }
            for (i = 0; i < segs.length; i++) {
                segRows[segs[i].row].push(segs[i]);
            }
            return segRows;
        }
    });
    function isDaySegCollision(seg, otherSegs) {
        var i, otherSeg;
        for (i = 0; i < otherSegs.length; i++) {
            otherSeg = otherSegs[i];
            if (otherSeg.leftCol <= seg.rightCol && otherSeg.rightCol >= seg.leftCol) {
                return true;
            }
        }
        return false;
    }
    function compareDaySegCols(a, b) {
        return a.leftCol - b.leftCol;
    }
    DayGrid.mixin({
        segPopover: null,
        popoverSegs: null,
        removeSegPopover: function() {
            if (this.segPopover) {
                this.segPopover.hide();
            }
        },
        limitRows: function(levelLimit) {
            var rowStructs = this.rowStructs || [];
            var row;
            var rowLevelLimit;
            for (row = 0; row < rowStructs.length; row++) {
                this.unlimitRow(row);
                if (!levelLimit) {
                    rowLevelLimit = false;
                } else if (typeof levelLimit === "number") {
                    rowLevelLimit = levelLimit;
                } else {
                    rowLevelLimit = this.computeRowLevelLimit(row);
                }
                if (rowLevelLimit !== false) {
                    this.limitRow(row, rowLevelLimit);
                }
            }
        },
        computeRowLevelLimit: function(row) {
            var rowEl = this.rowEls.eq(row);
            var rowHeight = rowEl.height();
            var trEls = this.rowStructs[row].tbodyEl.children();
            var i, trEl;
            var trHeight;
            function iterInnerHeights(i, childNode) {
                trHeight = Math.max(trHeight, $(childNode).outerHeight());
            }
            for (i = 0; i < trEls.length; i++) {
                trEl = trEls.eq(i).removeClass("fc-limited");
                trHeight = 0;
                trEl.find("> td > :first-child").each(iterInnerHeights);
                if (trEl.position().top + trHeight > rowHeight) {
                    return i;
                }
            }
            return false;
        },
        limitRow: function(row, levelLimit) {
            var _this = this;
            var rowStruct = this.rowStructs[row];
            var moreNodes = [];
            var col = 0;
            var levelSegs;
            var cellMatrix;
            var limitedNodes;
            var i, seg;
            var segsBelow;
            var totalSegsBelow;
            var colSegsBelow;
            var td, rowspan;
            var segMoreNodes;
            var j;
            var moreTd, moreWrap, moreLink;
            function emptyCellsUntil(endCol) {
                while (col < endCol) {
                    segsBelow = _this.getCellSegs(row, col, levelLimit);
                    if (segsBelow.length) {
                        td = cellMatrix[levelLimit - 1][col];
                        moreLink = _this.renderMoreLink(row, col, segsBelow);
                        moreWrap = $("<div/>").append(moreLink);
                        td.append(moreWrap);
                        moreNodes.push(moreWrap[0]);
                    }
                    col++;
                }
            }
            if (levelLimit && levelLimit < rowStruct.segLevels.length) {
                levelSegs = rowStruct.segLevels[levelLimit - 1];
                cellMatrix = rowStruct.cellMatrix;
                limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit).addClass("fc-limited").get();
                for (i = 0; i < levelSegs.length; i++) {
                    seg = levelSegs[i];
                    emptyCellsUntil(seg.leftCol);
                    colSegsBelow = [];
                    totalSegsBelow = 0;
                    while (col <= seg.rightCol) {
                        segsBelow = this.getCellSegs(row, col, levelLimit);
                        colSegsBelow.push(segsBelow);
                        totalSegsBelow += segsBelow.length;
                        col++;
                    }
                    if (totalSegsBelow) {
                        td = cellMatrix[levelLimit - 1][seg.leftCol];
                        rowspan = td.attr("rowspan") || 1;
                        segMoreNodes = [];
                        for (j = 0; j < colSegsBelow.length; j++) {
                            moreTd = $('<td class="fc-more-cell"/>').attr("rowspan", rowspan);
                            segsBelow = colSegsBelow[j];
                            moreLink = this.renderMoreLink(row, seg.leftCol + j, [ seg ].concat(segsBelow));
                            moreWrap = $("<div/>").append(moreLink);
                            moreTd.append(moreWrap);
                            segMoreNodes.push(moreTd[0]);
                            moreNodes.push(moreTd[0]);
                        }
                        td.addClass("fc-limited").after($(segMoreNodes));
                        limitedNodes.push(td[0]);
                    }
                }
                emptyCellsUntil(this.colCnt);
                rowStruct.moreEls = $(moreNodes);
                rowStruct.limitedEls = $(limitedNodes);
            }
        },
        unlimitRow: function(row) {
            var rowStruct = this.rowStructs[row];
            if (rowStruct.moreEls) {
                rowStruct.moreEls.remove();
                rowStruct.moreEls = null;
            }
            if (rowStruct.limitedEls) {
                rowStruct.limitedEls.removeClass("fc-limited");
                rowStruct.limitedEls = null;
            }
        },
        renderMoreLink: function(row, col, hiddenSegs) {
            var _this = this;
            var view = this.view;
            return $('<a class="fc-more"/>').text(this.getMoreLinkText(hiddenSegs.length)).on("click", function(ev) {
                var clickOption = view.opt("eventLimitClick");
                var date = _this.getCellDate(row, col);
                var moreEl = $(this);
                var dayEl = _this.getCellEl(row, col);
                var allSegs = _this.getCellSegs(row, col);
                var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
                var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
                if (typeof clickOption === "function") {
                    clickOption = view.trigger("eventLimitClick", null, {
                        date: date,
                        dayEl: dayEl,
                        moreEl: moreEl,
                        segs: reslicedAllSegs,
                        hiddenSegs: reslicedHiddenSegs
                    }, ev);
                }
                if (clickOption === "popover") {
                    _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
                } else if (typeof clickOption === "string") {
                    view.calendar.zoomTo(date, clickOption);
                }
            });
        },
        showSegPopover: function(row, col, moreLink, segs) {
            var _this = this;
            var view = this.view;
            var moreWrap = moreLink.parent();
            var topEl;
            var options;
            if (this.rowCnt == 1) {
                topEl = view.el;
            } else {
                topEl = this.rowEls.eq(row);
            }
            options = {
                className: "fc-more-popover",
                content: this.renderSegPopoverContent(row, col, segs),
                parentEl: this.view.el,
                top: topEl.offset().top,
                autoHide: true,
                viewportConstrain: view.opt("popoverViewportConstrain"),
                hide: function() {
                    _this.segPopover.removeElement();
                    _this.segPopover = null;
                    _this.popoverSegs = null;
                }
            };
            if (this.isRTL) {
                options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1;
            } else {
                options.left = moreWrap.offset().left - 1;
            }
            this.segPopover = new Popover(options);
            this.segPopover.show();
            this.bindSegHandlersToEl(this.segPopover.el);
        },
        renderSegPopoverContent: function(row, col, segs) {
            var view = this.view;
            var isTheme = view.opt("theme");
            var title = this.getCellDate(row, col).format(view.opt("dayPopoverFormat"));
            var content = $('<div class="fc-header ' + view.widgetHeaderClass + '">' + '<span class="fc-close ' + (isTheme ? "ui-icon ui-icon-closethick" : "fc-icon fc-icon-x") + '"></span>' + '<span class="fc-title">' + htmlEscape(title) + "</span>" + '<div class="fc-clear"/>' + "</div>" + '<div class="fc-body ' + view.widgetContentClass + '">' + '<div class="fc-event-container"></div>' + "</div>");
            var segContainer = content.find(".fc-event-container");
            var i;
            segs = this.renderFgSegEls(segs, true);
            this.popoverSegs = segs;
            for (i = 0; i < segs.length; i++) {
                this.prepareHits();
                segs[i].hit = this.getCellHit(row, col);
                this.releaseHits();
                segContainer.append(segs[i].el);
            }
            return content;
        },
        resliceDaySegs: function(segs, dayDate) {
            var events = $.map(segs, function(seg) {
                return seg.event;
            });
            var dayStart = dayDate.clone();
            var dayEnd = dayStart.clone().add(1, "days");
            var dayRange = {
                start: dayStart,
                end: dayEnd
            };
            segs = this.eventsToSegs(events, function(range) {
                var seg = intersectRanges(range, dayRange);
                return seg ? [ seg ] : [];
            });
            this.sortEventSegs(segs);
            return segs;
        },
        getMoreLinkText: function(num) {
            var opt = this.view.opt("eventLimitText");
            if (typeof opt === "function") {
                return opt(num);
            } else {
                return "+" + num + " " + opt;
            }
        },
        getCellSegs: function(row, col, startLevel) {
            var segMatrix = this.rowStructs[row].segMatrix;
            var level = startLevel || 0;
            var segs = [];
            var seg;
            while (level < segMatrix.length) {
                seg = segMatrix[level][col];
                if (seg) {
                    segs.push(seg);
                }
                level++;
            }
            return segs;
        }
    });
    var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {
        slotDuration: null,
        snapDuration: null,
        snapsPerSlot: null,
        minTime: null,
        maxTime: null,
        labelFormat: null,
        labelInterval: null,
        colEls: null,
        slatContainerEl: null,
        slatEls: null,
        nowIndicatorEls: null,
        colCoordCache: null,
        slatCoordCache: null,
        constructor: function() {
            Grid.apply(this, arguments);
            this.processOptions();
        },
        renderDates: function() {
            this.el.html(this.renderHtml());
            this.colEls = this.el.find(".fc-day");
            this.slatContainerEl = this.el.find(".fc-slats");
            this.slatEls = this.slatContainerEl.find("tr");
            this.colCoordCache = new CoordCache({
                els: this.colEls,
                isHorizontal: true
            });
            this.slatCoordCache = new CoordCache({
                els: this.slatEls,
                isVertical: true
            });
            this.renderContentSkeleton();
        },
        renderHtml: function() {
            return "" + '<div class="fc-bg">' + "<table>" + this.renderBgTrHtml(0) + "</table>" + "</div>" + '<div class="fc-slats">' + "<table>" + this.renderSlatRowHtml() + "</table>" + "</div>";
        },
        renderSlatRowHtml: function() {
            var view = this.view;
            var isRTL = this.isRTL;
            var html = "";
            var slotTime = moment.duration(+this.minTime);
            var slotDate;
            var isLabeled;
            var axisHtml;
            while (slotTime < this.maxTime) {
                slotDate = this.start.clone().time(slotTime);
                isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));
                axisHtml = '<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + ">" + (isLabeled ? "<span>" + htmlEscape(slotDate.format(this.labelFormat)) + "</span>" : "") + "</td>";
                html += '<tr data-time="' + slotDate.format("HH:mm:ss") + '"' + (isLabeled ? "" : ' class="fc-minor"') + ">" + (!isRTL ? axisHtml : "") + '<td class="' + view.widgetContentClass + '"/>' + (isRTL ? axisHtml : "") + "</tr>";
                slotTime.add(this.slotDuration);
            }
            return html;
        },
        processOptions: function() {
            var view = this.view;
            var slotDuration = view.opt("slotDuration");
            var snapDuration = view.opt("snapDuration");
            var input;
            slotDuration = moment.duration(slotDuration);
            snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
            this.slotDuration = slotDuration;
            this.snapDuration = snapDuration;
            this.snapsPerSlot = slotDuration / snapDuration;
            this.minResizeDuration = snapDuration;
            this.minTime = moment.duration(view.opt("minTime"));
            this.maxTime = moment.duration(view.opt("maxTime"));
            input = view.opt("slotLabelFormat");
            if ($.isArray(input)) {
                input = input[input.length - 1];
            }
            this.labelFormat = input || view.opt("smallTimeFormat");
            input = view.opt("slotLabelInterval");
            this.labelInterval = input ? moment.duration(input) : this.computeLabelInterval(slotDuration);
        },
        computeLabelInterval: function(slotDuration) {
            var i;
            var labelInterval;
            var slotsPerLabel;
            for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
                labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
                slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
                if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
                    return labelInterval;
                }
            }
            return moment.duration(slotDuration);
        },
        computeEventTimeFormat: function() {
            return this.view.opt("noMeridiemTimeFormat");
        },
        computeDisplayEventEnd: function() {
            return true;
        },
        prepareHits: function() {
            this.colCoordCache.build();
            this.slatCoordCache.build();
        },
        releaseHits: function() {
            this.colCoordCache.clear();
        },
        queryHit: function(leftOffset, topOffset) {
            var snapsPerSlot = this.snapsPerSlot;
            var colCoordCache = this.colCoordCache;
            var slatCoordCache = this.slatCoordCache;
            if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
                var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
                var slatIndex = slatCoordCache.getVerticalIndex(topOffset);
                if (colIndex != null && slatIndex != null) {
                    var slatTop = slatCoordCache.getTopOffset(slatIndex);
                    var slatHeight = slatCoordCache.getHeight(slatIndex);
                    var partial = (topOffset - slatTop) / slatHeight;
                    var localSnapIndex = Math.floor(partial * snapsPerSlot);
                    var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
                    var snapTop = slatTop + localSnapIndex / snapsPerSlot * slatHeight;
                    var snapBottom = slatTop + (localSnapIndex + 1) / snapsPerSlot * slatHeight;
                    return {
                        col: colIndex,
                        snap: snapIndex,
                        component: this,
                        left: colCoordCache.getLeftOffset(colIndex),
                        right: colCoordCache.getRightOffset(colIndex),
                        top: snapTop,
                        bottom: snapBottom
                    };
                }
            }
        },
        getHitSpan: function(hit) {
            var start = this.getCellDate(0, hit.col);
            var time = this.computeSnapTime(hit.snap);
            var end;
            start.time(time);
            end = start.clone().add(this.snapDuration);
            return {
                start: start,
                end: end
            };
        },
        getHitEl: function(hit) {
            return this.colEls.eq(hit.col);
        },
        rangeUpdated: function() {
            this.updateDayTable();
        },
        computeSnapTime: function(snapIndex) {
            return moment.duration(this.minTime + this.snapDuration * snapIndex);
        },
        spanToSegs: function(span) {
            var segs = this.sliceRangeByTimes(span);
            var i;
            for (i = 0; i < segs.length; i++) {
                if (this.isRTL) {
                    segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
                } else {
                    segs[i].col = segs[i].dayIndex;
                }
            }
            return segs;
        },
        sliceRangeByTimes: function(range) {
            var segs = [];
            var seg;
            var dayIndex;
            var dayDate;
            var dayRange;
            for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
                dayDate = this.dayDates[dayIndex].clone();
                dayRange = {
                    start: dayDate.clone().time(this.minTime),
                    end: dayDate.clone().time(this.maxTime)
                };
                seg = intersectRanges(range, dayRange);
                if (seg) {
                    seg.dayIndex = dayIndex;
                    segs.push(seg);
                }
            }
            return segs;
        },
        updateSize: function(isResize) {
            this.slatCoordCache.build();
            if (isResize) {
                this.updateSegVerticals([].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || []));
            }
        },
        getTotalSlatHeight: function() {
            return this.slatContainerEl.outerHeight();
        },
        computeDateTop: function(date, startOfDayDate) {
            return this.computeTimeTop(moment.duration(date - startOfDayDate.clone().stripTime()));
        },
        computeTimeTop: function(time) {
            var len = this.slatEls.length;
            var slatCoverage = (time - this.minTime) / this.slotDuration;
            var slatIndex;
            var slatRemainder;
            slatCoverage = Math.max(0, slatCoverage);
            slatCoverage = Math.min(len, slatCoverage);
            slatIndex = Math.floor(slatCoverage);
            slatIndex = Math.min(slatIndex, len - 1);
            slatRemainder = slatCoverage - slatIndex;
            return this.slatCoordCache.getTopPosition(slatIndex) + this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
        },
        renderDrag: function(eventLocation, seg) {
            if (seg) {
                return this.renderEventLocationHelper(eventLocation, seg);
            } else {
                this.renderHighlight(this.eventToSpan(eventLocation));
            }
        },
        unrenderDrag: function() {
            this.unrenderHelper();
            this.unrenderHighlight();
        },
        renderEventResize: function(eventLocation, seg) {
            return this.renderEventLocationHelper(eventLocation, seg);
        },
        unrenderEventResize: function() {
            this.unrenderHelper();
        },
        renderHelper: function(event, sourceSeg) {
            return this.renderHelperSegs(this.eventToSegs(event), sourceSeg);
        },
        unrenderHelper: function() {
            this.unrenderHelperSegs();
        },
        renderBusinessHours: function() {
            this.renderBusinessSegs(this.buildBusinessHourSegs());
        },
        unrenderBusinessHours: function() {
            this.unrenderBusinessSegs();
        },
        getNowIndicatorUnit: function() {
            return "minute";
        },
        renderNowIndicator: function(date) {
            var segs = this.spanToSegs({
                start: date,
                end: date
            });
            var top = this.computeDateTop(date, date);
            var nodes = [];
            var i;
            for (i = 0; i < segs.length; i++) {
                nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>').css("top", top).appendTo(this.colContainerEls.eq(segs[i].col))[0]);
            }
            if (segs.length > 0) {
                nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>').css("top", top).appendTo(this.el.find(".fc-content-skeleton"))[0]);
            }
            this.nowIndicatorEls = $(nodes);
        },
        unrenderNowIndicator: function() {
            if (this.nowIndicatorEls) {
                this.nowIndicatorEls.remove();
                this.nowIndicatorEls = null;
            }
        },
        renderSelection: function(span) {
            if (this.view.opt("selectHelper")) {
                this.renderEventLocationHelper(span);
            } else {
                this.renderHighlight(span);
            }
        },
        unrenderSelection: function() {
            this.unrenderHelper();
            this.unrenderHighlight();
        },
        renderHighlight: function(span) {
            this.renderHighlightSegs(this.spanToSegs(span));
        },
        unrenderHighlight: function() {
            this.unrenderHighlightSegs();
        }
    });
    TimeGrid.mixin({
        colContainerEls: null,
        fgContainerEls: null,
        bgContainerEls: null,
        helperContainerEls: null,
        highlightContainerEls: null,
        businessContainerEls: null,
        fgSegs: null,
        bgSegs: null,
        helperSegs: null,
        highlightSegs: null,
        businessSegs: null,
        renderContentSkeleton: function() {
            var cellHtml = "";
            var i;
            var skeletonEl;
            for (i = 0; i < this.colCnt; i++) {
                cellHtml += "<td>" + '<div class="fc-content-col">' + '<div class="fc-event-container fc-helper-container"></div>' + '<div class="fc-event-container"></div>' + '<div class="fc-highlight-container"></div>' + '<div class="fc-bgevent-container"></div>' + '<div class="fc-business-container"></div>' + "</div>" + "</td>";
            }
            skeletonEl = $('<div class="fc-content-skeleton">' + "<table>" + "<tr>" + cellHtml + "</tr>" + "</table>" + "</div>");
            this.colContainerEls = skeletonEl.find(".fc-content-col");
            this.helperContainerEls = skeletonEl.find(".fc-helper-container");
            this.fgContainerEls = skeletonEl.find(".fc-event-container:not(.fc-helper-container)");
            this.bgContainerEls = skeletonEl.find(".fc-bgevent-container");
            this.highlightContainerEls = skeletonEl.find(".fc-highlight-container");
            this.businessContainerEls = skeletonEl.find(".fc-business-container");
            this.bookendCells(skeletonEl.find("tr"));
            this.el.append(skeletonEl);
        },
        renderFgSegs: function(segs) {
            segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);
            this.fgSegs = segs;
            return segs;
        },
        unrenderFgSegs: function() {
            this.unrenderNamedSegs("fgSegs");
        },
        renderHelperSegs: function(segs, sourceSeg) {
            var helperEls = [];
            var i, seg;
            var sourceEl;
            segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                if (sourceSeg && sourceSeg.col === seg.col) {
                    sourceEl = sourceSeg.el;
                    seg.el.css({
                        left: sourceEl.css("left"),
                        right: sourceEl.css("right"),
                        "margin-left": sourceEl.css("margin-left"),
                        "margin-right": sourceEl.css("margin-right")
                    });
                }
                helperEls.push(seg.el[0]);
            }
            this.helperSegs = segs;
            return $(helperEls);
        },
        unrenderHelperSegs: function() {
            this.unrenderNamedSegs("helperSegs");
        },
        renderBgSegs: function(segs) {
            segs = this.renderFillSegEls("bgEvent", segs);
            this.updateSegVerticals(segs);
            this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);
            this.bgSegs = segs;
            return segs;
        },
        unrenderBgSegs: function() {
            this.unrenderNamedSegs("bgSegs");
        },
        renderHighlightSegs: function(segs) {
            segs = this.renderFillSegEls("highlight", segs);
            this.updateSegVerticals(segs);
            this.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);
            this.highlightSegs = segs;
        },
        unrenderHighlightSegs: function() {
            this.unrenderNamedSegs("highlightSegs");
        },
        renderBusinessSegs: function(segs) {
            segs = this.renderFillSegEls("businessHours", segs);
            this.updateSegVerticals(segs);
            this.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);
            this.businessSegs = segs;
        },
        unrenderBusinessSegs: function() {
            this.unrenderNamedSegs("businessSegs");
        },
        groupSegsByCol: function(segs) {
            var segsByCol = [];
            var i;
            for (i = 0; i < this.colCnt; i++) {
                segsByCol.push([]);
            }
            for (i = 0; i < segs.length; i++) {
                segsByCol[segs[i].col].push(segs[i]);
            }
            return segsByCol;
        },
        attachSegsByCol: function(segsByCol, containerEls) {
            var col;
            var segs;
            var i;
            for (col = 0; col < this.colCnt; col++) {
                segs = segsByCol[col];
                for (i = 0; i < segs.length; i++) {
                    containerEls.eq(col).append(segs[i].el);
                }
            }
        },
        unrenderNamedSegs: function(propName) {
            var segs = this[propName];
            var i;
            if (segs) {
                for (i = 0; i < segs.length; i++) {
                    segs[i].el.remove();
                }
                this[propName] = null;
            }
        },
        renderFgSegsIntoContainers: function(segs, containerEls) {
            var segsByCol;
            var col;
            segs = this.renderFgSegEls(segs);
            segsByCol = this.groupSegsByCol(segs);
            for (col = 0; col < this.colCnt; col++) {
                this.updateFgSegCoords(segsByCol[col]);
            }
            this.attachSegsByCol(segsByCol, containerEls);
            return segs;
        },
        fgSegHtml: function(seg, disableResizing) {
            var view = this.view;
            var event = seg.event;
            var isDraggable = view.isEventDraggable(event);
            var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
            var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
            var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
            var skinCss = cssToStr(this.getSegSkinCss(seg));
            var timeText;
            var fullTimeText;
            var startTimeText;
            classes.unshift("fc-time-grid-event", "fc-v-event");
            if (view.isMultiDayEvent(event)) {
                if (seg.isStart || seg.isEnd) {
                    timeText = this.getEventTimeText(seg);
                    fullTimeText = this.getEventTimeText(seg, "LT");
                    startTimeText = this.getEventTimeText(seg, null, false);
                }
            } else {
                timeText = this.getEventTimeText(event);
                fullTimeText = this.getEventTimeText(event, "LT");
                startTimeText = this.getEventTimeText(event, null, false);
            }
            return '<a class="' + classes.join(" ") + '"' + (event.url ? ' href="' + htmlEscape(event.url) + '"' : "") + (skinCss ? ' style="' + skinCss + '"' : "") + ">" + '<div class="fc-content">' + (timeText ? '<div class="fc-time"' + ' data-start="' + htmlEscape(startTimeText) + '"' + ' data-full="' + htmlEscape(fullTimeText) + '"' + ">" + "<span>" + htmlEscape(timeText) + "</span>" + "</div>" : "") + (event.title ? '<div class="fc-title">' + htmlEscape(event.title) + "</div>" : "") + "</div>" + '<div class="fc-bg"/>' + (isResizableFromEnd ? '<div class="fc-resizer fc-end-resizer" />' : "") + "</a>";
        },
        updateSegVerticals: function(segs) {
            this.computeSegVerticals(segs);
            this.assignSegVerticals(segs);
        },
        computeSegVerticals: function(segs) {
            var i, seg;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                seg.top = this.computeDateTop(seg.start, seg.start);
                seg.bottom = this.computeDateTop(seg.end, seg.start);
            }
        },
        assignSegVerticals: function(segs) {
            var i, seg;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                seg.el.css(this.generateSegVerticalCss(seg));
            }
        },
        generateSegVerticalCss: function(seg) {
            return {
                top: seg.top,
                bottom: -seg.bottom
            };
        },
        updateFgSegCoords: function(segs) {
            this.computeSegVerticals(segs);
            this.computeFgSegHorizontals(segs);
            this.assignSegVerticals(segs);
            this.assignFgSegHorizontals(segs);
        },
        computeFgSegHorizontals: function(segs) {
            var levels;
            var level0;
            var i;
            this.sortEventSegs(segs);
            levels = buildSlotSegLevels(segs);
            computeForwardSlotSegs(levels);
            if (level0 = levels[0]) {
                for (i = 0; i < level0.length; i++) {
                    computeSlotSegPressures(level0[i]);
                }
                for (i = 0; i < level0.length; i++) {
                    this.computeFgSegForwardBack(level0[i], 0, 0);
                }
            }
        },
        computeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {
            var forwardSegs = seg.forwardSegs;
            var i;
            if (seg.forwardCoord === undefined) {
                if (!forwardSegs.length) {
                    seg.forwardCoord = 1;
                } else {
                    this.sortForwardSegs(forwardSegs);
                    this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                    seg.forwardCoord = forwardSegs[0].backwardCoord;
                }
                seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / (seriesBackwardPressure + 1);
                for (i = 0; i < forwardSegs.length; i++) {
                    this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
                }
            }
        },
        sortForwardSegs: function(forwardSegs) {
            forwardSegs.sort(proxy(this, "compareForwardSegs"));
        },
        compareForwardSegs: function(seg1, seg2) {
            return seg2.forwardPressure - seg1.forwardPressure || (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) || this.compareEventSegs(seg1, seg2);
        },
        assignFgSegHorizontals: function(segs) {
            var i, seg;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                seg.el.css(this.generateFgSegHorizontalCss(seg));
                if (seg.bottom - seg.top < 30) {
                    seg.el.addClass("fc-short");
                }
            }
        },
        generateFgSegHorizontalCss: function(seg) {
            var shouldOverlap = this.view.opt("slotEventOverlap");
            var backwardCoord = seg.backwardCoord;
            var forwardCoord = seg.forwardCoord;
            var props = this.generateSegVerticalCss(seg);
            var left;
            var right;
            if (shouldOverlap) {
                forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
            }
            if (this.isRTL) {
                left = 1 - forwardCoord;
                right = backwardCoord;
            } else {
                left = backwardCoord;
                right = 1 - forwardCoord;
            }
            props.zIndex = seg.level + 1;
            props.left = left * 100 + "%";
            props.right = right * 100 + "%";
            if (shouldOverlap && seg.forwardPressure) {
                props[this.isRTL ? "marginLeft" : "marginRight"] = 10 * 2;
            }
            return props;
        }
    });
    function buildSlotSegLevels(segs) {
        var levels = [];
        var i, seg;
        var j;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            for (j = 0; j < levels.length; j++) {
                if (!computeSlotSegCollisions(seg, levels[j]).length) {
                    break;
                }
            }
            seg.level = j;
            (levels[j] || (levels[j] = [])).push(seg);
        }
        return levels;
    }
    function computeForwardSlotSegs(levels) {
        var i, level;
        var j, seg;
        var k;
        for (i = 0; i < levels.length; i++) {
            level = levels[i];
            for (j = 0; j < level.length; j++) {
                seg = level[j];
                seg.forwardSegs = [];
                for (k = i + 1; k < levels.length; k++) {
                    computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
                }
            }
        }
    }
    function computeSlotSegPressures(seg) {
        var forwardSegs = seg.forwardSegs;
        var forwardPressure = 0;
        var i, forwardSeg;
        if (seg.forwardPressure === undefined) {
            for (i = 0; i < forwardSegs.length; i++) {
                forwardSeg = forwardSegs[i];
                computeSlotSegPressures(forwardSeg);
                forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
            }
            seg.forwardPressure = forwardPressure;
        }
    }
    function computeSlotSegCollisions(seg, otherSegs, results) {
        results = results || [];
        for (var i = 0; i < otherSegs.length; i++) {
            if (isSlotSegCollision(seg, otherSegs[i])) {
                results.push(otherSegs[i]);
            }
        }
        return results;
    }
    function isSlotSegCollision(seg1, seg2) {
        return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
    }
    var View = FC.View = Class.extend(EmitterMixin, ListenerMixin, {
        type: null,
        name: null,
        title: null,
        calendar: null,
        options: null,
        el: null,
        displaying: null,
        isSkeletonRendered: false,
        isEventsRendered: false,
        start: null,
        end: null,
        intervalStart: null,
        intervalEnd: null,
        intervalDuration: null,
        intervalUnit: null,
        isRTL: false,
        isSelected: false,
        selectedEvent: null,
        eventOrderSpecs: null,
        widgetHeaderClass: null,
        widgetContentClass: null,
        highlightStateClass: null,
        nextDayThreshold: null,
        isHiddenDayHash: null,
        isNowIndicatorRendered: null,
        initialNowDate: null,
        initialNowQueriedMs: null,
        nowIndicatorTimeoutID: null,
        nowIndicatorIntervalID: null,
        constructor: function(calendar, type, options, intervalDuration) {
            this.calendar = calendar;
            this.type = this.name = type;
            this.options = options;
            this.intervalDuration = intervalDuration || moment.duration(1, "day");
            this.nextDayThreshold = moment.duration(this.opt("nextDayThreshold"));
            this.initThemingProps();
            this.initHiddenDays();
            this.isRTL = this.opt("isRTL");
            this.eventOrderSpecs = parseFieldSpecs(this.opt("eventOrder"));
            this.initialize();
        },
        initialize: function() {},
        opt: function(name) {
            return this.options[name];
        },
        trigger: function(name, thisObj) {
            var calendar = this.calendar;
            return calendar.trigger.apply(calendar, [ name, thisObj || this ].concat(Array.prototype.slice.call(arguments, 2), [ this ]));
        },
        setDate: function(date) {
            this.setRange(this.computeRange(date));
        },
        setRange: function(range) {
            $.extend(this, range);
            this.updateTitle();
        },
        computeRange: function(date) {
            var intervalUnit = computeIntervalUnit(this.intervalDuration);
            var intervalStart = date.clone().startOf(intervalUnit);
            var intervalEnd = intervalStart.clone().add(this.intervalDuration);
            var start, end;
            if (/year|month|week|day/.test(intervalUnit)) {
                intervalStart.stripTime();
                intervalEnd.stripTime();
            } else {
                if (!intervalStart.hasTime()) {
                    intervalStart = this.calendar.time(0);
                }
                if (!intervalEnd.hasTime()) {
                    intervalEnd = this.calendar.time(0);
                }
            }
            start = intervalStart.clone();
            start = this.skipHiddenDays(start);
            end = intervalEnd.clone();
            end = this.skipHiddenDays(end, -1, true);
            return {
                intervalUnit: intervalUnit,
                intervalStart: intervalStart,
                intervalEnd: intervalEnd,
                start: start,
                end: end
            };
        },
        computePrevDate: function(date) {
            return this.massageCurrentDate(date.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1);
        },
        computeNextDate: function(date) {
            return this.massageCurrentDate(date.clone().startOf(this.intervalUnit).add(this.intervalDuration));
        },
        massageCurrentDate: function(date, direction) {
            if (this.intervalDuration.as("days") <= 1) {
                if (this.isHiddenDay(date)) {
                    date = this.skipHiddenDays(date, direction);
                    date.startOf("day");
                }
            }
            return date;
        },
        updateTitle: function() {
            this.title = this.computeTitle();
        },
        computeTitle: function() {
            return this.formatRange({
                start: this.calendar.applyTimezone(this.intervalStart),
                end: this.calendar.applyTimezone(this.intervalEnd)
            }, this.opt("titleFormat") || this.computeTitleFormat(), this.opt("titleRangeSeparator"));
        },
        computeTitleFormat: function() {
            if (this.intervalUnit == "year") {
                return "YYYY";
            } else if (this.intervalUnit == "month") {
                return this.opt("monthYearFormat");
            } else if (this.intervalDuration.as("days") > 1) {
                return "ll";
            } else {
                return "LL";
            }
        },
        formatRange: function(range, formatStr, separator) {
            var end = range.end;
            if (!end.hasTime()) {
                end = end.clone().subtract(1);
            }
            return formatRange(range.start, end, formatStr, separator, this.opt("isRTL"));
        },
        getAllDayHtml: function() {
            return this.opt("allDayHtml") || htmlEscape(this.opt("allDayText"));
        },
        buildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {
            var date, type, forceOff;
            var finalOptions;
            if ($.isPlainObject(gotoOptions)) {
                date = gotoOptions.date;
                type = gotoOptions.type;
                forceOff = gotoOptions.forceOff;
            } else {
                date = gotoOptions;
            }
            date = FC.moment(date);
            finalOptions = {
                date: date.format("YYYY-MM-DD"),
                type: type || "day"
            };
            if (typeof attrs === "string") {
                innerHtml = attrs;
                attrs = null;
            }
            attrs = attrs ? " " + attrsToStr(attrs) : "";
            innerHtml = innerHtml || "";
            if (!forceOff && this.opt("navLinks")) {
                return "<a" + attrs + ' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' + innerHtml + "</a>";
            } else {
                return "<span" + attrs + ">" + innerHtml + "</span>";
            }
        },
        setElement: function(el) {
            this.el = el;
            this.bindGlobalHandlers();
        },
        removeElement: function() {
            this.clear();
            if (this.isSkeletonRendered) {
                this.unrenderSkeleton();
                this.isSkeletonRendered = false;
            }
            this.unbindGlobalHandlers();
            this.el.remove();
        },
        display: function(date, explicitScrollState) {
            var _this = this;
            var prevScrollState = null;
            if (explicitScrollState != null && this.displaying) {
                prevScrollState = this.queryScroll();
            }
            this.calendar.freezeContentHeight();
            return syncThen(this.clear(), function() {
                return _this.displaying = syncThen(_this.displayView(date), function() {
                    if (explicitScrollState != null) {
                        _this.setScroll(explicitScrollState);
                    } else {
                        _this.forceScroll(_this.computeInitialScroll(prevScrollState));
                    }
                    _this.calendar.unfreezeContentHeight();
                    _this.triggerRender();
                });
            });
        },
        clear: function() {
            var _this = this;
            var displaying = this.displaying;
            if (displaying) {
                return syncThen(displaying, function() {
                    _this.displaying = null;
                    _this.clearEvents();
                    return _this.clearView();
                });
            } else {
                return $.when();
            }
        },
        displayView: function(date) {
            if (!this.isSkeletonRendered) {
                this.renderSkeleton();
                this.isSkeletonRendered = true;
            }
            if (date) {
                this.setDate(date);
            }
            if (this.render) {
                this.render();
            }
            this.renderDates();
            this.updateSize();
            this.renderBusinessHours();
            this.startNowIndicator();
        },
        clearView: function() {
            this.unselect();
            this.stopNowIndicator();
            this.triggerUnrender();
            this.unrenderBusinessHours();
            this.unrenderDates();
            if (this.destroy) {
                this.destroy();
            }
        },
        renderSkeleton: function() {},
        unrenderSkeleton: function() {},
        renderDates: function() {},
        unrenderDates: function() {},
        triggerRender: function() {
            this.trigger("viewRender", this, this, this.el);
        },
        triggerUnrender: function() {
            this.trigger("viewDestroy", this, this, this.el);
        },
        bindGlobalHandlers: function() {
            this.listenTo($(document), "mousedown", this.handleDocumentMousedown);
            this.listenTo($(document), "touchstart", this.processUnselect);
        },
        unbindGlobalHandlers: function() {
            this.stopListeningTo($(document));
        },
        initThemingProps: function() {
            var tm = this.opt("theme") ? "ui" : "fc";
            this.widgetHeaderClass = tm + "-widget-header";
            this.widgetContentClass = tm + "-widget-content";
            this.highlightStateClass = tm + "-state-highlight";
        },
        renderBusinessHours: function() {},
        unrenderBusinessHours: function() {},
        startNowIndicator: function() {
            var _this = this;
            var unit;
            var update;
            var delay;
            if (this.opt("nowIndicator")) {
                unit = this.getNowIndicatorUnit();
                if (unit) {
                    update = proxy(this, "updateNowIndicator");
                    this.initialNowDate = this.calendar.getNow();
                    this.initialNowQueriedMs = +new Date();
                    this.renderNowIndicator(this.initialNowDate);
                    this.isNowIndicatorRendered = true;
                    delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;
                    this.nowIndicatorTimeoutID = setTimeout(function() {
                        _this.nowIndicatorTimeoutID = null;
                        update();
                        delay = +moment.duration(1, unit);
                        delay = Math.max(100, delay);
                        _this.nowIndicatorIntervalID = setInterval(update, delay);
                    }, delay);
                }
            }
        },
        updateNowIndicator: function() {
            if (this.isNowIndicatorRendered) {
                this.unrenderNowIndicator();
                this.renderNowIndicator(this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs));
            }
        },
        stopNowIndicator: function() {
            if (this.isNowIndicatorRendered) {
                if (this.nowIndicatorTimeoutID) {
                    clearTimeout(this.nowIndicatorTimeoutID);
                    this.nowIndicatorTimeoutID = null;
                }
                if (this.nowIndicatorIntervalID) {
                    clearTimeout(this.nowIndicatorIntervalID);
                    this.nowIndicatorIntervalID = null;
                }
                this.unrenderNowIndicator();
                this.isNowIndicatorRendered = false;
            }
        },
        getNowIndicatorUnit: function() {},
        renderNowIndicator: function(date) {},
        unrenderNowIndicator: function() {},
        updateSize: function(isResize) {
            var scrollState;
            if (isResize) {
                scrollState = this.queryScroll();
            }
            this.updateHeight(isResize);
            this.updateWidth(isResize);
            this.updateNowIndicator();
            if (isResize) {
                this.setScroll(scrollState);
            }
        },
        updateWidth: function(isResize) {},
        updateHeight: function(isResize) {
            var calendar = this.calendar;
            this.setHeight(calendar.getSuggestedViewHeight(), calendar.isHeightAuto());
        },
        setHeight: function(height, isAuto) {},
        computeInitialScroll: function(previousScrollState) {
            return 0;
        },
        queryScroll: function() {},
        setScroll: function(scrollState) {},
        forceScroll: function(scrollState) {
            var _this = this;
            this.setScroll(scrollState);
            setTimeout(function() {
                _this.setScroll(scrollState);
            }, 0);
        },
        displayEvents: function(events) {
            var scrollState = this.queryScroll();
            this.clearEvents();
            this.renderEvents(events);
            this.isEventsRendered = true;
            this.setScroll(scrollState);
            this.triggerEventRender();
        },
        clearEvents: function() {
            var scrollState;
            if (this.isEventsRendered) {
                scrollState = this.queryScroll();
                this.triggerEventUnrender();
                if (this.destroyEvents) {
                    this.destroyEvents();
                }
                this.unrenderEvents();
                this.setScroll(scrollState);
                this.isEventsRendered = false;
            }
        },
        renderEvents: function(events) {},
        unrenderEvents: function() {},
        triggerEventRender: function() {
            this.renderedEventSegEach(function(seg) {
                this.trigger("eventAfterRender", seg.event, seg.event, seg.el);
            });
            this.trigger("eventAfterAllRender");
        },
        triggerEventUnrender: function() {
            this.renderedEventSegEach(function(seg) {
                this.trigger("eventDestroy", seg.event, seg.event, seg.el);
            });
        },
        resolveEventEl: function(event, el) {
            var custom = this.trigger("eventRender", event, event, el);
            if (custom === false) {
                el = null;
            } else if (custom && custom !== true) {
                el = $(custom);
            }
            return el;
        },
        showEvent: function(event) {
            this.renderedEventSegEach(function(seg) {
                seg.el.css("visibility", "");
            }, event);
        },
        hideEvent: function(event) {
            this.renderedEventSegEach(function(seg) {
                seg.el.css("visibility", "hidden");
            }, event);
        },
        renderedEventSegEach: function(func, event) {
            var segs = this.getEventSegs();
            var i;
            for (i = 0; i < segs.length; i++) {
                if (!event || segs[i].event._id === event._id) {
                    if (segs[i].el) {
                        func.call(this, segs[i]);
                    }
                }
            }
        },
        getEventSegs: function() {
            return [];
        },
        isEventDraggable: function(event) {
            return this.isEventStartEditable(event);
        },
        isEventStartEditable: function(event) {
            return firstDefined(event.startEditable, (event.source || {}).startEditable, this.opt("eventStartEditable"), this.isEventGenerallyEditable(event));
        },
        isEventGenerallyEditable: function(event) {
            return firstDefined(event.editable, (event.source || {}).editable, this.opt("editable"));
        },
        reportEventDrop: function(event, dropLocation, largeUnit, el, ev) {
            var calendar = this.calendar;
            var mutateResult = calendar.mutateEvent(event, dropLocation, largeUnit);
            var undoFunc = function() {
                mutateResult.undo();
                calendar.reportEventChange();
            };
            this.triggerEventDrop(event, mutateResult.dateDelta, undoFunc, el, ev);
            calendar.reportEventChange();
        },
        triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {
            this.trigger("eventDrop", el[0], event, dateDelta, undoFunc, ev, {});
        },
        reportExternalDrop: function(meta, dropLocation, el, ev, ui) {
            var eventProps = meta.eventProps;
            var eventInput;
            var event;
            if (eventProps) {
                eventInput = $.extend({}, eventProps, dropLocation);
                event = this.calendar.renderEvent(eventInput, meta.stick)[0];
            }
            this.triggerExternalDrop(event, dropLocation, el, ev, ui);
        },
        triggerExternalDrop: function(event, dropLocation, el, ev, ui) {
            this.trigger("drop", el[0], dropLocation.start, ev, ui);
            if (event) {
                this.trigger("eventReceive", null, event);
            }
        },
        renderDrag: function(dropLocation, seg) {},
        unrenderDrag: function() {},
        isEventResizableFromStart: function(event) {
            return this.opt("eventResizableFromStart") && this.isEventResizable(event);
        },
        isEventResizableFromEnd: function(event) {
            return this.isEventResizable(event);
        },
        isEventResizable: function(event) {
            var source = event.source || {};
            return firstDefined(event.durationEditable, source.durationEditable, this.opt("eventDurationEditable"), event.editable, source.editable, this.opt("editable"));
        },
        reportEventResize: function(event, resizeLocation, largeUnit, el, ev) {
            var calendar = this.calendar;
            var mutateResult = calendar.mutateEvent(event, resizeLocation, largeUnit);
            var undoFunc = function() {
                mutateResult.undo();
                calendar.reportEventChange();
            };
            this.triggerEventResize(event, mutateResult.durationDelta, undoFunc, el, ev);
            calendar.reportEventChange();
        },
        triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {
            this.trigger("eventResize", el[0], event, durationDelta, undoFunc, ev, {});
        },
        select: function(span, ev) {
            this.unselect(ev);
            this.renderSelection(span);
            this.reportSelection(span, ev);
        },
        renderSelection: function(span) {},
        reportSelection: function(span, ev) {
            this.isSelected = true;
            this.triggerSelect(span, ev);
        },
        triggerSelect: function(span, ev) {
            this.trigger("select", null, this.calendar.applyTimezone(span.start), this.calendar.applyTimezone(span.end), ev);
        },
        unselect: function(ev) {
            if (this.isSelected) {
                this.isSelected = false;
                if (this.destroySelection) {
                    this.destroySelection();
                }
                this.unrenderSelection();
                this.trigger("unselect", null, ev);
            }
        },
        unrenderSelection: function() {},
        selectEvent: function(event) {
            if (!this.selectedEvent || this.selectedEvent !== event) {
                this.unselectEvent();
                this.renderedEventSegEach(function(seg) {
                    seg.el.addClass("fc-selected");
                }, event);
                this.selectedEvent = event;
            }
        },
        unselectEvent: function() {
            if (this.selectedEvent) {
                this.renderedEventSegEach(function(seg) {
                    seg.el.removeClass("fc-selected");
                }, this.selectedEvent);
                this.selectedEvent = null;
            }
        },
        isEventSelected: function(event) {
            return this.selectedEvent && this.selectedEvent._id === event._id;
        },
        handleDocumentMousedown: function(ev) {
            if (isPrimaryMouseButton(ev)) {
                this.processUnselect(ev);
            }
        },
        processUnselect: function(ev) {
            this.processRangeUnselect(ev);
            this.processEventUnselect(ev);
        },
        processRangeUnselect: function(ev) {
            var ignore;
            if (this.isSelected && this.opt("unselectAuto")) {
                ignore = this.opt("unselectCancel");
                if (!ignore || !$(ev.target).closest(ignore).length) {
                    this.unselect(ev);
                }
            }
        },
        processEventUnselect: function(ev) {
            if (this.selectedEvent) {
                if (!$(ev.target).closest(".fc-selected").length) {
                    this.unselectEvent();
                }
            }
        },
        triggerDayClick: function(span, dayEl, ev) {
            this.trigger("dayClick", dayEl, this.calendar.applyTimezone(span.start), ev);
        },
        initHiddenDays: function() {
            var hiddenDays = this.opt("hiddenDays") || [];
            var isHiddenDayHash = [];
            var dayCnt = 0;
            var i;
            if (this.opt("weekends") === false) {
                hiddenDays.push(0, 6);
            }
            for (i = 0; i < 7; i++) {
                if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {
                    dayCnt++;
                }
            }
            if (!dayCnt) {
                throw "invalid hiddenDays";
            }
            this.isHiddenDayHash = isHiddenDayHash;
        },
        isHiddenDay: function(day) {
            if (moment.isMoment(day)) {
                day = day.day();
            }
            return this.isHiddenDayHash[day];
        },
        skipHiddenDays: function(date, inc, isExclusive) {
            var out = date.clone();
            inc = inc || 1;
            while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {
                out.add(inc, "days");
            }
            return out;
        },
        computeDayRange: function(range) {
            var startDay = range.start.clone().stripTime();
            var end = range.end;
            var endDay = null;
            var endTimeMS;
            if (end) {
                endDay = end.clone().stripTime();
                endTimeMS = +end.time();
                if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
                    endDay.add(1, "days");
                }
            }
            if (!end || endDay <= startDay) {
                endDay = startDay.clone().add(1, "days");
            }
            return {
                start: startDay,
                end: endDay
            };
        },
        isMultiDayEvent: function(event) {
            var range = this.computeDayRange(event);
            return range.end.diff(range.start, "days") > 1;
        }
    });
    var Scroller = FC.Scroller = Class.extend({
        el: null,
        scrollEl: null,
        overflowX: null,
        overflowY: null,
        constructor: function(options) {
            options = options || {};
            this.overflowX = options.overflowX || options.overflow || "auto";
            this.overflowY = options.overflowY || options.overflow || "auto";
        },
        render: function() {
            this.el = this.renderEl();
            this.applyOverflow();
        },
        renderEl: function() {
            return this.scrollEl = $('<div class="fc-scroller"></div>');
        },
        clear: function() {
            this.setHeight("auto");
            this.applyOverflow();
        },
        destroy: function() {
            this.el.remove();
        },
        applyOverflow: function() {
            this.scrollEl.css({
                "overflow-x": this.overflowX,
                "overflow-y": this.overflowY
            });
        },
        lockOverflow: function(scrollbarWidths) {
            var overflowX = this.overflowX;
            var overflowY = this.overflowY;
            scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();
            if (overflowX === "auto") {
                overflowX = scrollbarWidths.top || scrollbarWidths.bottom || this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth ? "scroll" : "hidden";
            }
            if (overflowY === "auto") {
                overflowY = scrollbarWidths.left || scrollbarWidths.right || this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight ? "scroll" : "hidden";
            }
            this.scrollEl.css({
                "overflow-x": overflowX,
                "overflow-y": overflowY
            });
        },
        setHeight: function(height) {
            this.scrollEl.height(height);
        },
        getScrollTop: function() {
            return this.scrollEl.scrollTop();
        },
        setScrollTop: function(top) {
            this.scrollEl.scrollTop(top);
        },
        getClientWidth: function() {
            return this.scrollEl[0].clientWidth;
        },
        getClientHeight: function() {
            return this.scrollEl[0].clientHeight;
        },
        getScrollbarWidths: function() {
            return getScrollbarWidths(this.scrollEl);
        }
    });
    var Calendar = FC.Calendar = Class.extend({
        dirDefaults: null,
        localeDefaults: null,
        overrides: null,
        dynamicOverrides: null,
        options: null,
        viewSpecCache: null,
        view: null,
        header: null,
        loadingLevel: 0,
        constructor: Calendar_constructor,
        initialize: function() {},
        populateOptionsHash: function() {
            var locale, localeDefaults;
            var isRTL, dirDefaults;
            locale = firstDefined(this.dynamicOverrides.locale, this.overrides.locale);
            localeDefaults = localeOptionHash[locale];
            if (!localeDefaults) {
                locale = Calendar.defaults.locale;
                localeDefaults = localeOptionHash[locale] || {};
            }
            isRTL = firstDefined(this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, Calendar.defaults.isRTL);
            dirDefaults = isRTL ? Calendar.rtlDefaults : {};
            this.dirDefaults = dirDefaults;
            this.localeDefaults = localeDefaults;
            this.options = mergeOptions([ Calendar.defaults, dirDefaults, localeDefaults, this.overrides, this.dynamicOverrides ]);
            populateInstanceComputableOptions(this.options);
        },
        getViewSpec: function(viewType) {
            var cache = this.viewSpecCache;
            return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
        },
        getUnitViewSpec: function(unit) {
            var viewTypes;
            var i;
            var spec;
            if ($.inArray(unit, intervalUnits) != -1) {
                viewTypes = this.header.getViewsWithButtons();
                $.each(FC.views, function(viewType) {
                    viewTypes.push(viewType);
                });
                for (i = 0; i < viewTypes.length; i++) {
                    spec = this.getViewSpec(viewTypes[i]);
                    if (spec) {
                        if (spec.singleUnit == unit) {
                            return spec;
                        }
                    }
                }
            }
        },
        buildViewSpec: function(requestedViewType) {
            var viewOverrides = this.overrides.views || {};
            var specChain = [];
            var defaultsChain = [];
            var overridesChain = [];
            var viewType = requestedViewType;
            var spec;
            var overrides;
            var duration;
            var unit;
            while (viewType) {
                spec = fcViews[viewType];
                overrides = viewOverrides[viewType];
                viewType = null;
                if (typeof spec === "function") {
                    spec = {
                        class: spec
                    };
                }
                if (spec) {
                    specChain.unshift(spec);
                    defaultsChain.unshift(spec.defaults || {});
                    duration = duration || spec.duration;
                    viewType = viewType || spec.type;
                }
                if (overrides) {
                    overridesChain.unshift(overrides);
                    duration = duration || overrides.duration;
                    viewType = viewType || overrides.type;
                }
            }
            spec = mergeProps(specChain);
            spec.type = requestedViewType;
            if (!spec["class"]) {
                return false;
            }
            if (duration) {
                duration = moment.duration(duration);
                if (duration.valueOf()) {
                    spec.duration = duration;
                    unit = computeIntervalUnit(duration);
                    if (duration.as(unit) === 1) {
                        spec.singleUnit = unit;
                        overridesChain.unshift(viewOverrides[unit] || {});
                    }
                }
            }
            spec.defaults = mergeOptions(defaultsChain);
            spec.overrides = mergeOptions(overridesChain);
            this.buildViewSpecOptions(spec);
            this.buildViewSpecButtonText(spec, requestedViewType);
            return spec;
        },
        buildViewSpecOptions: function(spec) {
            spec.options = mergeOptions([ Calendar.defaults, spec.defaults, this.dirDefaults, this.localeDefaults, this.overrides, spec.overrides, this.dynamicOverrides ]);
            populateInstanceComputableOptions(spec.options);
        },
        buildViewSpecButtonText: function(spec, requestedViewType) {
            function queryButtonText(options) {
                var buttonText = options.buttonText || {};
                return buttonText[requestedViewType] || (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) || (spec.singleUnit ? buttonText[spec.singleUnit] : null);
            }
            spec.buttonTextOverride = queryButtonText(this.dynamicOverrides) || queryButtonText(this.overrides) || spec.overrides.buttonText;
            spec.buttonTextDefault = queryButtonText(this.localeDefaults) || queryButtonText(this.dirDefaults) || spec.defaults.buttonText || queryButtonText(Calendar.defaults) || (spec.duration ? this.humanizeDuration(spec.duration) : null) || requestedViewType;
        },
        instantiateView: function(viewType) {
            var spec = this.getViewSpec(viewType);
            return new spec["class"](this, viewType, spec.options, spec.duration);
        },
        isValidViewType: function(viewType) {
            return Boolean(this.getViewSpec(viewType));
        },
        pushLoading: function() {
            if (!this.loadingLevel++) {
                this.trigger("loading", null, true, this.view);
            }
        },
        popLoading: function() {
            if (!--this.loadingLevel) {
                this.trigger("loading", null, false, this.view);
            }
        },
        buildSelectSpan: function(zonedStartInput, zonedEndInput) {
            var start = this.moment(zonedStartInput).stripZone();
            var end;
            if (zonedEndInput) {
                end = this.moment(zonedEndInput).stripZone();
            } else if (start.hasTime()) {
                end = start.clone().add(this.defaultTimedEventDuration);
            } else {
                end = start.clone().add(this.defaultAllDayEventDuration);
            }
            return {
                start: start,
                end: end
            };
        }
    });
    Calendar.mixin(EmitterMixin);
    function Calendar_constructor(element, overrides) {
        var t = this;
        t.render = render;
        t.destroy = destroy;
        t.refetchEvents = refetchEvents;
        t.refetchEventSources = refetchEventSources;
        t.reportEvents = reportEvents;
        t.reportEventChange = reportEventChange;
        t.rerenderEvents = renderEvents;
        t.changeView = renderView;
        t.select = select;
        t.unselect = unselect;
        t.prev = prev;
        t.next = next;
        t.prevYear = prevYear;
        t.nextYear = nextYear;
        t.today = today;
        t.gotoDate = gotoDate;
        t.incrementDate = incrementDate;
        t.zoomTo = zoomTo;
        t.getDate = getDate;
        t.getCalendar = getCalendar;
        t.getView = getView;
        t.option = option;
        t.trigger = trigger;
        t.dynamicOverrides = {};
        t.viewSpecCache = {};
        t.optionHandlers = {};
        t.overrides = $.extend({}, overrides);
        t.populateOptionsHash();
        var localeData;
        t.bindOptions([ "locale", "monthNames", "monthNamesShort", "dayNames", "dayNamesShort", "firstDay", "weekNumberCalculation" ], function(locale, monthNames, monthNamesShort, dayNames, dayNamesShort, firstDay, weekNumberCalculation) {
            if (weekNumberCalculation === "iso") {
                weekNumberCalculation = "ISO";
            }
            localeData = createObject(getMomentLocaleData(locale));
            if (monthNames) {
                localeData._months = monthNames;
            }
            if (monthNamesShort) {
                localeData._monthsShort = monthNamesShort;
            }
            if (dayNames) {
                localeData._weekdays = dayNames;
            }
            if (dayNamesShort) {
                localeData._weekdaysShort = dayNamesShort;
            }
            if (firstDay == null && weekNumberCalculation === "ISO") {
                firstDay = 1;
            }
            if (firstDay != null) {
                var _week = createObject(localeData._week);
                _week.dow = firstDay;
                localeData._week = _week;
            }
            if (weekNumberCalculation === "ISO" || weekNumberCalculation === "local" || typeof weekNumberCalculation === "function") {
                localeData._fullCalendar_weekCalc = weekNumberCalculation;
            }
            if (date) {
                localizeMoment(date);
            }
        });
        t.defaultAllDayEventDuration = moment.duration(t.options.defaultAllDayEventDuration);
        t.defaultTimedEventDuration = moment.duration(t.options.defaultTimedEventDuration);
        t.moment = function() {
            var mom;
            if (t.options.timezone === "local") {
                mom = FC.moment.apply(null, arguments);
                if (mom.hasTime()) {
                    mom.local();
                }
            } else if (t.options.timezone === "UTC") {
                mom = FC.moment.utc.apply(null, arguments);
            } else {
                mom = FC.moment.parseZone.apply(null, arguments);
            }
            localizeMoment(mom);
            return mom;
        };
        function localizeMoment(mom) {
            mom._locale = localeData;
        }
        t.localizeMoment = localizeMoment;
        t.getIsAmbigTimezone = function() {
            return t.options.timezone !== "local" && t.options.timezone !== "UTC";
        };
        t.applyTimezone = function(date) {
            if (!date.hasTime()) {
                return date.clone();
            }
            var zonedDate = t.moment(date.toArray());
            var timeAdjust = date.time() - zonedDate.time();
            var adjustedZonedDate;
            if (timeAdjust) {
                adjustedZonedDate = zonedDate.clone().add(timeAdjust);
                if (date.time() - adjustedZonedDate.time() === 0) {
                    zonedDate = adjustedZonedDate;
                }
            }
            return zonedDate;
        };
        t.getNow = function() {
            var now = t.options.now;
            if (typeof now === "function") {
                now = now();
            }
            return t.moment(now).stripZone();
        };
        t.getEventEnd = function(event) {
            if (event.end) {
                return event.end.clone();
            } else {
                return t.getDefaultEventEnd(event.allDay, event.start);
            }
        };
        t.getDefaultEventEnd = function(allDay, zonedStart) {
            var end = zonedStart.clone();
            if (allDay) {
                end.stripTime().add(t.defaultAllDayEventDuration);
            } else {
                end.add(t.defaultTimedEventDuration);
            }
            if (t.getIsAmbigTimezone()) {
                end.stripZone();
            }
            return end;
        };
        t.humanizeDuration = function(duration) {
            return duration.locale(t.options.locale).humanize();
        };
        EventManager.call(t);
        var isFetchNeeded = t.isFetchNeeded;
        var fetchEvents = t.fetchEvents;
        var fetchEventSources = t.fetchEventSources;
        var _element = element[0];
        var header;
        var content;
        var tm;
        var currentView;
        var viewsByType = {};
        var suggestedViewHeight;
        var windowResizeProxy;
        var ignoreWindowResize = 0;
        var events = [];
        var date;
        if (t.options.defaultDate != null) {
            date = t.moment(t.options.defaultDate).stripZone();
        } else {
            date = t.getNow();
        }
        function render() {
            if (!content) {
                initialRender();
            } else if (elementVisible()) {
                calcSize();
                renderView();
            }
        }
        function initialRender() {
            element.addClass("fc");
            element.on("click.fc", "a[data-goto]", function(ev) {
                var anchorEl = $(this);
                var gotoOptions = anchorEl.data("goto");
                var date = t.moment(gotoOptions.date);
                var viewType = gotoOptions.type;
                var customAction = currentView.opt("navLink" + capitaliseFirstLetter(viewType) + "Click");
                if (typeof customAction === "function") {
                    customAction(date, ev);
                } else {
                    if (typeof customAction === "string") {
                        viewType = customAction;
                    }
                    zoomTo(date, viewType);
                }
            });
            t.bindOption("theme", function(theme) {
                tm = theme ? "ui" : "fc";
                element.toggleClass("ui-widget", theme);
                element.toggleClass("fc-unthemed", !theme);
            });
            t.bindOptions([ "isRTL", "locale" ], function(isRTL) {
                element.toggleClass("fc-ltr", !isRTL);
                element.toggleClass("fc-rtl", isRTL);
            });
            content = $("<div class='fc-view-container'/>").prependTo(element);
            header = t.header = new Header(t);
            renderHeader();
            renderView(t.options.defaultView);
            if (t.options.handleWindowResize) {
                windowResizeProxy = debounce(windowResize, t.options.windowResizeDelay);
                $(window).resize(windowResizeProxy);
            }
        }
        function renderHeader() {
            header.render();
            if (header.el) {
                element.prepend(header.el);
            }
        }
        function destroy() {
            if (currentView) {
                currentView.removeElement();
            }
            header.removeElement();
            content.remove();
            element.removeClass("fc fc-ltr fc-rtl fc-unthemed ui-widget");
            element.off(".fc");
            if (windowResizeProxy) {
                $(window).unbind("resize", windowResizeProxy);
            }
        }
        function elementVisible() {
            return element.is(":visible");
        }
        function renderView(viewType, explicitScrollState) {
            ignoreWindowResize++;
            if (currentView && viewType && currentView.type !== viewType) {
                freezeContentHeight();
                clearView();
            }
            if (!currentView && viewType) {
                currentView = t.view = viewsByType[viewType] || (viewsByType[viewType] = t.instantiateView(viewType));
                currentView.setElement($("<div class='fc-view fc-" + viewType + "-view' />").appendTo(content));
                header.activateButton(viewType);
            }
            if (currentView) {
                date = currentView.massageCurrentDate(date);
                if (!currentView.displaying || !(date >= currentView.intervalStart && date < currentView.intervalEnd)) {
                    if (elementVisible()) {
                        currentView.display(date, explicitScrollState);
                        unfreezeContentHeight();
                        updateHeaderTitle();
                        updateTodayButton();
                        getAndRenderEvents();
                    }
                }
            }
            unfreezeContentHeight();
            ignoreWindowResize--;
        }
        function clearView() {
            header.deactivateButton(currentView.type);
            currentView.removeElement();
            currentView = t.view = null;
        }
        function reinitView() {
            ignoreWindowResize++;
            freezeContentHeight();
            var viewType = currentView.type;
            var scrollState = currentView.queryScroll();
            clearView();
            renderView(viewType, scrollState);
            unfreezeContentHeight();
            ignoreWindowResize--;
        }
        t.getSuggestedViewHeight = function() {
            if (suggestedViewHeight === undefined) {
                calcSize();
            }
            return suggestedViewHeight;
        };
        t.isHeightAuto = function() {
            return t.options.contentHeight === "auto" || t.options.height === "auto";
        };
        function updateSize(shouldRecalc) {
            if (elementVisible()) {
                if (shouldRecalc) {
                    _calcSize();
                }
                ignoreWindowResize++;
                currentView.updateSize(true);
                ignoreWindowResize--;
                return true;
            }
        }
        function calcSize() {
            if (elementVisible()) {
                _calcSize();
            }
        }
        function _calcSize() {
            var contentHeightInput = t.options.contentHeight;
            var heightInput = t.options.height;
            if (typeof contentHeightInput === "number") {
                suggestedViewHeight = contentHeightInput;
            } else if (typeof contentHeightInput === "function") {
                suggestedViewHeight = contentHeightInput();
            } else if (typeof heightInput === "number") {
                suggestedViewHeight = heightInput - queryHeaderHeight();
            } else if (typeof heightInput === "function") {
                suggestedViewHeight = heightInput() - queryHeaderHeight();
            } else if (heightInput === "parent") {
                suggestedViewHeight = element.parent().height() - queryHeaderHeight();
            } else {
                suggestedViewHeight = Math.round(content.width() / Math.max(t.options.aspectRatio, .5));
            }
        }
        function queryHeaderHeight() {
            return header.el ? header.el.outerHeight(true) : 0;
        }
        function windowResize(ev) {
            if (!ignoreWindowResize && ev.target === window && currentView.start) {
                if (updateSize(true)) {
                    currentView.trigger("windowResize", _element);
                }
            }
        }
        function refetchEvents() {
            fetchAndRenderEvents();
        }
        function refetchEventSources(matchInputs) {
            fetchEventSources(t.getEventSourcesByMatchArray(matchInputs));
        }
        function renderEvents() {
            if (elementVisible()) {
                freezeContentHeight();
                currentView.displayEvents(events);
                unfreezeContentHeight();
            }
        }
        function getAndRenderEvents() {
            if (!t.options.lazyFetching || isFetchNeeded(currentView.start, currentView.end)) {
                fetchAndRenderEvents();
            } else {
                renderEvents();
            }
        }
        function fetchAndRenderEvents() {
            fetchEvents(currentView.start, currentView.end);
        }
        function reportEvents(_events) {
            events = _events;
            renderEvents();
        }
        function reportEventChange() {
            renderEvents();
        }
        function updateHeaderTitle() {
            header.updateTitle(currentView.title);
        }
        function updateTodayButton() {
            var now = t.getNow();
            if (now >= currentView.intervalStart && now < currentView.intervalEnd) {
                header.disableButton("today");
            } else {
                header.enableButton("today");
            }
        }
        function select(zonedStartInput, zonedEndInput) {
            currentView.select(t.buildSelectSpan.apply(t, arguments));
        }
        function unselect() {
            if (currentView) {
                currentView.unselect();
            }
        }
        function prev() {
            date = currentView.computePrevDate(date);
            renderView();
        }
        function next() {
            date = currentView.computeNextDate(date);
            renderView();
        }
        function prevYear() {
            date.add(-1, "years");
            renderView();
        }
        function nextYear() {
            date.add(1, "years");
            renderView();
        }
        function today() {
            date = t.getNow();
            renderView();
        }
        function gotoDate(zonedDateInput) {
            date = t.moment(zonedDateInput).stripZone();
            renderView();
        }
        function incrementDate(delta) {
            date.add(moment.duration(delta));
            renderView();
        }
        function zoomTo(newDate, viewType) {
            var spec;
            viewType = viewType || "day";
            spec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);
            date = newDate.clone();
            renderView(spec ? spec.type : null);
        }
        function getDate() {
            return t.applyTimezone(date);
        }
        t.freezeContentHeight = freezeContentHeight;
        t.unfreezeContentHeight = unfreezeContentHeight;
        function freezeContentHeight() {
            content.css({
                width: "100%",
                height: content.height(),
                overflow: "hidden"
            });
        }
        function unfreezeContentHeight() {
            content.css({
                width: "",
                height: "",
                overflow: ""
            });
        }
        function getCalendar() {
            return t;
        }
        function getView() {
            return currentView;
        }
        function option(name, value) {
            var newOptionHash;
            if (typeof name === "string") {
                if (value === undefined) {
                    return t.options[name];
                } else {
                    newOptionHash = {};
                    newOptionHash[name] = value;
                    setOptions(newOptionHash);
                }
            } else if (typeof name === "object") {
                setOptions(name);
            }
        }
        function setOptions(newOptionHash) {
            var optionCnt = 0;
            var optionName;
            for (optionName in newOptionHash) {
                t.dynamicOverrides[optionName] = newOptionHash[optionName];
            }
            t.viewSpecCache = {};
            t.populateOptionsHash();
            for (optionName in newOptionHash) {
                t.triggerOptionHandlers(optionName);
                optionCnt++;
            }
            if (optionCnt === 1) {
                if (optionName === "height" || optionName === "contentHeight" || optionName === "aspectRatio") {
                    updateSize(true);
                    return;
                } else if (optionName === "defaultDate") {
                    return;
                } else if (optionName === "businessHours") {
                    if (currentView) {
                        currentView.unrenderBusinessHours();
                        currentView.renderBusinessHours();
                    }
                    return;
                } else if (optionName === "timezone") {
                    t.rezoneArrayEventSources();
                    refetchEvents();
                    return;
                }
            }
            renderHeader();
            viewsByType = {};
            reinitView();
        }
        function trigger(name, thisObj) {
            var args = Array.prototype.slice.call(arguments, 2);
            thisObj = thisObj || _element;
            this.triggerWith(name, thisObj, args);
            if (t.options[name]) {
                return t.options[name].apply(thisObj, args);
            }
        }
        t.initialize();
    }
    Calendar.mixin({
        optionHandlers: null,
        bindOption: function(optionName, handlerFunc) {
            this.bindOptions([ optionName ], handlerFunc);
        },
        bindOptions: function(optionNames, handlerFunc) {
            var handlerObj = {
                func: handlerFunc,
                names: optionNames
            };
            var i;
            for (i = 0; i < optionNames.length; i++) {
                this.registerOptionHandlerObj(optionNames[i], handlerObj);
            }
            this.triggerOptionHandlerObj(handlerObj);
        },
        registerOptionHandlerObj: function(optionName, handlerObj) {
            (this.optionHandlers[optionName] || (this.optionHandlers[optionName] = [])).push(handlerObj);
        },
        triggerOptionHandlers: function(optionName) {
            var handlerObjs = this.optionHandlers[optionName] || [];
            var i;
            for (i = 0; i < handlerObjs.length; i++) {
                this.triggerOptionHandlerObj(handlerObjs[i]);
            }
        },
        triggerOptionHandlerObj: function(handlerObj) {
            var optionNames = handlerObj.names;
            var optionValues = [];
            var i;
            for (i = 0; i < optionNames.length; i++) {
                optionValues.push(this.options[optionNames[i]]);
            }
            handlerObj.func.apply(this, optionValues);
        }
    });
    Calendar.defaults = {
        titleRangeSeparator: "  ",
        monthYearFormat: "MMMM YYYY",
        defaultTimedEventDuration: "02:00:00",
        defaultAllDayEventDuration: {
            days: 1
        },
        forceEventDuration: false,
        nextDayThreshold: "09:00:00",
        defaultView: "month",
        aspectRatio: 1.35,
        header: {
            left: "title",
            center: "",
            right: "today prev,next"
        },
        weekends: true,
        weekNumbers: false,
        weekNumberTitle: "W",
        weekNumberCalculation: "local",
        scrollTime: "06:00:00",
        lazyFetching: true,
        startParam: "start",
        endParam: "end",
        timezoneParam: "timezone",
        timezone: false,
        isRTL: false,
        buttonText: {
            prev: "prev",
            next: "next",
            prevYear: "prev year",
            nextYear: "next year",
            year: "year",
            today: "today",
            month: "month",
            week: "week",
            day: "day"
        },
        buttonIcons: {
            prev: "left-single-arrow",
            next: "right-single-arrow",
            prevYear: "left-double-arrow",
            nextYear: "right-double-arrow"
        },
        allDayText: "all-day",
        theme: false,
        themeButtonIcons: {
            prev: "circle-triangle-w",
            next: "circle-triangle-e",
            prevYear: "seek-prev",
            nextYear: "seek-next"
        },
        dragOpacity: .75,
        dragRevertDuration: 500,
        dragScroll: true,
        unselectAuto: true,
        dropAccept: "*",
        eventOrder: "title",
        eventLimit: false,
        eventLimitText: "more",
        eventLimitClick: "popover",
        dayPopoverFormat: "LL",
        handleWindowResize: true,
        windowResizeDelay: 100,
        longPressDelay: 1e3
    };
    Calendar.englishDefaults = {
        dayPopoverFormat: "dddd, MMMM D"
    };
    Calendar.rtlDefaults = {
        header: {
            left: "next,prev today",
            center: "",
            right: "title"
        },
        buttonIcons: {
            prev: "right-single-arrow",
            next: "left-single-arrow",
            prevYear: "right-double-arrow",
            nextYear: "left-double-arrow"
        },
        themeButtonIcons: {
            prev: "circle-triangle-e",
            next: "circle-triangle-w",
            nextYear: "seek-prev",
            prevYear: "seek-next"
        }
    };
    var localeOptionHash = FC.locales = {};
    FC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {
        var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});
        fcOptions.isRTL = dpOptions.isRTL;
        fcOptions.weekNumberTitle = dpOptions.weekHeader;
        $.each(dpComputableOptions, function(name, func) {
            fcOptions[name] = func(dpOptions);
        });
        if ($.datepicker) {
            $.datepicker.regional[dpLocaleCode] = $.datepicker.regional[localeCode] = dpOptions;
            $.datepicker.regional.en = $.datepicker.regional[""];
            $.datepicker.setDefaults(dpOptions);
        }
    };
    FC.locale = function(localeCode, newFcOptions) {
        var fcOptions;
        var momOptions;
        fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});
        if (newFcOptions) {
            fcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);
        }
        momOptions = getMomentLocaleData(localeCode);
        $.each(momComputableOptions, function(name, func) {
            if (fcOptions[name] == null) {
                fcOptions[name] = func(momOptions, fcOptions);
            }
        });
        Calendar.defaults.locale = localeCode;
    };
    var dpComputableOptions = {
        buttonText: function(dpOptions) {
            return {
                prev: stripHtmlEntities(dpOptions.prevText),
                next: stripHtmlEntities(dpOptions.nextText),
                today: stripHtmlEntities(dpOptions.currentText)
            };
        },
        monthYearFormat: function(dpOptions) {
            return dpOptions.showMonthAfterYear ? "YYYY[" + dpOptions.yearSuffix + "] MMMM" : "MMMM YYYY[" + dpOptions.yearSuffix + "]";
        }
    };
    var momComputableOptions = {
        dayOfMonthFormat: function(momOptions, fcOptions) {
            var format = momOptions.longDateFormat("l");
            format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, "");
            if (fcOptions.isRTL) {
                format += " ddd";
            } else {
                format = "ddd " + format;
            }
            return format;
        },
        mediumTimeFormat: function(momOptions) {
            return momOptions.longDateFormat("LT").replace(/\s*a$/i, "a");
        },
        smallTimeFormat: function(momOptions) {
            return momOptions.longDateFormat("LT").replace(":mm", "(:mm)").replace(/(\Wmm)$/, "($1)").replace(/\s*a$/i, "a");
        },
        extraSmallTimeFormat: function(momOptions) {
            return momOptions.longDateFormat("LT").replace(":mm", "(:mm)").replace(/(\Wmm)$/, "($1)").replace(/\s*a$/i, "t");
        },
        hourFormat: function(momOptions) {
            return momOptions.longDateFormat("LT").replace(":mm", "").replace(/(\Wmm)$/, "").replace(/\s*a$/i, "a");
        },
        noMeridiemTimeFormat: function(momOptions) {
            return momOptions.longDateFormat("LT").replace(/\s*a$/i, "");
        }
    };
    var instanceComputableOptions = {
        smallDayDateFormat: function(options) {
            return options.isRTL ? "D dd" : "dd D";
        },
        weekFormat: function(options) {
            return options.isRTL ? "w[ " + options.weekNumberTitle + "]" : "[" + options.weekNumberTitle + " ]w";
        },
        smallWeekFormat: function(options) {
            return options.isRTL ? "w[" + options.weekNumberTitle + "]" : "[" + options.weekNumberTitle + "]w";
        }
    };
    function populateInstanceComputableOptions(options) {
        $.each(instanceComputableOptions, function(name, func) {
            if (options[name] == null) {
                options[name] = func(options);
            }
        });
    }
    function getMomentLocaleData(localeCode) {
        return moment.localeData(localeCode) || moment.localeData("en");
    }
    FC.locale("en", Calendar.englishDefaults);
    function Header(calendar) {
        var t = this;
        t.render = render;
        t.removeElement = removeElement;
        t.updateTitle = updateTitle;
        t.activateButton = activateButton;
        t.deactivateButton = deactivateButton;
        t.disableButton = disableButton;
        t.enableButton = enableButton;
        t.getViewsWithButtons = getViewsWithButtons;
        t.el = null;
        var el;
        var viewsWithButtons = [];
        var tm;
        function render() {
            var options = calendar.options;
            var sections = options.header;
            tm = options.theme ? "ui" : "fc";
            if (sections) {
                if (!el) {
                    el = this.el = $("<div class='fc-toolbar'/>");
                } else {
                    el.empty();
                }
                el.append(renderSection("left")).append(renderSection("right")).append(renderSection("center")).append('<div class="fc-clear"/>');
            } else {
                removeElement();
            }
        }
        function removeElement() {
            if (el) {
                el.remove();
                el = t.el = null;
            }
        }
        function renderSection(position) {
            var sectionEl = $('<div class="fc-' + position + '"/>');
            var options = calendar.options;
            var buttonStr = options.header[position];
            if (buttonStr) {
                $.each(buttonStr.split(" "), function(i) {
                    var groupChildren = $();
                    var isOnlyButtons = true;
                    var groupEl;
                    $.each(this.split(","), function(j, buttonName) {
                        var customButtonProps;
                        var viewSpec;
                        var buttonClick;
                        var overrideText;
                        var defaultText;
                        var themeIcon;
                        var normalIcon;
                        var innerHtml;
                        var classes;
                        var button;
                        if (buttonName == "title") {
                            groupChildren = groupChildren.add($("<h2>&nbsp;</h2>"));
                            isOnlyButtons = false;
                        } else {
                            if (customButtonProps = (options.customButtons || {})[buttonName]) {
                                buttonClick = function(ev) {
                                    if (customButtonProps.click) {
                                        customButtonProps.click.call(button[0], ev);
                                    }
                                };
                                overrideText = "";
                                defaultText = customButtonProps.text;
                            } else if (viewSpec = calendar.getViewSpec(buttonName)) {
                                buttonClick = function() {
                                    calendar.changeView(buttonName);
                                };
                                viewsWithButtons.push(buttonName);
                                overrideText = viewSpec.buttonTextOverride;
                                defaultText = viewSpec.buttonTextDefault;
                            } else if (calendar[buttonName]) {
                                buttonClick = function() {
                                    calendar[buttonName]();
                                };
                                overrideText = (calendar.overrides.buttonText || {})[buttonName];
                                defaultText = options.buttonText[buttonName];
                            }
                            if (buttonClick) {
                                themeIcon = customButtonProps ? customButtonProps.themeIcon : options.themeButtonIcons[buttonName];
                                normalIcon = customButtonProps ? customButtonProps.icon : options.buttonIcons[buttonName];
                                if (overrideText) {
                                    innerHtml = htmlEscape(overrideText);
                                } else if (themeIcon && options.theme) {
                                    innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
                                } else if (normalIcon && !options.theme) {
                                    innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
                                } else {
                                    innerHtml = htmlEscape(defaultText);
                                }
                                classes = [ "fc-" + buttonName + "-button", tm + "-button", tm + "-state-default" ];
                                button = $('<button type="button" class="' + classes.join(" ") + '">' + innerHtml + "</button>").click(function(ev) {
                                    if (!button.hasClass(tm + "-state-disabled")) {
                                        buttonClick(ev);
                                        if (button.hasClass(tm + "-state-active") || button.hasClass(tm + "-state-disabled")) {
                                            button.removeClass(tm + "-state-hover");
                                        }
                                    }
                                }).mousedown(function() {
                                    button.not("." + tm + "-state-active").not("." + tm + "-state-disabled").addClass(tm + "-state-down");
                                }).mouseup(function() {
                                    button.removeClass(tm + "-state-down");
                                }).hover(function() {
                                    button.not("." + tm + "-state-active").not("." + tm + "-state-disabled").addClass(tm + "-state-hover");
                                }, function() {
                                    button.removeClass(tm + "-state-hover").removeClass(tm + "-state-down");
                                });
                                groupChildren = groupChildren.add(button);
                            }
                        }
                    });
                    if (isOnlyButtons) {
                        groupChildren.first().addClass(tm + "-corner-left").end().last().addClass(tm + "-corner-right").end();
                    }
                    if (groupChildren.length > 1) {
                        groupEl = $("<div/>");
                        if (isOnlyButtons) {
                            groupEl.addClass("fc-button-group");
                        }
                        groupEl.append(groupChildren);
                        sectionEl.append(groupEl);
                    } else {
                        sectionEl.append(groupChildren);
                    }
                });
            }
            return sectionEl;
        }
        function updateTitle(text) {
            if (el) {
                el.find("h2").text(text);
            }
        }
        function activateButton(buttonName) {
            if (el) {
                el.find(".fc-" + buttonName + "-button").addClass(tm + "-state-active");
            }
        }
        function deactivateButton(buttonName) {
            if (el) {
                el.find(".fc-" + buttonName + "-button").removeClass(tm + "-state-active");
            }
        }
        function disableButton(buttonName) {
            if (el) {
                el.find(".fc-" + buttonName + "-button").prop("disabled", true).addClass(tm + "-state-disabled");
            }
        }
        function enableButton(buttonName) {
            if (el) {
                el.find(".fc-" + buttonName + "-button").prop("disabled", false).removeClass(tm + "-state-disabled");
            }
        }
        function getViewsWithButtons() {
            return viewsWithButtons;
        }
    }
    FC.sourceNormalizers = [];
    FC.sourceFetchers = [];
    var ajaxDefaults = {
        dataType: "json",
        cache: false
    };
    var eventGUID = 1;
    function EventManager() {
        var t = this;
        t.isFetchNeeded = isFetchNeeded;
        t.fetchEvents = fetchEvents;
        t.fetchEventSources = fetchEventSources;
        t.getEventSources = getEventSources;
        t.getEventSourceById = getEventSourceById;
        t.getEventSourcesByMatchArray = getEventSourcesByMatchArray;
        t.getEventSourcesByMatch = getEventSourcesByMatch;
        t.addEventSource = addEventSource;
        t.removeEventSource = removeEventSource;
        t.removeEventSources = removeEventSources;
        t.updateEvent = updateEvent;
        t.renderEvent = renderEvent;
        t.removeEvents = removeEvents;
        t.clientEvents = clientEvents;
        t.mutateEvent = mutateEvent;
        t.normalizeEventDates = normalizeEventDates;
        t.normalizeEventTimes = normalizeEventTimes;
        var reportEvents = t.reportEvents;
        var stickySource = {
            events: []
        };
        var sources = [ stickySource ];
        var rangeStart, rangeEnd;
        var pendingSourceCnt = 0;
        var cache = [];
        $.each((t.options.events ? [ t.options.events ] : []).concat(t.options.eventSources || []), function(i, sourceInput) {
            var source = buildEventSource(sourceInput);
            if (source) {
                sources.push(source);
            }
        });
        function isFetchNeeded(start, end) {
            return !rangeStart || start < rangeStart || end > rangeEnd;
        }
        function fetchEvents(start, end) {
            rangeStart = start;
            rangeEnd = end;
            fetchEventSources(sources, "reset");
        }
        function fetchEventSources(specificSources, specialFetchType) {
            var i, source;
            if (specialFetchType === "reset") {
                cache = [];
            } else if (specialFetchType !== "add") {
                cache = excludeEventsBySources(cache, specificSources);
            }
            for (i = 0; i < specificSources.length; i++) {
                source = specificSources[i];
                if (source._status !== "pending") {
                    pendingSourceCnt++;
                }
                source._fetchId = (source._fetchId || 0) + 1;
                source._status = "pending";
            }
            for (i = 0; i < specificSources.length; i++) {
                source = specificSources[i];
                tryFetchEventSource(source, source._fetchId);
            }
        }
        function tryFetchEventSource(source, fetchId) {
            _fetchEventSource(source, function(eventInputs) {
                var isArraySource = $.isArray(source.events);
                var i, eventInput;
                var abstractEvent;
                if (fetchId === source._fetchId && source._status !== "rejected") {
                    source._status = "resolved";
                    if (eventInputs) {
                        for (i = 0; i < eventInputs.length; i++) {
                            eventInput = eventInputs[i];
                            if (isArraySource) {
                                abstractEvent = eventInput;
                            } else {
                                abstractEvent = buildEventFromInput(eventInput, source);
                            }
                            if (abstractEvent) {
                                cache.push.apply(cache, expandEvent(abstractEvent));
                            }
                        }
                    }
                    decrementPendingSourceCnt();
                }
            });
        }
        function rejectEventSource(source) {
            var wasPending = source._status === "pending";
            source._status = "rejected";
            if (wasPending) {
                decrementPendingSourceCnt();
            }
        }
        function decrementPendingSourceCnt() {
            pendingSourceCnt--;
            if (!pendingSourceCnt) {
                reportEvents(cache);
            }
        }
        function _fetchEventSource(source, callback) {
            var i;
            var fetchers = FC.sourceFetchers;
            var res;
            for (i = 0; i < fetchers.length; i++) {
                res = fetchers[i].call(t, source, rangeStart.clone(), rangeEnd.clone(), t.options.timezone, callback);
                if (res === true) {
                    return;
                } else if (typeof res == "object") {
                    _fetchEventSource(res, callback);
                    return;
                }
            }
            var events = source.events;
            if (events) {
                if ($.isFunction(events)) {
                    t.pushLoading();
                    events.call(t, rangeStart.clone(), rangeEnd.clone(), t.options.timezone, function(events) {
                        callback(events);
                        t.popLoading();
                    });
                } else if ($.isArray(events)) {
                    callback(events);
                } else {
                    callback();
                }
            } else {
                var url = source.url;
                if (url) {
                    var success = source.success;
                    var error = source.error;
                    var complete = source.complete;
                    var customData;
                    if ($.isFunction(source.data)) {
                        customData = source.data();
                    } else {
                        customData = source.data;
                    }
                    var data = $.extend({}, customData || {});
                    var startParam = firstDefined(source.startParam, t.options.startParam);
                    var endParam = firstDefined(source.endParam, t.options.endParam);
                    var timezoneParam = firstDefined(source.timezoneParam, t.options.timezoneParam);
                    if (startParam) {
                        data[startParam] = rangeStart.format();
                    }
                    if (endParam) {
                        data[endParam] = rangeEnd.format();
                    }
                    if (t.options.timezone && t.options.timezone != "local") {
                        data[timezoneParam] = t.options.timezone;
                    }
                    t.pushLoading();
                    $.ajax($.extend({}, ajaxDefaults, source, {
                        data: data,
                        success: function(events) {
                            events = events || [];
                            var res = applyAll(success, this, arguments);
                            if ($.isArray(res)) {
                                events = res;
                            }
                            callback(events);
                        },
                        error: function() {
                            applyAll(error, this, arguments);
                            callback();
                        },
                        complete: function() {
                            applyAll(complete, this, arguments);
                            t.popLoading();
                        }
                    }));
                } else {
                    callback();
                }
            }
        }
        function addEventSource(sourceInput) {
            var source = buildEventSource(sourceInput);
            if (source) {
                sources.push(source);
                fetchEventSources([ source ], "add");
            }
        }
        function buildEventSource(sourceInput) {
            var normalizers = FC.sourceNormalizers;
            var source;
            var i;
            if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
                source = {
                    events: sourceInput
                };
            } else if (typeof sourceInput === "string") {
                source = {
                    url: sourceInput
                };
            } else if (typeof sourceInput === "object") {
                source = $.extend({}, sourceInput);
            }
            if (source) {
                if (source.className) {
                    if (typeof source.className === "string") {
                        source.className = source.className.split(/\s+/);
                    }
                } else {
                    source.className = [];
                }
                if ($.isArray(source.events)) {
                    source.origArray = source.events;
                    source.events = $.map(source.events, function(eventInput) {
                        return buildEventFromInput(eventInput, source);
                    });
                }
                for (i = 0; i < normalizers.length; i++) {
                    normalizers[i].call(t, source);
                }
                return source;
            }
        }
        function removeEventSource(matchInput) {
            removeSpecificEventSources(getEventSourcesByMatch(matchInput));
        }
        function removeEventSources(matchInputs) {
            if (matchInputs == null) {
                removeSpecificEventSources(sources, true);
            } else {
                removeSpecificEventSources(getEventSourcesByMatchArray(matchInputs));
            }
        }
        function removeSpecificEventSources(targetSources, isAll) {
            var i;
            for (i = 0; i < targetSources.length; i++) {
                rejectEventSource(targetSources[i]);
            }
            if (isAll) {
                sources = [];
                cache = [];
            } else {
                sources = $.grep(sources, function(source) {
                    for (i = 0; i < targetSources.length; i++) {
                        if (source === targetSources[i]) {
                            return false;
                        }
                    }
                    return true;
                });
                cache = excludeEventsBySources(cache, targetSources);
            }
            reportEvents(cache);
        }
        function getEventSources() {
            return sources.slice(1);
        }
        function getEventSourceById(id) {
            return $.grep(sources, function(source) {
                return source.id && source.id === id;
            })[0];
        }
        function getEventSourcesByMatchArray(matchInputs) {
            if (!matchInputs) {
                matchInputs = [];
            } else if (!$.isArray(matchInputs)) {
                matchInputs = [ matchInputs ];
            }
            var matchingSources = [];
            var i;
            for (i = 0; i < matchInputs.length; i++) {
                matchingSources.push.apply(matchingSources, getEventSourcesByMatch(matchInputs[i]));
            }
            return matchingSources;
        }
        function getEventSourcesByMatch(matchInput) {
            var i, source;
            for (i = 0; i < sources.length; i++) {
                source = sources[i];
                if (source === matchInput) {
                    return [ source ];
                }
            }
            source = getEventSourceById(matchInput);
            if (source) {
                return [ source ];
            }
            return $.grep(sources, function(source) {
                return isSourcesEquivalent(matchInput, source);
            });
        }
        function isSourcesEquivalent(source1, source2) {
            return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
        }
        function getSourcePrimitive(source) {
            return (typeof source === "object" ? source.origArray || source.googleCalendarId || source.url || source.events : null) || source;
        }
        function excludeEventsBySources(specificEvents, specificSources) {
            return $.grep(specificEvents, function(event) {
                for (var i = 0; i < specificSources.length; i++) {
                    if (event.source === specificSources[i]) {
                        return false;
                    }
                }
                return true;
            });
        }
        function updateEvent(event) {
            event.start = t.moment(event.start);
            if (event.end) {
                event.end = t.moment(event.end);
            } else {
                event.end = null;
            }
            mutateEvent(event, getMiscEventProps(event));
            reportEvents(cache);
        }
        function getMiscEventProps(event) {
            var props = {};
            $.each(event, function(name, val) {
                if (isMiscEventPropName(name)) {
                    if (val !== undefined && isAtomic(val)) {
                        props[name] = val;
                    }
                }
            });
            return props;
        }
        function isMiscEventPropName(name) {
            return !/^_|^(id|allDay|start|end)$/.test(name);
        }
        function renderEvent(eventInput, stick) {
            var abstractEvent = buildEventFromInput(eventInput);
            var events;
            var i, event;
            if (abstractEvent) {
                events = expandEvent(abstractEvent);
                for (i = 0; i < events.length; i++) {
                    event = events[i];
                    if (!event.source) {
                        if (stick) {
                            stickySource.events.push(event);
                            event.source = stickySource;
                        }
                        cache.push(event);
                    }
                }
                reportEvents(cache);
                return events;
            }
            return [];
        }
        function removeEvents(filter) {
            var eventID;
            var i;
            if (filter == null) {
                filter = function() {
                    return true;
                };
            } else if (!$.isFunction(filter)) {
                eventID = filter + "";
                filter = function(event) {
                    return event._id == eventID;
                };
            }
            cache = $.grep(cache, filter, true);
            for (i = 0; i < sources.length; i++) {
                if ($.isArray(sources[i].events)) {
                    sources[i].events = $.grep(sources[i].events, filter, true);
                }
            }
            reportEvents(cache);
        }
        function clientEvents(filter) {
            if ($.isFunction(filter)) {
                return $.grep(cache, filter);
            } else if (filter != null) {
                filter += "";
                return $.grep(cache, function(e) {
                    return e._id == filter;
                });
            }
            return cache;
        }
        t.rezoneArrayEventSources = function() {
            var i;
            var events;
            var j;
            for (i = 0; i < sources.length; i++) {
                events = sources[i].events;
                if ($.isArray(events)) {
                    for (j = 0; j < events.length; j++) {
                        rezoneEventDates(events[j]);
                    }
                }
            }
        };
        function rezoneEventDates(event) {
            event.start = t.moment(event.start);
            if (event.end) {
                event.end = t.moment(event.end);
            }
            backupEventDates(event);
        }
        function buildEventFromInput(input, source) {
            var out = {};
            var start, end;
            var allDay;
            if (t.options.eventDataTransform) {
                input = t.options.eventDataTransform(input);
            }
            if (source && source.eventDataTransform) {
                input = source.eventDataTransform(input);
            }
            $.extend(out, input);
            if (source) {
                out.source = source;
            }
            out._id = input._id || (input.id === undefined ? "_fc" + eventGUID++ : input.id + "");
            if (input.className) {
                if (typeof input.className == "string") {
                    out.className = input.className.split(/\s+/);
                } else {
                    out.className = input.className;
                }
            } else {
                out.className = [];
            }
            start = input.start || input.date;
            end = input.end;
            if (isTimeString(start)) {
                start = moment.duration(start);
            }
            if (isTimeString(end)) {
                end = moment.duration(end);
            }
            if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {
                out.start = start ? moment.duration(start) : null;
                out.end = end ? moment.duration(end) : null;
                out._recurring = true;
            } else {
                if (start) {
                    start = t.moment(start);
                    if (!start.isValid()) {
                        return false;
                    }
                }
                if (end) {
                    end = t.moment(end);
                    if (!end.isValid()) {
                        end = null;
                    }
                }
                allDay = input.allDay;
                if (allDay === undefined) {
                    allDay = firstDefined(source ? source.allDayDefault : undefined, t.options.allDayDefault);
                }
                assignDatesToEvent(start, end, allDay, out);
            }
            t.normalizeEvent(out);
            return out;
        }
        t.buildEventFromInput = buildEventFromInput;
        function assignDatesToEvent(start, end, allDay, event) {
            event.start = start;
            event.end = end;
            event.allDay = allDay;
            normalizeEventDates(event);
            backupEventDates(event);
        }
        function normalizeEventDates(eventProps) {
            normalizeEventTimes(eventProps);
            if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {
                eventProps.end = null;
            }
            if (!eventProps.end) {
                if (t.options.forceEventDuration) {
                    eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);
                } else {
                    eventProps.end = null;
                }
            }
        }
        function normalizeEventTimes(eventProps) {
            if (eventProps.allDay == null) {
                eventProps.allDay = !(eventProps.start.hasTime() || eventProps.end && eventProps.end.hasTime());
            }
            if (eventProps.allDay) {
                eventProps.start.stripTime();
                if (eventProps.end) {
                    eventProps.end.stripTime();
                }
            } else {
                if (!eventProps.start.hasTime()) {
                    eventProps.start = t.applyTimezone(eventProps.start.time(0));
                }
                if (eventProps.end && !eventProps.end.hasTime()) {
                    eventProps.end = t.applyTimezone(eventProps.end.time(0));
                }
            }
        }
        function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
            var events = [];
            var dowHash;
            var dow;
            var i;
            var date;
            var startTime, endTime;
            var start, end;
            var event;
            _rangeStart = _rangeStart || rangeStart;
            _rangeEnd = _rangeEnd || rangeEnd;
            if (abstractEvent) {
                if (abstractEvent._recurring) {
                    if (dow = abstractEvent.dow) {
                        dowHash = {};
                        for (i = 0; i < dow.length; i++) {
                            dowHash[dow[i]] = true;
                        }
                    }
                    date = _rangeStart.clone().stripTime();
                    while (date.isBefore(_rangeEnd)) {
                        if (!dowHash || dowHash[date.day()]) {
                            startTime = abstractEvent.start;
                            endTime = abstractEvent.end;
                            start = date.clone();
                            end = null;
                            if (startTime) {
                                start = start.time(startTime);
                            }
                            if (endTime) {
                                end = date.clone().time(endTime);
                            }
                            event = $.extend({}, abstractEvent);
                            assignDatesToEvent(start, end, !startTime && !endTime, event);
                            events.push(event);
                        }
                        date.add(1, "days");
                    }
                } else {
                    events.push(abstractEvent);
                }
            }
            return events;
        }
        t.expandEvent = expandEvent;
        function mutateEvent(event, newProps, largeUnit) {
            var miscProps = {};
            var oldProps;
            var clearEnd;
            var startDelta;
            var endDelta;
            var durationDelta;
            var undoFunc;
            function diffDates(date1, date0) {
                if (largeUnit) {
                    return diffByUnit(date1, date0, largeUnit);
                } else if (newProps.allDay) {
                    return diffDay(date1, date0);
                } else {
                    return diffDayTime(date1, date0);
                }
            }
            newProps = newProps || {};
            if (!newProps.start) {
                newProps.start = event.start.clone();
            }
            if (newProps.end === undefined) {
                newProps.end = event.end ? event.end.clone() : null;
            }
            if (newProps.allDay == null) {
                newProps.allDay = event.allDay;
            }
            normalizeEventDates(newProps);
            oldProps = {
                start: event._start.clone(),
                end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
                allDay: newProps.allDay
            };
            normalizeEventDates(oldProps);
            clearEnd = event._end !== null && newProps.end === null;
            startDelta = diffDates(newProps.start, oldProps.start);
            if (newProps.end) {
                endDelta = diffDates(newProps.end, oldProps.end);
                durationDelta = endDelta.subtract(startDelta);
            } else {
                durationDelta = null;
            }
            $.each(newProps, function(name, val) {
                if (isMiscEventPropName(name)) {
                    if (val !== undefined) {
                        miscProps[name] = val;
                    }
                }
            });
            undoFunc = mutateEvents(clientEvents(event._id), clearEnd, newProps.allDay, startDelta, durationDelta, miscProps);
            return {
                dateDelta: startDelta,
                durationDelta: durationDelta,
                undo: undoFunc
            };
        }
        function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
            var isAmbigTimezone = t.getIsAmbigTimezone();
            var undoFunctions = [];
            if (dateDelta && !dateDelta.valueOf()) {
                dateDelta = null;
            }
            if (durationDelta && !durationDelta.valueOf()) {
                durationDelta = null;
            }
            $.each(events, function(i, event) {
                var oldProps;
                var newProps;
                oldProps = {
                    start: event.start.clone(),
                    end: event.end ? event.end.clone() : null,
                    allDay: event.allDay
                };
                $.each(miscProps, function(name) {
                    oldProps[name] = event[name];
                });
                newProps = {
                    start: event._start,
                    end: event._end,
                    allDay: allDay
                };
                normalizeEventDates(newProps);
                if (clearEnd) {
                    newProps.end = null;
                } else if (durationDelta && !newProps.end) {
                    newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
                }
                if (dateDelta) {
                    newProps.start.add(dateDelta);
                    if (newProps.end) {
                        newProps.end.add(dateDelta);
                    }
                }
                if (durationDelta) {
                    newProps.end.add(durationDelta);
                }
                if (isAmbigTimezone && !newProps.allDay && (dateDelta || durationDelta)) {
                    newProps.start.stripZone();
                    if (newProps.end) {
                        newProps.end.stripZone();
                    }
                }
                $.extend(event, miscProps, newProps);
                backupEventDates(event);
                undoFunctions.push(function() {
                    $.extend(event, oldProps);
                    backupEventDates(event);
                });
            });
            return function() {
                for (var i = 0; i < undoFunctions.length; i++) {
                    undoFunctions[i]();
                }
            };
        }
        t.getEventCache = function() {
            return cache;
        };
    }
    Calendar.prototype.normalizeEvent = function(event) {};
    Calendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {
        var eventStart = outerSpan.start.clone().stripZone();
        var eventEnd = this.getEventEnd(outerSpan).stripZone();
        return innerSpan.start >= eventStart && innerSpan.end <= eventEnd;
    };
    Calendar.prototype.getPeerEvents = function(span, event) {
        var cache = this.getEventCache();
        var peerEvents = [];
        var i, otherEvent;
        for (i = 0; i < cache.length; i++) {
            otherEvent = cache[i];
            if (!event || event._id !== otherEvent._id) {
                peerEvents.push(otherEvent);
            }
        }
        return peerEvents;
    };
    function backupEventDates(event) {
        event._allDay = event.allDay;
        event._start = event.start.clone();
        event._end = event.end ? event.end.clone() : null;
    }
    Calendar.prototype.isEventSpanAllowed = function(span, event) {
        var source = event.source || {};
        var constraint = firstDefined(event.constraint, source.constraint, this.options.eventConstraint);
        var overlap = firstDefined(event.overlap, source.overlap, this.options.eventOverlap);
        return this.isSpanAllowed(span, constraint, overlap, event) && (!this.options.eventAllow || this.options.eventAllow(span, event) !== false);
    };
    Calendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {
        var eventInput;
        var event;
        if (eventProps) {
            eventInput = $.extend({}, eventProps, eventLocation);
            event = this.expandEvent(this.buildEventFromInput(eventInput))[0];
        }
        if (event) {
            return this.isEventSpanAllowed(eventSpan, event);
        } else {
            return this.isSelectionSpanAllowed(eventSpan);
        }
    };
    Calendar.prototype.isSelectionSpanAllowed = function(span) {
        return this.isSpanAllowed(span, this.options.selectConstraint, this.options.selectOverlap) && (!this.options.selectAllow || this.options.selectAllow(span) !== false);
    };
    Calendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {
        var constraintEvents;
        var anyContainment;
        var peerEvents;
        var i, peerEvent;
        var peerOverlap;
        if (constraint != null) {
            constraintEvents = this.constraintToEvents(constraint);
            if (constraintEvents) {
                anyContainment = false;
                for (i = 0; i < constraintEvents.length; i++) {
                    if (this.spanContainsSpan(constraintEvents[i], span)) {
                        anyContainment = true;
                        break;
                    }
                }
                if (!anyContainment) {
                    return false;
                }
            }
        }
        peerEvents = this.getPeerEvents(span, event);
        for (i = 0; i < peerEvents.length; i++) {
            peerEvent = peerEvents[i];
            if (this.eventIntersectsRange(peerEvent, span)) {
                if (overlap === false) {
                    return false;
                } else if (typeof overlap === "function" && !overlap(peerEvent, event)) {
                    return false;
                }
                if (event) {
                    peerOverlap = firstDefined(peerEvent.overlap, (peerEvent.source || {}).overlap);
                    if (peerOverlap === false) {
                        return false;
                    }
                    if (typeof peerOverlap === "function" && !peerOverlap(event, peerEvent)) {
                        return false;
                    }
                }
            }
        }
        return true;
    };
    Calendar.prototype.constraintToEvents = function(constraintInput) {
        if (constraintInput === "businessHours") {
            return this.getCurrentBusinessHourEvents();
        }
        if (typeof constraintInput === "object") {
            if (constraintInput.start != null) {
                return this.expandEvent(this.buildEventFromInput(constraintInput));
            } else {
                return null;
            }
        }
        return this.clientEvents(constraintInput);
    };
    Calendar.prototype.eventIntersectsRange = function(event, range) {
        var eventStart = event.start.clone().stripZone();
        var eventEnd = this.getEventEnd(event).stripZone();
        return range.start < eventEnd && range.end > eventStart;
    };
    var BUSINESS_HOUR_EVENT_DEFAULTS = {
        id: "_fcBusinessHours",
        start: "09:00",
        end: "17:00",
        dow: [ 1, 2, 3, 4, 5 ],
        rendering: "inverse-background"
    };
    Calendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {
        return this.computeBusinessHourEvents(wholeDay, this.options.businessHours);
    };
    Calendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {
        if (input === true) {
            return this.expandBusinessHourEvents(wholeDay, [ {} ]);
        } else if ($.isPlainObject(input)) {
            return this.expandBusinessHourEvents(wholeDay, [ input ]);
        } else if ($.isArray(input)) {
            return this.expandBusinessHourEvents(wholeDay, input, true);
        } else {
            return [];
        }
    };
    Calendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {
        var view = this.getView();
        var events = [];
        var i, input;
        for (i = 0; i < inputs.length; i++) {
            input = inputs[i];
            if (ignoreNoDow && !input.dow) {
                continue;
            }
            input = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);
            if (wholeDay) {
                input.start = null;
                input.end = null;
            }
            events.push.apply(events, this.expandEvent(this.buildEventFromInput(input), view.start, view.end));
        }
        return events;
    };
    var BasicView = FC.BasicView = View.extend({
        scroller: null,
        dayGridClass: DayGrid,
        dayGrid: null,
        dayNumbersVisible: false,
        colWeekNumbersVisible: false,
        cellWeekNumbersVisible: false,
        weekNumberWidth: null,
        headContainerEl: null,
        headRowEl: null,
        initialize: function() {
            this.dayGrid = this.instantiateDayGrid();
            this.scroller = new Scroller({
                overflowX: "hidden",
                overflowY: "auto"
            });
        },
        instantiateDayGrid: function() {
            var subclass = this.dayGridClass.extend(basicDayGridMethods);
            return new subclass(this);
        },
        setRange: function(range) {
            View.prototype.setRange.call(this, range);
            this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit);
            this.dayGrid.setRange(range);
        },
        computeRange: function(date) {
            var range = View.prototype.computeRange.call(this, date);
            if (/year|month/.test(range.intervalUnit)) {
                range.start.startOf("week");
                range.start = this.skipHiddenDays(range.start);
                if (range.end.weekday()) {
                    range.end.add(1, "week").startOf("week");
                    range.end = this.skipHiddenDays(range.end, -1, true);
                }
            }
            return range;
        },
        renderDates: function() {
            this.dayNumbersVisible = this.dayGrid.rowCnt > 1;
            if (this.opt("weekNumbers")) {
                if (this.opt("weekNumbersWithinDays")) {
                    this.cellWeekNumbersVisible = true;
                    this.colWeekNumbersVisible = false;
                } else {
                    this.cellWeekNumbersVisible = false;
                    this.colWeekNumbersVisible = true;
                }
            }
            this.dayGrid.numbersVisible = this.dayNumbersVisible || this.cellWeekNumbersVisible || this.colWeekNumbersVisible;
            this.el.addClass("fc-basic-view").html(this.renderSkeletonHtml());
            this.renderHead();
            this.scroller.render();
            var dayGridContainerEl = this.scroller.el.addClass("fc-day-grid-container");
            var dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
            this.el.find(".fc-body > tr > td").append(dayGridContainerEl);
            this.dayGrid.setElement(dayGridEl);
            this.dayGrid.renderDates(this.hasRigidRows());
        },
        renderHead: function() {
            this.headContainerEl = this.el.find(".fc-head-container").html(this.dayGrid.renderHeadHtml());
            this.headRowEl = this.headContainerEl.find(".fc-row");
        },
        unrenderDates: function() {
            this.dayGrid.unrenderDates();
            this.dayGrid.removeElement();
            this.scroller.destroy();
        },
        renderBusinessHours: function() {
            this.dayGrid.renderBusinessHours();
        },
        unrenderBusinessHours: function() {
            this.dayGrid.unrenderBusinessHours();
        },
        renderSkeletonHtml: function() {
            return "" + "<table>" + '<thead class="fc-head">' + "<tr>" + '<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' + "</tr>" + "</thead>" + '<tbody class="fc-body">' + "<tr>" + '<td class="' + this.widgetContentClass + '"></td>' + "</tr>" + "</tbody>" + "</table>";
        },
        weekNumberStyleAttr: function() {
            if (this.weekNumberWidth !== null) {
                return 'style="width:' + this.weekNumberWidth + 'px"';
            }
            return "";
        },
        hasRigidRows: function() {
            var eventLimit = this.opt("eventLimit");
            return eventLimit && typeof eventLimit !== "number";
        },
        updateWidth: function() {
            if (this.colWeekNumbersVisible) {
                this.weekNumberWidth = matchCellWidths(this.el.find(".fc-week-number"));
            }
        },
        setHeight: function(totalHeight, isAuto) {
            var eventLimit = this.opt("eventLimit");
            var scrollerHeight;
            var scrollbarWidths;
            this.scroller.clear();
            uncompensateScroll(this.headRowEl);
            this.dayGrid.removeSegPopover();
            if (eventLimit && typeof eventLimit === "number") {
                this.dayGrid.limitRows(eventLimit);
            }
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.setGridHeight(scrollerHeight, isAuto);
            if (eventLimit && typeof eventLimit !== "number") {
                this.dayGrid.limitRows(eventLimit);
            }
            if (!isAuto) {
                this.scroller.setHeight(scrollerHeight);
                scrollbarWidths = this.scroller.getScrollbarWidths();
                if (scrollbarWidths.left || scrollbarWidths.right) {
                    compensateScroll(this.headRowEl, scrollbarWidths);
                    scrollerHeight = this.computeScrollerHeight(totalHeight);
                    this.scroller.setHeight(scrollerHeight);
                }
                this.scroller.lockOverflow(scrollbarWidths);
            }
        },
        computeScrollerHeight: function(totalHeight) {
            return totalHeight - subtractInnerElHeight(this.el, this.scroller.el);
        },
        setGridHeight: function(height, isAuto) {
            if (isAuto) {
                undistributeHeight(this.dayGrid.rowEls);
            } else {
                distributeHeight(this.dayGrid.rowEls, height, true);
            }
        },
        queryScroll: function() {
            return this.scroller.getScrollTop();
        },
        setScroll: function(top) {
            this.scroller.setScrollTop(top);
        },
        prepareHits: function() {
            this.dayGrid.prepareHits();
        },
        releaseHits: function() {
            this.dayGrid.releaseHits();
        },
        queryHit: function(left, top) {
            return this.dayGrid.queryHit(left, top);
        },
        getHitSpan: function(hit) {
            return this.dayGrid.getHitSpan(hit);
        },
        getHitEl: function(hit) {
            return this.dayGrid.getHitEl(hit);
        },
        renderEvents: function(events) {
            this.dayGrid.renderEvents(events);
            this.updateHeight();
        },
        getEventSegs: function() {
            return this.dayGrid.getEventSegs();
        },
        unrenderEvents: function() {
            this.dayGrid.unrenderEvents();
        },
        renderDrag: function(dropLocation, seg) {
            return this.dayGrid.renderDrag(dropLocation, seg);
        },
        unrenderDrag: function() {
            this.dayGrid.unrenderDrag();
        },
        renderSelection: function(span) {
            this.dayGrid.renderSelection(span);
        },
        unrenderSelection: function() {
            this.dayGrid.unrenderSelection();
        }
    });
    var basicDayGridMethods = {
        renderHeadIntroHtml: function() {
            var view = this.view;
            if (view.colWeekNumbersVisible) {
                return "" + '<th class="fc-week-number ' + view.widgetHeaderClass + '" ' + view.weekNumberStyleAttr() + ">" + "<span>" + htmlEscape(view.opt("weekNumberTitle")) + "</span>" + "</th>";
            }
            return "";
        },
        renderNumberIntroHtml: function(row) {
            var view = this.view;
            var weekStart = this.getCellDate(row, 0);
            if (view.colWeekNumbersVisible) {
                return "" + '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + ">" + view.buildGotoAnchorHtml({
                    date: weekStart,
                    type: "week",
                    forceOff: this.colCnt === 1
                }, weekStart.format("w")) + "</td>";
            }
            return "";
        },
        renderBgIntroHtml: function() {
            var view = this.view;
            if (view.colWeekNumbersVisible) {
                return '<td class="fc-week-number ' + view.widgetContentClass + '" ' + view.weekNumberStyleAttr() + "></td>";
            }
            return "";
        },
        renderIntroHtml: function() {
            var view = this.view;
            if (view.colWeekNumbersVisible) {
                return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + "></td>";
            }
            return "";
        }
    };
    var MonthView = FC.MonthView = BasicView.extend({
        computeRange: function(date) {
            var range = BasicView.prototype.computeRange.call(this, date);
            var rowCnt;
            if (this.isFixedWeeks()) {
                rowCnt = Math.ceil(range.end.diff(range.start, "weeks", true));
                range.end.add(6 - rowCnt, "weeks");
            }
            return range;
        },
        setGridHeight: function(height, isAuto) {
            if (isAuto) {
                height *= this.rowCnt / 6;
            }
            distributeHeight(this.dayGrid.rowEls, height, !isAuto);
        },
        isFixedWeeks: function() {
            return this.opt("fixedWeekCount");
        }
    });
    fcViews.basic = {
        class: BasicView
    };
    fcViews.basicDay = {
        type: "basic",
        duration: {
            days: 1
        }
    };
    fcViews.basicWeek = {
        type: "basic",
        duration: {
            weeks: 1
        }
    };
    fcViews.month = {
        class: MonthView,
        duration: {
            months: 1
        },
        defaults: {
            fixedWeekCount: true
        }
    };
    var AgendaView = FC.AgendaView = View.extend({
        scroller: null,
        timeGridClass: TimeGrid,
        timeGrid: null,
        dayGridClass: DayGrid,
        dayGrid: null,
        axisWidth: null,
        headContainerEl: null,
        noScrollRowEls: null,
        bottomRuleEl: null,
        initialize: function() {
            this.timeGrid = this.instantiateTimeGrid();
            if (this.opt("allDaySlot")) {
                this.dayGrid = this.instantiateDayGrid();
            }
            this.scroller = new Scroller({
                overflowX: "hidden",
                overflowY: "auto"
            });
        },
        instantiateTimeGrid: function() {
            var subclass = this.timeGridClass.extend(agendaTimeGridMethods);
            return new subclass(this);
        },
        instantiateDayGrid: function() {
            var subclass = this.dayGridClass.extend(agendaDayGridMethods);
            return new subclass(this);
        },
        setRange: function(range) {
            View.prototype.setRange.call(this, range);
            this.timeGrid.setRange(range);
            if (this.dayGrid) {
                this.dayGrid.setRange(range);
            }
        },
        renderDates: function() {
            this.el.addClass("fc-agenda-view").html(this.renderSkeletonHtml());
            this.renderHead();
            this.scroller.render();
            var timeGridWrapEl = this.scroller.el.addClass("fc-time-grid-container");
            var timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
            this.el.find(".fc-body > tr > td").append(timeGridWrapEl);
            this.timeGrid.setElement(timeGridEl);
            this.timeGrid.renderDates();
            this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>').appendTo(this.timeGrid.el);
            if (this.dayGrid) {
                this.dayGrid.setElement(this.el.find(".fc-day-grid"));
                this.dayGrid.renderDates();
                this.dayGrid.bottomCoordPadding = this.dayGrid.el.next("hr").outerHeight();
            }
            this.noScrollRowEls = this.el.find(".fc-row:not(.fc-scroller *)");
        },
        renderHead: function() {
            this.headContainerEl = this.el.find(".fc-head-container").html(this.timeGrid.renderHeadHtml());
        },
        unrenderDates: function() {
            this.timeGrid.unrenderDates();
            this.timeGrid.removeElement();
            if (this.dayGrid) {
                this.dayGrid.unrenderDates();
                this.dayGrid.removeElement();
            }
            this.scroller.destroy();
        },
        renderSkeletonHtml: function() {
            return "" + "<table>" + '<thead class="fc-head">' + "<tr>" + '<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' + "</tr>" + "</thead>" + '<tbody class="fc-body">' + "<tr>" + '<td class="' + this.widgetContentClass + '">' + (this.dayGrid ? '<div class="fc-day-grid"/>' + '<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' : "") + "</td>" + "</tr>" + "</tbody>" + "</table>";
        },
        axisStyleAttr: function() {
            if (this.axisWidth !== null) {
                return 'style="width:' + this.axisWidth + 'px"';
            }
            return "";
        },
        renderBusinessHours: function() {
            this.timeGrid.renderBusinessHours();
            if (this.dayGrid) {
                this.dayGrid.renderBusinessHours();
            }
        },
        unrenderBusinessHours: function() {
            this.timeGrid.unrenderBusinessHours();
            if (this.dayGrid) {
                this.dayGrid.unrenderBusinessHours();
            }
        },
        getNowIndicatorUnit: function() {
            return this.timeGrid.getNowIndicatorUnit();
        },
        renderNowIndicator: function(date) {
            this.timeGrid.renderNowIndicator(date);
        },
        unrenderNowIndicator: function() {
            this.timeGrid.unrenderNowIndicator();
        },
        updateSize: function(isResize) {
            this.timeGrid.updateSize(isResize);
            View.prototype.updateSize.call(this, isResize);
        },
        updateWidth: function() {
            this.axisWidth = matchCellWidths(this.el.find(".fc-axis"));
        },
        setHeight: function(totalHeight, isAuto) {
            var eventLimit;
            var scrollerHeight;
            var scrollbarWidths;
            this.bottomRuleEl.hide();
            this.scroller.clear();
            uncompensateScroll(this.noScrollRowEls);
            if (this.dayGrid) {
                this.dayGrid.removeSegPopover();
                eventLimit = this.opt("eventLimit");
                if (eventLimit && typeof eventLimit !== "number") {
                    eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT;
                }
                if (eventLimit) {
                    this.dayGrid.limitRows(eventLimit);
                }
            }
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
                scrollbarWidths = this.scroller.getScrollbarWidths();
                if (scrollbarWidths.left || scrollbarWidths.right) {
                    compensateScroll(this.noScrollRowEls, scrollbarWidths);
                    scrollerHeight = this.computeScrollerHeight(totalHeight);
                    this.scroller.setHeight(scrollerHeight);
                }
                this.scroller.lockOverflow(scrollbarWidths);
                if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
                    this.bottomRuleEl.show();
                }
            }
        },
        computeScrollerHeight: function(totalHeight) {
            return totalHeight - subtractInnerElHeight(this.el, this.scroller.el);
        },
        computeInitialScroll: function() {
            var scrollTime = moment.duration(this.opt("scrollTime"));
            var top = this.timeGrid.computeTimeTop(scrollTime);
            top = Math.ceil(top);
            if (top) {
                top++;
            }
            return top;
        },
        queryScroll: function() {
            return this.scroller.getScrollTop();
        },
        setScroll: function(top) {
            this.scroller.setScrollTop(top);
        },
        prepareHits: function() {
            this.timeGrid.prepareHits();
            if (this.dayGrid) {
                this.dayGrid.prepareHits();
            }
        },
        releaseHits: function() {
            this.timeGrid.releaseHits();
            if (this.dayGrid) {
                this.dayGrid.releaseHits();
            }
        },
        queryHit: function(left, top) {
            var hit = this.timeGrid.queryHit(left, top);
            if (!hit && this.dayGrid) {
                hit = this.dayGrid.queryHit(left, top);
            }
            return hit;
        },
        getHitSpan: function(hit) {
            return hit.component.getHitSpan(hit);
        },
        getHitEl: function(hit) {
            return hit.component.getHitEl(hit);
        },
        renderEvents: function(events) {
            var dayEvents = [];
            var timedEvents = [];
            var daySegs = [];
            var timedSegs;
            var i;
            for (i = 0; i < events.length; i++) {
                if (events[i].allDay) {
                    dayEvents.push(events[i]);
                } else {
                    timedEvents.push(events[i]);
                }
            }
            timedSegs = this.timeGrid.renderEvents(timedEvents);
            if (this.dayGrid) {
                daySegs = this.dayGrid.renderEvents(dayEvents);
            }
            this.updateHeight();
        },
        getEventSegs: function() {
            return this.timeGrid.getEventSegs().concat(this.dayGrid ? this.dayGrid.getEventSegs() : []);
        },
        unrenderEvents: function() {
            this.timeGrid.unrenderEvents();
            if (this.dayGrid) {
                this.dayGrid.unrenderEvents();
            }
        },
        renderDrag: function(dropLocation, seg) {
            if (dropLocation.start.hasTime()) {
                return this.timeGrid.renderDrag(dropLocation, seg);
            } else if (this.dayGrid) {
                return this.dayGrid.renderDrag(dropLocation, seg);
            }
        },
        unrenderDrag: function() {
            this.timeGrid.unrenderDrag();
            if (this.dayGrid) {
                this.dayGrid.unrenderDrag();
            }
        },
        renderSelection: function(span) {
            if (span.start.hasTime() || span.end.hasTime()) {
                this.timeGrid.renderSelection(span);
            } else if (this.dayGrid) {
                this.dayGrid.renderSelection(span);
            }
        },
        unrenderSelection: function() {
            this.timeGrid.unrenderSelection();
            if (this.dayGrid) {
                this.dayGrid.unrenderSelection();
            }
        }
    });
    var agendaTimeGridMethods = {
        renderHeadIntroHtml: function() {
            var view = this.view;
            var weekText;
            if (view.opt("weekNumbers")) {
                weekText = this.start.format(view.opt("smallWeekFormat"));
                return "" + '<th class="fc-axis fc-week-number ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + ">" + view.buildGotoAnchorHtml({
                    date: this.start,
                    type: "week",
                    forceOff: this.colCnt > 1
                }, htmlEscape(weekText)) + "</th>";
            } else {
                return '<th class="fc-axis ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + "></th>";
            }
        },
        renderBgIntroHtml: function() {
            var view = this.view;
            return '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + "></td>";
        },
        renderIntroHtml: function() {
            var view = this.view;
            return '<td class="fc-axis" ' + view.axisStyleAttr() + "></td>";
        }
    };
    var agendaDayGridMethods = {
        renderBgIntroHtml: function() {
            var view = this.view;
            return "" + '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + ">" + "<span>" + view.getAllDayHtml() + "</span>" + "</td>";
        },
        renderIntroHtml: function() {
            var view = this.view;
            return '<td class="fc-axis" ' + view.axisStyleAttr() + "></td>";
        }
    };
    var AGENDA_ALL_DAY_EVENT_LIMIT = 5;
    var AGENDA_STOCK_SUB_DURATIONS = [ {
        hours: 1
    }, {
        minutes: 30
    }, {
        minutes: 15
    }, {
        seconds: 30
    }, {
        seconds: 15
    } ];
    fcViews.agenda = {
        class: AgendaView,
        defaults: {
            allDaySlot: true,
            slotDuration: "00:30:00",
            minTime: "00:00:00",
            maxTime: "24:00:00",
            slotEventOverlap: true
        }
    };
    fcViews.agendaDay = {
        type: "agenda",
        duration: {
            days: 1
        }
    };
    fcViews.agendaWeek = {
        type: "agenda",
        duration: {
            weeks: 1
        }
    };
    var ListView = View.extend({
        grid: null,
        scroller: null,
        initialize: function() {
            this.grid = new ListViewGrid(this);
            this.scroller = new Scroller({
                overflowX: "hidden",
                overflowY: "auto"
            });
        },
        setRange: function(range) {
            View.prototype.setRange.call(this, range);
            this.grid.setRange(range);
        },
        renderSkeleton: function() {
            this.el.addClass("fc-list-view " + this.widgetContentClass);
            this.scroller.render();
            this.scroller.el.appendTo(this.el);
            this.grid.setElement(this.scroller.scrollEl);
        },
        unrenderSkeleton: function() {
            this.scroller.destroy();
        },
        setHeight: function(totalHeight, isAuto) {
            this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
        },
        computeScrollerHeight: function(totalHeight) {
            return totalHeight - subtractInnerElHeight(this.el, this.scroller.el);
        },
        renderEvents: function(events) {
            this.grid.renderEvents(events);
        },
        unrenderEvents: function() {
            this.grid.unrenderEvents();
        },
        isEventResizable: function(event) {
            return false;
        },
        isEventDraggable: function(event) {
            return false;
        }
    });
    var ListViewGrid = Grid.extend({
        segSelector: ".fc-list-item",
        hasDayInteractions: false,
        spanToSegs: function(span) {
            var view = this.view;
            var dayStart = view.start.clone().time(0);
            var dayIndex = 0;
            var seg;
            var segs = [];
            while (dayStart < view.end) {
                seg = intersectRanges(span, {
                    start: dayStart,
                    end: dayStart.clone().add(1, "day")
                });
                if (seg) {
                    seg.dayIndex = dayIndex;
                    segs.push(seg);
                }
                dayStart.add(1, "day");
                dayIndex++;
                if (seg && !seg.isEnd && span.end.hasTime() && span.end < dayStart.clone().add(this.view.nextDayThreshold)) {
                    seg.end = span.end.clone();
                    seg.isEnd = true;
                    break;
                }
            }
            return segs;
        },
        computeEventTimeFormat: function() {
            return this.view.opt("mediumTimeFormat");
        },
        handleSegClick: function(seg, ev) {
            var url;
            Grid.prototype.handleSegClick.apply(this, arguments);
            if (!$(ev.target).closest("a[href]").length) {
                url = seg.event.url;
                if (url && !ev.isDefaultPrevented()) {
                    window.location.href = url;
                }
            }
        },
        renderFgSegs: function(segs) {
            segs = this.renderFgSegEls(segs);
            if (!segs.length) {
                this.renderEmptyMessage();
            } else {
                this.renderSegList(segs);
            }
            return segs;
        },
        renderEmptyMessage: function() {
            this.el.html('<div class="fc-list-empty-wrap2">' + '<div class="fc-list-empty-wrap1">' + '<div class="fc-list-empty">' + htmlEscape(this.view.opt("noEventsMessage")) + "</div>" + "</div>" + "</div>");
        },
        renderSegList: function(allSegs) {
            var segsByDay = this.groupSegsByDay(allSegs);
            var dayIndex;
            var daySegs;
            var i;
            var tableEl = $('<table class="fc-list-table"><tbody/></table>');
            var tbodyEl = tableEl.find("tbody");
            for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
                daySegs = segsByDay[dayIndex];
                if (daySegs) {
                    tbodyEl.append(this.dayHeaderHtml(this.view.start.clone().add(dayIndex, "days")));
                    this.sortEventSegs(daySegs);
                    for (i = 0; i < daySegs.length; i++) {
                        tbodyEl.append(daySegs[i].el);
                    }
                }
            }
            this.el.empty().append(tableEl);
        },
        groupSegsByDay: function(segs) {
            var segsByDay = [];
            var i, seg;
            for (i = 0; i < segs.length; i++) {
                seg = segs[i];
                (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
            }
            return segsByDay;
        },
        dayHeaderHtml: function(dayDate) {
            var view = this.view;
            var mainFormat = view.opt("listDayFormat");
            var altFormat = view.opt("listDayAltFormat");
            return '<tr class="fc-list-heading" data-date="' + dayDate.format("YYYY-MM-DD") + '">' + '<td class="' + view.widgetHeaderClass + '" colspan="3">' + (mainFormat ? view.buildGotoAnchorHtml(dayDate, {
                class: "fc-list-heading-main"
            }, htmlEscape(dayDate.format(mainFormat))) : "") + (altFormat ? view.buildGotoAnchorHtml(dayDate, {
                class: "fc-list-heading-alt"
            }, htmlEscape(dayDate.format(altFormat))) : "") + "</td>" + "</tr>";
        },
        fgSegHtml: function(seg) {
            var view = this.view;
            var classes = [ "fc-list-item" ].concat(this.getSegCustomClasses(seg));
            var bgColor = this.getSegBackgroundColor(seg);
            var event = seg.event;
            var url = event.url;
            var timeHtml;
            if (event.allDay) {
                timeHtml = view.getAllDayHtml();
            } else if (view.isMultiDayEvent(event)) {
                if (seg.isStart || seg.isEnd) {
                    timeHtml = htmlEscape(this.getEventTimeText(seg));
                } else {
                    timeHtml = view.getAllDayHtml();
                }
            } else {
                timeHtml = htmlEscape(this.getEventTimeText(event));
            }
            if (url) {
                classes.push("fc-has-url");
            }
            return '<tr class="' + classes.join(" ") + '">' + (this.displayEventTime ? '<td class="fc-list-item-time ' + view.widgetContentClass + '">' + (timeHtml || "") + "</td>" : "") + '<td class="fc-list-item-marker ' + view.widgetContentClass + '">' + '<span class="fc-event-dot"' + (bgColor ? ' style="background-color:' + bgColor + '"' : "") + "></span>" + "</td>" + '<td class="fc-list-item-title ' + view.widgetContentClass + '">' + "<a" + (url ? ' href="' + htmlEscape(url) + '"' : "") + ">" + htmlEscape(seg.event.title || "") + "</a>" + "</td>" + "</tr>";
        }
    });
    fcViews.list = {
        class: ListView,
        buttonTextKey: "list",
        defaults: {
            buttonText: "list",
            listDayFormat: "LL",
            noEventsMessage: "No events to display"
        }
    };
    fcViews.listDay = {
        type: "list",
        duration: {
            days: 1
        },
        defaults: {
            listDayFormat: "dddd"
        }
    };
    fcViews.listWeek = {
        type: "list",
        duration: {
            weeks: 1
        },
        defaults: {
            listDayFormat: "dddd",
            listDayAltFormat: "LL"
        }
    };
    fcViews.listMonth = {
        type: "list",
        duration: {
            month: 1
        },
        defaults: {
            listDayAltFormat: "dddd"
        }
    };
    fcViews.listYear = {
        type: "list",
        duration: {
            year: 1
        },
        defaults: {
            listDayAltFormat: "dddd"
        }
    };
    return FC;
});

(function() {
    "use strict";
    function a() {}
    function b(a, b) {
        for (var c = a.length; c--; ) if (a[c].listener === b) return c;
        return -1;
    }
    function c(a) {
        return function() {
            return this[a].apply(this, arguments);
        };
    }
    var d = a.prototype, e = this, f = e.EventEmitter;
    d.getListeners = function(a) {
        var b, c, d = this._getEvents();
        if ("object" == typeof a) {
            b = {};
            for (c in d) d.hasOwnProperty(c) && a.test(c) && (b[c] = d[c]);
        } else b = d[a] || (d[a] = []);
        return b;
    }, d.flattenListeners = function(a) {
        var b, c = [];
        for (b = 0; b < a.length; b += 1) c.push(a[b].listener);
        return c;
    }, d.getListenersAsObject = function(a) {
        var b, c = this.getListeners(a);
        return c instanceof Array && (b = {}, b[a] = c), b || c;
    }, d.addListener = function(a, c) {
        var d, e = this.getListenersAsObject(a), f = "object" == typeof c;
        for (d in e) e.hasOwnProperty(d) && -1 === b(e[d], c) && e[d].push(f ? c : {
            listener: c,
            once: !1
        });
        return this;
    }, d.on = c("addListener"), d.addOnceListener = function(a, b) {
        return this.addListener(a, {
            listener: b,
            once: !0
        });
    }, d.once = c("addOnceListener"), d.defineEvent = function(a) {
        return this.getListeners(a), this;
    }, d.defineEvents = function(a) {
        for (var b = 0; b < a.length; b += 1) this.defineEvent(a[b]);
        return this;
    }, d.removeListener = function(a, c) {
        var d, e, f = this.getListenersAsObject(a);
        for (e in f) f.hasOwnProperty(e) && (d = b(f[e], c), -1 !== d && f[e].splice(d, 1));
        return this;
    }, d.off = c("removeListener"), d.addListeners = function(a, b) {
        return this.manipulateListeners(!1, a, b);
    }, d.removeListeners = function(a, b) {
        return this.manipulateListeners(!0, a, b);
    }, d.manipulateListeners = function(a, b, c) {
        var d, e, f = a ? this.removeListener : this.addListener, g = a ? this.removeListeners : this.addListeners;
        if ("object" != typeof b || b instanceof RegExp) for (d = c.length; d--; ) f.call(this, b, c[d]); else for (d in b) b.hasOwnProperty(d) && (e = b[d]) && ("function" == typeof e ? f.call(this, d, e) : g.call(this, d, e));
        return this;
    }, d.removeEvent = function(a) {
        var b, c = typeof a, d = this._getEvents();
        if ("string" === c) delete d[a]; else if ("object" === c) for (b in d) d.hasOwnProperty(b) && a.test(b) && delete d[b]; else delete this._events;
        return this;
    }, d.removeAllListeners = c("removeEvent"), d.emitEvent = function(a, b) {
        var c, d, e, f, g = this.getListenersAsObject(a);
        for (e in g) if (g.hasOwnProperty(e)) for (d = g[e].length; d--; ) c = g[e][d], 
        c.once === !0 && this.removeListener(a, c.listener), f = c.listener.apply(this, b || []), 
        f === this._getOnceReturnValue() && this.removeListener(a, c.listener);
        return this;
    }, d.trigger = c("emitEvent"), d.emit = function(a) {
        var b = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(a, b);
    }, d.setOnceReturnValue = function(a) {
        return this._onceReturnValue = a, this;
    }, d._getOnceReturnValue = function() {
        return this.hasOwnProperty("_onceReturnValue") ? this._onceReturnValue : !0;
    }, d._getEvents = function() {
        return this._events || (this._events = {});
    }, a.noConflict = function() {
        return e.EventEmitter = f, a;
    }, "function" == typeof define && define.amd ? define(function() {
        return a;
    }) : "object" == typeof module && module.exports ? module.exports = a : this.EventEmitter = a;
}).call(this), function(a) {
    "use strict";
    var b = document.documentElement, c = function() {};
    b.addEventListener ? c = function(a, b, c) {
        a.addEventListener(b, c, !1);
    } : b.attachEvent && (c = function(b, c, d) {
        b[c + d] = d.handleEvent ? function() {
            var b = a.event;
            b.target = b.target || b.srcElement, d.handleEvent.call(d, b);
        } : function() {
            var c = a.event;
            c.target = c.target || c.srcElement, d.call(b, c);
        }, b.attachEvent("on" + c, b[c + d]);
    });
    var d = function() {};
    b.removeEventListener ? d = function(a, b, c) {
        a.removeEventListener(b, c, !1);
    } : b.detachEvent && (d = function(a, b, c) {
        a.detachEvent("on" + b, a[b + c]);
        try {
            delete a[b + c];
        } catch (d) {
            a[b + c] = void 0;
        }
    });
    var e = {
        bind: c,
        unbind: d
    };
    "function" == typeof define && define.amd ? define(e) : a.eventie = e;
}(this), function(a) {
    "use strict";
    function b(a, b) {
        for (var c in b) a[c] = b[c];
        return a;
    }
    function c(a) {
        return "[object Array]" === i.call(a);
    }
    function d(a) {
        var b = [];
        if (c(a)) b = a; else if ("number" == typeof a.length) for (var d = 0, e = a.length; e > d; d++) b.push(a[d]); else b.push(a);
        return b;
    }
    function e(a, c) {
        function e(a, c, g) {
            if (!(this instanceof e)) return new e(a, c);
            "string" == typeof a && (a = document.querySelectorAll(a)), this.elements = d(a), 
            this.options = b({}, this.options), "function" == typeof c ? g = c : b(this.options, c), 
            g && this.on("always", g), this.getImages(), f && (this.jqDeferred = new f.Deferred());
            var h = this;
            setTimeout(function() {
                h.check();
            });
        }
        function i(a) {
            this.img = a;
        }
        e.prototype = new a(), e.prototype.options = {}, e.prototype.getImages = function() {
            this.images = [];
            for (var a = 0, b = this.elements.length; b > a; a++) {
                var c = this.elements[a];
                "IMG" === c.nodeName && this.addImage(c);
                for (var d = c.querySelectorAll("img"), e = 0, f = d.length; f > e; e++) {
                    var g = d[e];
                    this.addImage(g);
                }
            }
        }, e.prototype.addImage = function(a) {
            var b = new i(a);
            this.images.push(b);
        }, e.prototype.check = function() {
            function a(a, e) {
                return b.options.debug && h && g.log("confirm", a, e), b.progress(a), c++, c === d && b.complete(), 
                !0;
            }
            var b = this, c = 0, d = this.images.length;
            if (this.hasAnyBroken = !1, !d) return void this.complete();
            for (var e = 0; d > e; e++) {
                var f = this.images[e];
                f.on("confirm", a), f.check();
            }
        }, e.prototype.progress = function(a) {
            this.hasAnyBroken = this.hasAnyBroken || !a.isLoaded, this.emit("progress", this, a), 
            this.jqDeferred && this.jqDeferred.notify(this, a);
        }, e.prototype.complete = function() {
            var a = this.hasAnyBroken ? "fail" : "done";
            if (this.isComplete = !0, this.emit(a, this), this.emit("always", this), this.jqDeferred) {
                var b = this.hasAnyBroken ? "reject" : "resolve";
                this.jqDeferred[b](this);
            }
        }, f && (f.fn.imagesLoaded = function(a, b) {
            var c = new e(this, a, b);
            return c.jqDeferred.promise(f(this));
        });
        var j = {};
        return i.prototype = new a(), i.prototype.check = function() {
            var a = j[this.img.src];
            if (a) return void this.useCached(a);
            if (j[this.img.src] = this, this.img.complete && void 0 !== this.img.naturalWidth) return void this.confirm(0 !== this.img.naturalWidth, "naturalWidth");
            var b = this.proxyImage = new Image();
            c.bind(b, "load", this), c.bind(b, "error", this), b.src = this.img.src;
        }, i.prototype.useCached = function(a) {
            if (a.isConfirmed) this.confirm(a.isLoaded, "cached was confirmed"); else {
                var b = this;
                a.on("confirm", function(a) {
                    return b.confirm(a.isLoaded, "cache emitted confirmed"), !0;
                });
            }
        }, i.prototype.confirm = function(a, b) {
            this.isConfirmed = !0, this.isLoaded = a, this.emit("confirm", this, b);
        }, i.prototype.handleEvent = function(a) {
            var b = "on" + a.type;
            this[b] && this[b](a);
        }, i.prototype.onload = function() {
            this.confirm(!0, "onload"), this.unbindProxyEvents();
        }, i.prototype.onerror = function() {
            this.confirm(!1, "onerror"), this.unbindProxyEvents();
        }, i.prototype.unbindProxyEvents = function() {
            c.unbind(this.proxyImage, "load", this), c.unbind(this.proxyImage, "error", this);
        }, e;
    }
    var f = a.jQuery, g = a.console, h = "undefined" != typeof g, i = Object.prototype.toString;
    "function" == typeof define && define.amd ? define([ "eventEmitter", "eventie" ], e) : a.imagesLoaded = e(a.EventEmitter, a.eventie);
}(window);

(function(factory) {
    if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(jQuery);
    }
})(function($) {
    $.ui = $.ui || {};
    $.extend($.ui, {
        version: "1.11.4",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });
    $.fn.extend({
        scrollParent: function(includeHidden) {
            var position = this.css("position"), excludeStaticParent = position === "absolute", overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function() {
                var parent = $(this);
                if (excludeStaticParent && parent.css("position") === "static") {
                    return false;
                }
                return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
            }).eq(0);
            return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
        },
        uniqueId: function() {
            var uuid = 0;
            return function() {
                return this.each(function() {
                    if (!this.id) {
                        this.id = "ui-id-" + ++uuid;
                    }
                });
            };
        }(),
        removeUniqueId: function() {
            return this.each(function() {
                if (/^ui-id-\d+$/.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap='#" + mapName + "']")[0];
            return !!img && visible(img);
        }
        return (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
            return $.css(this, "visibility") === "hidden";
        }).length;
    }
    $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });
    if (!$("<a>").outerWidth(1).jquery) {
        $.each([ "Width", "Height" ], function(i, name) {
            var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
                innerWidth: $.fn.innerWidth,
                innerHeight: $.fn.innerHeight,
                outerWidth: $.fn.outerWidth,
                outerHeight: $.fn.outerHeight
            };
            function reduce(elem, size, border, margin) {
                $.each(side, function() {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }
            $.fn["inner" + name] = function(size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }
                return this.each(function() {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };
            $.fn["outer" + name] = function(size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }
                return this.each(function() {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
    }
    if (!$.fn.addBack) {
        $.fn.addBack = function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        };
    }
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = function(removeData) {
            return function(key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        }($.fn.removeData);
    }
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    $.fn.extend({
        focus: function(orig) {
            return function(delay, fn) {
                return typeof delay === "number" ? this.each(function() {
                    var elem = this;
                    setTimeout(function() {
                        $(elem).focus();
                        if (fn) {
                            fn.call(elem);
                        }
                    }, delay);
                }) : orig.apply(this, arguments);
            };
        }($.fn.focus),
        disableSelection: function() {
            var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
            return function() {
                return this.bind(eventType + ".ui-disableSelection", function(event) {
                    event.preventDefault();
                });
            };
        }(),
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        },
        zIndex: function(zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }
            if (this.length) {
                var elem = $(this[0]), position, value;
                while (elem.length && elem[0] !== document) {
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }
            return 0;
        }
    });
    $.ui.plugin = {
        add: function(module, option, set) {
            var i, proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([ option, set[i] ]);
            }
        },
        call: function(instance, name, args, allowDisconnected) {
            var i, set = instance.plugins[name];
            if (!set) {
                return;
            }
            if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
                return;
            }
            for (i = 0; i < set.length; i++) {
                if (instance.options[set[i][0]]) {
                    set[i][1].apply(instance.element, args);
                }
            }
        }
    };
    var widget_uuid = 0, widget_slice = Array.prototype.slice;
    $.cleanData = function(orig) {
        return function(elems) {
            var events, elem, i;
            for (i = 0; (elem = elems[i]) != null; i++) {
                try {
                    events = $._data(elem, "events");
                    if (events && events.remove) {
                        $(elem).triggerHandler("remove");
                    }
                } catch (e) {}
            }
            orig(elems);
        };
    }($.cleanData);
    $.widget = function(name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {}, namespace = name.split(".")[0];
        name = name.split(".")[1];
        fullName = namespace + "-" + name;
        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        };
        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function(options, element) {
            if (!this._createWidget) {
                return new constructor(options, element);
            }
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            _proto: $.extend({}, prototype),
            _childConstructors: []
        });
        basePrototype = new base();
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function(prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = function() {
                var _super = function() {
                    return base.prototype[prop].apply(this, arguments);
                }, _superApply = function(args) {
                    return base.prototype[prop].apply(this, args);
                };
                return function() {
                    var __super = this._super, __superApply = this._superApply, returnValue;
                    this._super = _super;
                    this._superApply = _superApply;
                    returnValue = value.apply(this, arguments);
                    this._super = __super;
                    this._superApply = __superApply;
                    return returnValue;
                };
            }();
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function(i, child) {
                var childPrototype = child.prototype;
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }
        $.widget.bridge(name, constructor);
        return constructor;
    };
    $.widget.extend = function(target) {
        var input = widget_slice.call(arguments, 1), inputIndex = 0, inputLength = input.length, key, value;
        for (;inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };
    $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = typeof options === "string", args = widget_slice.call(arguments, 1), returnValue = this;
            if (isMethodCall) {
                this.each(function() {
                    var methodValue, instance = $.data(this, fullName);
                    if (options === "instance") {
                        returnValue = instance;
                        return false;
                    }
                    if (!instance) {
                        return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                        return $.error("no such method '" + options + "' for " + name + " widget instance");
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                        return false;
                    }
                });
            } else {
                if (args.length) {
                    options = $.widget.extend.apply(null, [ options ].concat(args));
                }
                this.each(function() {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {});
                        if (instance._init) {
                            instance._init();
                        }
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }
            return returnValue;
        };
    };
    $.Widget = function() {};
    $.Widget._childConstructors = [];
    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = widget_uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function(event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ? element.ownerDocument : element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }
            this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
            this._create();
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
            this._destroy();
            this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
            this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled");
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,
        widget: function() {
            return this.element;
        },
        option: function(key, value) {
            var options = key, parts, curOption, i;
            if (arguments.length === 0) {
                return $.widget.extend({}, this.options);
            }
            if (typeof key === "string") {
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (arguments.length === 1) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (arguments.length === 1) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }
            this._setOptions(options);
            return this;
        },
        _setOptions: function(options) {
            var key;
            for (key in options) {
                this._setOption(key, options[key]);
            }
            return this;
        },
        _setOption: function(key, value) {
            this.options[key] = value;
            if (key === "disabled") {
                this.widget().toggleClass(this.widgetFullName + "-disabled", !!value);
                if (value) {
                    this.hoverable.removeClass("ui-state-hover");
                    this.focusable.removeClass("ui-state-focus");
                }
            }
            return this;
        },
        enable: function() {
            return this._setOptions({
                disabled: false
            });
        },
        disable: function() {
            return this._setOptions({
                disabled: true
            });
        },
        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement, instance = this;
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }
            $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                }
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
                }
                var match = event.match(/^([\w:-]*)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },
        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);
            this.bindings = $(this.bindings.not(element).get());
            this.focusable = $(this.focusable.not(element).get());
            this.hoverable = $(this.hoverable.not(element).get());
        },
        _delay: function(handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function(event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },
        _focusable: function(element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function(event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },
        _trigger: function(type, event, data) {
            var prop, orig, callback = this.options[type];
            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
            event.target = this.element[0];
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }
            this.element.trigger(event, data);
            return !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === false || event.isDefaultPrevented());
        }
    };
    $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            if (typeof options === "string") {
                options = {
                    effect: options
                };
            }
            var hasOptions, effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = {
                    duration: options
                };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function(next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });
    var widget = $.widget;
    var mouseHandled = false;
    $(document).mouseup(function() {
        mouseHandled = false;
    });
    var mouse = $.widget("ui.mouse", {
        version: "1.11.4",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;
            this.element.bind("mousedown." + this.widgetName, function(event) {
                return that._mouseDown(event);
            }).bind("click." + this.widgetName, function(event) {
                if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                    $.removeData(event.target, that.widgetName + ".preventClickEvent");
                    event.stopImmediatePropagation();
                    return false;
                }
            });
            this.started = false;
        },
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },
        _mouseDown: function(event) {
            if (mouseHandled) {
                return;
            }
            this._mouseMoved = false;
            this._mouseStarted && this._mouseUp(event);
            this._mouseDownEvent = event;
            var that = this, btnIsLeft = event.which === 1, elIsCancel = typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }
            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }
            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(event) !== false;
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }
            this._mouseMoveDelegate = function(event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function(event) {
                return that._mouseUp(event);
            };
            this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate);
            event.preventDefault();
            mouseHandled = true;
            return true;
        },
        _mouseMove: function(event) {
            if (this._mouseMoved) {
                if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                    return this._mouseUp(event);
                } else if (!event.which) {
                    return this._mouseUp(event);
                }
            }
            if (event.which || event.button) {
                this._mouseMoved = true;
            }
            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }
            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
                this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
            }
            return !this._mouseStarted;
        },
        _mouseUp: function(event) {
            this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            if (this._mouseStarted) {
                this._mouseStarted = false;
                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }
                this._mouseStop(event);
            }
            mouseHandled = false;
            return false;
        },
        _mouseDistanceMet: function(event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return true;
        }
    });
    (function() {
        $.ui = $.ui || {};
        var cachedScrollbarWidth, supportsOffsetFractions, max = Math.max, abs = Math.abs, round = Math.round, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
        function getOffsets(offsets, width, height) {
            return [ parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1) ];
        }
        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0;
        }
        function getDimensions(elem) {
            var raw = elem[0];
            if (raw.nodeType === 9) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: 0,
                        left: 0
                    }
                };
            }
            if ($.isWindow(raw)) {
                return {
                    width: elem.width(),
                    height: elem.height(),
                    offset: {
                        top: elem.scrollTop(),
                        left: elem.scrollLeft()
                    }
                };
            }
            if (raw.preventDefault) {
                return {
                    width: 0,
                    height: 0,
                    offset: {
                        top: raw.pageY,
                        left: raw.pageX
                    }
                };
            }
            return {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            };
        }
        $.position = {
            scrollbarWidth: function() {
                if (cachedScrollbarWidth !== undefined) {
                    return cachedScrollbarWidth;
                }
                var w1, w2, div = $("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"), innerDiv = div.children()[0];
                $("body").append(div);
                w1 = innerDiv.offsetWidth;
                div.css("overflow", "scroll");
                w2 = innerDiv.offsetWidth;
                if (w1 === w2) {
                    w2 = div[0].clientWidth;
                }
                div.remove();
                return cachedScrollbarWidth = w1 - w2;
            },
            getScrollInfo: function(within) {
                var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"), overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"), hasOverflowX = overflowX === "scroll" || overflowX === "auto" && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === "scroll" || overflowY === "auto" && within.height < within.element[0].scrollHeight;
                return {
                    width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                    height: hasOverflowX ? $.position.scrollbarWidth() : 0
                };
            },
            getWithinInfo: function(element) {
                var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]), isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;
                return {
                    element: withinElement,
                    isWindow: isWindow,
                    isDocument: isDocument,
                    offset: withinElement.offset() || {
                        left: 0,
                        top: 0
                    },
                    scrollLeft: withinElement.scrollLeft(),
                    scrollTop: withinElement.scrollTop(),
                    width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
                    height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
                };
            }
        };
        $.fn.position = function(options) {
            if (!options || !options.of) {
                return _position.apply(this, arguments);
            }
            options = $.extend({}, options);
            var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || "flip").split(" "), offsets = {};
            dimensions = getDimensions(target);
            if (target[0].preventDefault) {
                options.at = "left top";
            }
            targetWidth = dimensions.width;
            targetHeight = dimensions.height;
            targetOffset = dimensions.offset;
            basePosition = $.extend({}, targetOffset);
            $.each([ "my", "at" ], function() {
                var pos = (options[this] || "").split(" "), horizontalOffset, verticalOffset;
                if (pos.length === 1) {
                    pos = rhorizontal.test(pos[0]) ? pos.concat([ "center" ]) : rvertical.test(pos[0]) ? [ "center" ].concat(pos) : [ "center", "center" ];
                }
                pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
                pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
                horizontalOffset = roffset.exec(pos[0]);
                verticalOffset = roffset.exec(pos[1]);
                offsets[this] = [ horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0 ];
                options[this] = [ rposition.exec(pos[0])[0], rposition.exec(pos[1])[0] ];
            });
            if (collision.length === 1) {
                collision[1] = collision[0];
            }
            if (options.at[0] === "right") {
                basePosition.left += targetWidth;
            } else if (options.at[0] === "center") {
                basePosition.left += targetWidth / 2;
            }
            if (options.at[1] === "bottom") {
                basePosition.top += targetHeight;
            } else if (options.at[1] === "center") {
                basePosition.top += targetHeight / 2;
            }
            atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
            basePosition.left += atOffset[0];
            basePosition.top += atOffset[1];
            return this.each(function() {
                var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, "marginLeft"), marginTop = parseCss(this, "marginTop"), collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
                if (options.my[0] === "right") {
                    position.left -= elemWidth;
                } else if (options.my[0] === "center") {
                    position.left -= elemWidth / 2;
                }
                if (options.my[1] === "bottom") {
                    position.top -= elemHeight;
                } else if (options.my[1] === "center") {
                    position.top -= elemHeight / 2;
                }
                position.left += myOffset[0];
                position.top += myOffset[1];
                if (!supportsOffsetFractions) {
                    position.left = round(position.left);
                    position.top = round(position.top);
                }
                collisionPosition = {
                    marginLeft: marginLeft,
                    marginTop: marginTop
                };
                $.each([ "left", "top" ], function(i, dir) {
                    if ($.ui.position[collision[i]]) {
                        $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [ atOffset[0] + myOffset[0], atOffset[1] + myOffset[1] ],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        });
                    }
                });
                if (options.using) {
                    using = function(props) {
                        var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
                            target: {
                                element: target,
                                left: targetOffset.left,
                                top: targetOffset.top,
                                width: targetWidth,
                                height: targetHeight
                            },
                            element: {
                                element: elem,
                                left: position.left,
                                top: position.top,
                                width: elemWidth,
                                height: elemHeight
                            },
                            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                        };
                        if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                            feedback.horizontal = "center";
                        }
                        if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                            feedback.vertical = "middle";
                        }
                        if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                            feedback.important = "horizontal";
                        } else {
                            feedback.important = "vertical";
                        }
                        options.using.call(this, props, feedback);
                    };
                }
                elem.offset($.extend(position, {
                    using: using
                }));
            });
        };
        $.ui.position = {
            fit: {
                left: function(position, data) {
                    var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
                    if (data.collisionWidth > outerWidth) {
                        if (overLeft > 0 && overRight <= 0) {
                            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                            position.left += overLeft - newOverRight;
                        } else if (overRight > 0 && overLeft <= 0) {
                            position.left = withinOffset;
                        } else {
                            if (overLeft > overRight) {
                                position.left = withinOffset + outerWidth - data.collisionWidth;
                            } else {
                                position.left = withinOffset;
                            }
                        }
                    } else if (overLeft > 0) {
                        position.left += overLeft;
                    } else if (overRight > 0) {
                        position.left -= overRight;
                    } else {
                        position.left = max(position.left - collisionPosLeft, position.left);
                    }
                },
                top: function(position, data) {
                    var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
                    if (data.collisionHeight > outerHeight) {
                        if (overTop > 0 && overBottom <= 0) {
                            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                            position.top += overTop - newOverBottom;
                        } else if (overBottom > 0 && overTop <= 0) {
                            position.top = withinOffset;
                        } else {
                            if (overTop > overBottom) {
                                position.top = withinOffset + outerHeight - data.collisionHeight;
                            } else {
                                position.top = withinOffset;
                            }
                        }
                    } else if (overTop > 0) {
                        position.top += overTop;
                    } else if (overBottom > 0) {
                        position.top -= overBottom;
                    } else {
                        position.top = max(position.top - collisionPosTop, position.top);
                    }
                }
            },
            flip: {
                left: function(position, data) {
                    var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0, atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
                    if (overLeft < 0) {
                        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
                        if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                            position.left += myOffset + atOffset + offset;
                        }
                    } else if (overRight > 0) {
                        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
                        if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                            position.left += myOffset + atOffset + offset;
                        }
                    }
                },
                top: function(position, data) {
                    var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === "top", myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0, atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
                    if (overTop < 0) {
                        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
                        if (newOverBottom < 0 || newOverBottom < abs(overTop)) {
                            position.top += myOffset + atOffset + offset;
                        }
                    } else if (overBottom > 0) {
                        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
                        if (newOverTop > 0 || abs(newOverTop) < overBottom) {
                            position.top += myOffset + atOffset + offset;
                        }
                    }
                }
            },
            flipfit: {
                left: function() {
                    $.ui.position.flip.left.apply(this, arguments);
                    $.ui.position.fit.left.apply(this, arguments);
                },
                top: function() {
                    $.ui.position.flip.top.apply(this, arguments);
                    $.ui.position.fit.top.apply(this, arguments);
                }
            }
        };
        (function() {
            var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName("body")[0], div = document.createElement("div");
            testElement = document.createElement(body ? "div" : "body");
            testElementStyle = {
                visibility: "hidden",
                width: 0,
                height: 0,
                border: 0,
                margin: 0,
                background: "none"
            };
            if (body) {
                $.extend(testElementStyle, {
                    position: "absolute",
                    left: "-1000px",
                    top: "-1000px"
                });
            }
            for (i in testElementStyle) {
                testElement.style[i] = testElementStyle[i];
            }
            testElement.appendChild(div);
            testElementParent = body || document.documentElement;
            testElementParent.insertBefore(testElement, testElementParent.firstChild);
            div.style.cssText = "position: absolute; left: 10.7432222px;";
            offsetLeft = $(div).offset().left;
            supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
            testElement.innerHTML = "";
            testElementParent.removeChild(testElement);
        })();
    })();
    var position = $.ui.position;
    var accordion = $.widget("ui.accordion", {
        version: "1.11.4",
        options: {
            active: 0,
            animate: {},
            collapsible: false,
            event: "click",
            header: "> li > :first-child,> :not(li):even",
            heightStyle: "auto",
            icons: {
                activeHeader: "ui-icon-triangle-1-s",
                header: "ui-icon-triangle-1-e"
            },
            activate: null,
            beforeActivate: null
        },
        hideProps: {
            borderTopWidth: "hide",
            borderBottomWidth: "hide",
            paddingTop: "hide",
            paddingBottom: "hide",
            height: "hide"
        },
        showProps: {
            borderTopWidth: "show",
            borderBottomWidth: "show",
            paddingTop: "show",
            paddingBottom: "show",
            height: "show"
        },
        _create: function() {
            var options = this.options;
            this.prevShow = this.prevHide = $();
            this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role", "tablist");
            if (!options.collapsible && (options.active === false || options.active == null)) {
                options.active = 0;
            }
            this._processPanels();
            if (options.active < 0) {
                options.active += this.headers.length;
            }
            this._refresh();
        },
        _getCreateEventData: function() {
            return {
                header: this.active,
                panel: !this.active.length ? $() : this.active.next()
            };
        },
        _createIcons: function() {
            var icons = this.options.icons;
            if (icons) {
                $("<span>").addClass("ui-accordion-header-icon ui-icon " + icons.header).prependTo(this.headers);
                this.active.children(".ui-accordion-header-icon").removeClass(icons.header).addClass(icons.activeHeader);
                this.headers.addClass("ui-accordion-icons");
            }
        },
        _destroyIcons: function() {
            this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove();
        },
        _destroy: function() {
            var contents;
            this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");
            this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-state-default " + "ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").removeUniqueId();
            this._destroyIcons();
            contents = this.headers.next().removeClass("ui-helper-reset ui-widget-content ui-corner-bottom " + "ui-accordion-content ui-accordion-content-active ui-state-disabled").css("display", "").removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeUniqueId();
            if (this.options.heightStyle !== "content") {
                contents.css("height", "");
            }
        },
        _setOption: function(key, value) {
            if (key === "active") {
                this._activate(value);
                return;
            }
            if (key === "event") {
                if (this.options.event) {
                    this._off(this.headers, this.options.event);
                }
                this._setupEvents(value);
            }
            this._super(key, value);
            if (key === "collapsible" && !value && this.options.active === false) {
                this._activate(0);
            }
            if (key === "icons") {
                this._destroyIcons();
                if (value) {
                    this._createIcons();
                }
            }
            if (key === "disabled") {
                this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
                this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!value);
            }
        },
        _keydown: function(event) {
            if (event.altKey || event.ctrlKey) {
                return;
            }
            var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false;
            switch (event.keyCode) {
              case keyCode.RIGHT:
              case keyCode.DOWN:
                toFocus = this.headers[(currentIndex + 1) % length];
                break;

              case keyCode.LEFT:
              case keyCode.UP:
                toFocus = this.headers[(currentIndex - 1 + length) % length];
                break;

              case keyCode.SPACE:
              case keyCode.ENTER:
                this._eventHandler(event);
                break;

              case keyCode.HOME:
                toFocus = this.headers[0];
                break;

              case keyCode.END:
                toFocus = this.headers[length - 1];
                break;
            }
            if (toFocus) {
                $(event.target).attr("tabIndex", -1);
                $(toFocus).attr("tabIndex", 0);
                toFocus.focus();
                event.preventDefault();
            }
        },
        _panelKeyDown: function(event) {
            if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
                $(event.currentTarget).prev().focus();
            }
        },
        refresh: function() {
            var options = this.options;
            this._processPanels();
            if (options.active === false && options.collapsible === true || !this.headers.length) {
                options.active = false;
                this.active = $();
            } else if (options.active === false) {
                this._activate(0);
            } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
                if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
                    options.active = false;
                    this.active = $();
                } else {
                    this._activate(Math.max(0, options.active - 1));
                }
            } else {
                options.active = this.headers.index(this.active);
            }
            this._destroyIcons();
            this._refresh();
        },
        _processPanels: function() {
            var prevHeaders = this.headers, prevPanels = this.panels;
            this.headers = this.element.find(this.options.header).addClass("ui-accordion-header ui-state-default ui-corner-all");
            this.panels = this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide();
            if (prevPanels) {
                this._off(prevHeaders.not(this.headers));
                this._off(prevPanels.not(this.panels));
            }
        },
        _refresh: function() {
            var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent();
            this.active = this._findActive(options.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all");
            this.active.next().addClass("ui-accordion-content-active").show();
            this.headers.attr("role", "tab").each(function() {
                var header = $(this), headerId = header.uniqueId().attr("id"), panel = header.next(), panelId = panel.uniqueId().attr("id");
                header.attr("aria-controls", panelId);
                panel.attr("aria-labelledby", headerId);
            }).next().attr("role", "tabpanel");
            this.headers.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            }).next().attr({
                "aria-hidden": "true"
            }).hide();
            if (!this.active.length) {
                this.headers.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                }).next().attr({
                    "aria-hidden": "false"
                });
            }
            this._createIcons();
            this._setupEvents(options.event);
            if (heightStyle === "fill") {
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this), position = elem.css("position");
                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });
                this.headers.each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });
                this.headers.next().each(function() {
                    $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                }).css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.headers.next().each(function() {
                    maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                }).height(maxHeight);
            }
        },
        _activate: function(index) {
            var active = this._findActive(index)[0];
            if (active === this.active[0]) {
                return;
            }
            active = active || this.active[0];
            this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            });
        },
        _findActive: function(selector) {
            return typeof selector === "number" ? this.headers.eq(selector) : $();
        },
        _setupEvents: function(event) {
            var events = {
                keydown: "_keydown"
            };
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }
            this._off(this.headers.add(this.headers.next()));
            this._on(this.headers, events);
            this._on(this.headers.next(), {
                keydown: "_panelKeyDown"
            });
            this._hoverable(this.headers);
            this._focusable(this.headers);
        },
        _eventHandler: function(event) {
            var options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
                oldHeader: active,
                oldPanel: toHide,
                newHeader: collapsing ? $() : clicked,
                newPanel: toShow
            };
            event.preventDefault();
            if (clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === false) {
                return;
            }
            options.active = collapsing ? false : this.headers.index(clicked);
            this.active = clickedIsActive ? $() : clicked;
            this._toggle(eventData);
            active.removeClass("ui-accordion-header-active ui-state-active");
            if (options.icons) {
                active.children(".ui-accordion-header-icon").removeClass(options.icons.activeHeader).addClass(options.icons.header);
            }
            if (!clickedIsActive) {
                clicked.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top");
                if (options.icons) {
                    clicked.children(".ui-accordion-header-icon").removeClass(options.icons.header).addClass(options.icons.activeHeader);
                }
                clicked.next().addClass("ui-accordion-content-active");
            }
        },
        _toggle: function(data) {
            var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
            this.prevShow.add(this.prevHide).stop(true, true);
            this.prevShow = toShow;
            this.prevHide = toHide;
            if (this.options.animate) {
                this._animate(toShow, toHide, data);
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete(data);
            }
            toHide.attr({
                "aria-hidden": "true"
            });
            toHide.prev().attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            });
            if (toShow.length && toHide.length) {
                toHide.prev().attr({
                    tabIndex: -1,
                    "aria-expanded": "false"
                });
            } else if (toShow.length) {
                this.headers.filter(function() {
                    return parseInt($(this).attr("tabIndex"), 10) === 0;
                }).attr("tabIndex", -1);
            }
            toShow.attr("aria-hidden", "false").prev().attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },
        _animate: function(toShow, toHide, data) {
            var total, easing, duration, that = this, adjust = 0, boxSizing = toShow.css("box-sizing"), down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function() {
                that._toggleComplete(data);
            };
            if (typeof options === "number") {
                duration = options;
            }
            if (typeof options === "string") {
                easing = options;
            }
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;
            if (!toHide.length) {
                return toShow.animate(this.showProps, duration, easing, complete);
            }
            if (!toShow.length) {
                return toHide.animate(this.hideProps, duration, easing, complete);
            }
            total = toShow.show().outerHeight();
            toHide.animate(this.hideProps, {
                duration: duration,
                easing: easing,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                }
            });
            toShow.hide().animate(this.showProps, {
                duration: duration,
                easing: easing,
                complete: complete,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                    if (fx.prop !== "height") {
                        if (boxSizing === "content-box") {
                            adjust += fx.now;
                        }
                    } else if (that.options.heightStyle !== "content") {
                        fx.now = Math.round(total - toHide.outerHeight() - adjust);
                        adjust = 0;
                    }
                }
            });
        },
        _toggleComplete: function(data) {
            var toHide = data.oldPanel;
            toHide.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all");
            if (toHide.length) {
                toHide.parent()[0].className = toHide.parent()[0].className;
            }
            this._trigger("activate", null, data);
        }
    });
    var menu = $.widget("ui.menu", {
        version: "1.11.4",
        defaultElement: "<ul>",
        delay: 300,
        options: {
            icons: {
                submenu: "ui-icon-carat-1-e"
            },
            items: "> *",
            menus: "ul",
            position: {
                my: "left-1 top",
                at: "right top"
            },
            role: "menu",
            blur: null,
            focus: null,
            select: null
        },
        _create: function() {
            this.activeMenu = this.element;
            this.mouseHandled = false;
            this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
                role: this.options.role,
                tabIndex: 0
            });
            if (this.options.disabled) {
                this.element.addClass("ui-state-disabled").attr("aria-disabled", "true");
            }
            this._on({
                "mousedown .ui-menu-item": function(event) {
                    event.preventDefault();
                },
                "click .ui-menu-item": function(event) {
                    var target = $(event.target);
                    if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
                        this.select(event);
                        if (!event.isPropagationStopped()) {
                            this.mouseHandled = true;
                        }
                        if (target.has(".ui-menu").length) {
                            this.expand(event);
                        } else if (!this.element.is(":focus") && $(this.document[0].activeElement).closest(".ui-menu").length) {
                            this.element.trigger("focus", [ true ]);
                            if (this.active && this.active.parents(".ui-menu").length === 1) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                },
                "mouseenter .ui-menu-item": function(event) {
                    if (this.previousFilter) {
                        return;
                    }
                    var target = $(event.currentTarget);
                    target.siblings(".ui-state-active").removeClass("ui-state-active");
                    this.focus(event, target);
                },
                mouseleave: "collapseAll",
                "mouseleave .ui-menu": "collapseAll",
                focus: function(event, keepActiveItem) {
                    var item = this.active || this.element.find(this.options.items).eq(0);
                    if (!keepActiveItem) {
                        this.focus(event, item);
                    }
                },
                blur: function(event) {
                    this._delay(function() {
                        if (!$.contains(this.element[0], this.document[0].activeElement)) {
                            this.collapseAll(event);
                        }
                    });
                },
                keydown: "_keydown"
            });
            this.refresh();
            this._on(this.document, {
                click: function(event) {
                    if (this._closeOnDocumentClick(event)) {
                        this.collapseAll(event);
                    }
                    this.mouseHandled = false;
                }
            });
        },
        _destroy: function() {
            this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show();
            this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function() {
                var elem = $(this);
                if (elem.data("ui-menu-submenu-carat")) {
                    elem.remove();
                }
            });
            this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
        },
        _keydown: function(event) {
            var match, prev, character, skip, preventDefault = true;
            switch (event.keyCode) {
              case $.ui.keyCode.PAGE_UP:
                this.previousPage(event);
                break;

              case $.ui.keyCode.PAGE_DOWN:
                this.nextPage(event);
                break;

              case $.ui.keyCode.HOME:
                this._move("first", "first", event);
                break;

              case $.ui.keyCode.END:
                this._move("last", "last", event);
                break;

              case $.ui.keyCode.UP:
                this.previous(event);
                break;

              case $.ui.keyCode.DOWN:
                this.next(event);
                break;

              case $.ui.keyCode.LEFT:
                this.collapse(event);
                break;

              case $.ui.keyCode.RIGHT:
                if (this.active && !this.active.is(".ui-state-disabled")) {
                    this.expand(event);
                }
                break;

              case $.ui.keyCode.ENTER:
              case $.ui.keyCode.SPACE:
                this._activate(event);
                break;

              case $.ui.keyCode.ESCAPE:
                this.collapse(event);
                break;

              default:
                preventDefault = false;
                prev = this.previousFilter || "";
                character = String.fromCharCode(event.keyCode);
                skip = false;
                clearTimeout(this.filterTimer);
                if (character === prev) {
                    skip = true;
                } else {
                    character = prev + character;
                }
                match = this._filterMenuItems(character);
                match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : match;
                if (!match.length) {
                    character = String.fromCharCode(event.keyCode);
                    match = this._filterMenuItems(character);
                }
                if (match.length) {
                    this.focus(event, match);
                    this.previousFilter = character;
                    this.filterTimer = this._delay(function() {
                        delete this.previousFilter;
                    }, 1e3);
                } else {
                    delete this.previousFilter;
                }
            }
            if (preventDefault) {
                event.preventDefault();
            }
        },
        _activate: function(event) {
            if (!this.active.is(".ui-state-disabled")) {
                if (this.active.is("[aria-haspopup='true']")) {
                    this.expand(event);
                } else {
                    this.select(event);
                }
            }
        },
        refresh: function() {
            var menus, items, that = this, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
            this.element.toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length);
            submenus.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({
                role: this.options.role,
                "aria-hidden": "true",
                "aria-expanded": "false"
            }).each(function() {
                var menu = $(this), item = menu.parent(), submenuCarat = $("<span>").addClass("ui-menu-icon ui-icon " + icon).data("ui-menu-submenu-carat", true);
                item.attr("aria-haspopup", "true").prepend(submenuCarat);
                menu.attr("aria-labelledby", item.attr("id"));
            });
            menus = submenus.add(this.element);
            items = menus.find(this.options.items);
            items.not(".ui-menu-item").each(function() {
                var item = $(this);
                if (that._isDivider(item)) {
                    item.addClass("ui-widget-content ui-menu-divider");
                }
            });
            items.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({
                tabIndex: -1,
                role: this._itemRole()
            });
            items.filter(".ui-state-disabled").attr("aria-disabled", "true");
            if (this.active && !$.contains(this.element[0], this.active[0])) {
                this.blur();
            }
        },
        _itemRole: function() {
            return {
                menu: "menuitem",
                listbox: "option"
            }[this.options.role];
        },
        _setOption: function(key, value) {
            if (key === "icons") {
                this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(value.submenu);
            }
            if (key === "disabled") {
                this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
            }
            this._super(key, value);
        },
        focus: function(event, item) {
            var nested, focused;
            this.blur(event, event && event.type === "focus");
            this._scrollIntoView(item);
            this.active = item.first();
            focused = this.active.addClass("ui-state-focus").removeClass("ui-state-active");
            if (this.options.role) {
                this.element.attr("aria-activedescendant", focused.attr("id"));
            }
            this.active.parent().closest(".ui-menu-item").addClass("ui-state-active");
            if (event && event.type === "keydown") {
                this._close();
            } else {
                this.timer = this._delay(function() {
                    this._close();
                }, this.delay);
            }
            nested = item.children(".ui-menu");
            if (nested.length && event && /^mouse/.test(event.type)) {
                this._startOpening(nested);
            }
            this.activeMenu = item.parent();
            this._trigger("focus", event, {
                item: item
            });
        },
        _scrollIntoView: function(item) {
            var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
            if (this._hasScroll()) {
                borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
                paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
                offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
                scroll = this.activeMenu.scrollTop();
                elementHeight = this.activeMenu.height();
                itemHeight = item.outerHeight();
                if (offset < 0) {
                    this.activeMenu.scrollTop(scroll + offset);
                } else if (offset + itemHeight > elementHeight) {
                    this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
                }
            }
        },
        blur: function(event, fromFocus) {
            if (!fromFocus) {
                clearTimeout(this.timer);
            }
            if (!this.active) {
                return;
            }
            this.active.removeClass("ui-state-focus");
            this.active = null;
            this._trigger("blur", event, {
                item: this.active
            });
        },
        _startOpening: function(submenu) {
            clearTimeout(this.timer);
            if (submenu.attr("aria-hidden") !== "true") {
                return;
            }
            this.timer = this._delay(function() {
                this._close();
                this._open(submenu);
            }, this.delay);
        },
        _open: function(submenu) {
            var position = $.extend({
                of: this.active
            }, this.options.position);
            clearTimeout(this.timer);
            this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true");
            submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position);
        },
        collapseAll: function(event, all) {
            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
                if (!currentMenu.length) {
                    currentMenu = this.element;
                }
                this._close(currentMenu);
                this.blur(event);
                this.activeMenu = currentMenu;
            }, this.delay);
        },
        _close: function(startMenu) {
            if (!startMenu) {
                startMenu = this.active ? this.active.parent() : this.element;
            }
            startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active");
        },
        _closeOnDocumentClick: function(event) {
            return !$(event.target).closest(".ui-menu").length;
        },
        _isDivider: function(item) {
            return !/[^\-\u2014\u2013\s]/.test(item.text());
        },
        collapse: function(event) {
            var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
            if (newItem && newItem.length) {
                this._close();
                this.focus(event, newItem);
            }
        },
        expand: function(event) {
            var newItem = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
            if (newItem && newItem.length) {
                this._open(newItem.parent());
                this._delay(function() {
                    this.focus(event, newItem);
                });
            }
        },
        next: function(event) {
            this._move("next", "first", event);
        },
        previous: function(event) {
            this._move("prev", "last", event);
        },
        isFirstItem: function() {
            return this.active && !this.active.prevAll(".ui-menu-item").length;
        },
        isLastItem: function() {
            return this.active && !this.active.nextAll(".ui-menu-item").length;
        },
        _move: function(direction, filter, event) {
            var next;
            if (this.active) {
                if (direction === "first" || direction === "last") {
                    next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1);
                } else {
                    next = this.active[direction + "All"](".ui-menu-item").eq(0);
                }
            }
            if (!next || !next.length || !this.active) {
                next = this.activeMenu.find(this.options.items)[filter]();
            }
            this.focus(event, next);
        },
        nextPage: function(event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isLastItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.nextAll(".ui-menu-item").each(function() {
                    item = $(this);
                    return item.offset().top - base - height < 0;
                });
                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.find(this.options.items)[!this.active ? "first" : "last"]());
            }
        },
        previousPage: function(event) {
            var item, base, height;
            if (!this.active) {
                this.next(event);
                return;
            }
            if (this.isFirstItem()) {
                return;
            }
            if (this._hasScroll()) {
                base = this.active.offset().top;
                height = this.element.height();
                this.active.prevAll(".ui-menu-item").each(function() {
                    item = $(this);
                    return item.offset().top - base + height > 0;
                });
                this.focus(event, item);
            } else {
                this.focus(event, this.activeMenu.find(this.options.items).first());
            }
        },
        _hasScroll: function() {
            return this.element.outerHeight() < this.element.prop("scrollHeight");
        },
        select: function(event) {
            this.active = this.active || $(event.target).closest(".ui-menu-item");
            var ui = {
                item: this.active
            };
            if (!this.active.has(".ui-menu").length) {
                this.collapseAll(event, true);
            }
            this._trigger("select", event, ui);
        },
        _filterMenuItems: function(character) {
            var escapedCharacter = character.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"), regex = new RegExp("^" + escapedCharacter, "i");
            return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function() {
                return regex.test($.trim($(this).text()));
            });
        }
    });
    $.widget("ui.autocomplete", {
        version: "1.11.4",
        defaultElement: "<input>",
        options: {
            appendTo: null,
            autoFocus: false,
            delay: 300,
            minLength: 1,
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            source: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            response: null,
            search: null,
            select: null
        },
        requestIndex: 0,
        pending: 0,
        _create: function() {
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = nodeName === "textarea", isInput = nodeName === "input";
            this.isMultiLine = isTextarea ? true : isInput ? false : this.element.prop("isContentEditable");
            this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
            this.isNewMenu = true;
            this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off");
            this._on(this.element, {
                keydown: function(event) {
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }
                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                      case keyCode.PAGE_UP:
                        suppressKeyPress = true;
                        this._move("previousPage", event);
                        break;

                      case keyCode.PAGE_DOWN:
                        suppressKeyPress = true;
                        this._move("nextPage", event);
                        break;

                      case keyCode.UP:
                        suppressKeyPress = true;
                        this._keyEvent("previous", event);
                        break;

                      case keyCode.DOWN:
                        suppressKeyPress = true;
                        this._keyEvent("next", event);
                        break;

                      case keyCode.ENTER:
                        if (this.menu.active) {
                            suppressKeyPress = true;
                            event.preventDefault();
                            this.menu.select(event);
                        }
                        break;

                      case keyCode.TAB:
                        if (this.menu.active) {
                            this.menu.select(event);
                        }
                        break;

                      case keyCode.ESCAPE:
                        if (this.menu.element.is(":visible")) {
                            if (!this.isMultiLine) {
                                this._value(this.term);
                            }
                            this.close(event);
                            event.preventDefault();
                        }
                        break;

                      default:
                        suppressKeyPressRepeat = true;
                        this._searchTimeout(event);
                        break;
                    }
                },
                keypress: function(event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        if (!this.isMultiLine || this.menu.element.is(":visible")) {
                            event.preventDefault();
                        }
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                      case keyCode.PAGE_UP:
                        this._move("previousPage", event);
                        break;

                      case keyCode.PAGE_DOWN:
                        this._move("nextPage", event);
                        break;

                      case keyCode.UP:
                        this._keyEvent("previous", event);
                        break;

                      case keyCode.DOWN:
                        this._keyEvent("next", event);
                        break;
                    }
                },
                input: function(event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                focus: function() {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                blur: function(event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }
                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                }
            });
            this._initSource();
            this.menu = $("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({
                role: null
            }).hide().menu("instance");
            this._on(this.menu.element, {
                mousedown: function(event) {
                    event.preventDefault();
                    this.cancelBlur = true;
                    this._delay(function() {
                        delete this.cancelBlur;
                    });
                    var menuElement = this.menu.element[0];
                    if (!$(event.target).closest(".ui-menu-item").length) {
                        this._delay(function() {
                            var that = this;
                            this.document.one("mousedown", function(event) {
                                if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {
                                    that.close();
                                }
                            });
                        });
                    }
                },
                menufocus: function(event, ui) {
                    var label, item;
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                            this.menu.blur();
                            this.document.one("mousemove", function() {
                                $(event.target).trigger(event.originalEvent);
                            });
                            return;
                        }
                    }
                    item = ui.item.data("ui-autocomplete-item");
                    if (false !== this._trigger("focus", event, {
                        item: item
                    })) {
                        if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                            this._value(item.value);
                        }
                    }
                    label = ui.item.attr("aria-label") || item.value;
                    if (label && $.trim(label).length) {
                        this.liveRegion.children().hide();
                        $("<div>").text(label).appendTo(this.liveRegion);
                    }
                },
                menuselect: function(event, ui) {
                    var item = ui.item.data("ui-autocomplete-item"), previous = this.previous;
                    if (this.element[0] !== this.document[0].activeElement) {
                        this.element.focus();
                        this.previous = previous;
                        this._delay(function() {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }
                    if (false !== this._trigger("select", event, {
                        item: item
                    })) {
                        this._value(item.value);
                    }
                    this.term = this._value();
                    this.close(event);
                    this.selectedItem = item;
                }
            });
            this.liveRegion = $("<span>", {
                role: "status",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body);
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },
        _destroy: function() {
            clearTimeout(this.searching);
            this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this._appendTo());
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            if (element) {
                element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
            }
            if (!element || !element[0]) {
                element = this.element.closest(".ui-front");
            }
            if (!element.length) {
                element = this.document[0].body;
            }
            return element;
        },
        _initSource: function() {
            var array, url, that = this;
            if ($.isArray(this.options.source)) {
                array = this.options.source;
                this.source = function(request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };
            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                this.source = function(request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function(data) {
                            response(data);
                        },
                        error: function() {
                            response([]);
                        }
                    });
                };
            } else {
                this.source = this.options.source;
            }
        },
        _searchTimeout: function(event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function() {
                var equalValues = this.term === this._value(), menuVisible = this.menu.element.is(":visible"), modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
                if (!equalValues || equalValues && !menuVisible && !modifierKey) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },
        search: function(value, event) {
            value = value != null ? value : this._value();
            this.term = this._value();
            if (value.length < this.options.minLength) {
                return this.close(event);
            }
            if (this._trigger("search", event) === false) {
                return;
            }
            return this._search(value);
        },
        _search: function(value) {
            this.pending++;
            this.element.addClass("ui-autocomplete-loading");
            this.cancelSearch = false;
            this.source({
                term: value
            }, this._response());
        },
        _response: function() {
            var index = ++this.requestIndex;
            return $.proxy(function(content) {
                if (index === this.requestIndex) {
                    this.__response(content);
                }
                this.pending--;
                if (!this.pending) {
                    this.element.removeClass("ui-autocomplete-loading");
                }
            }, this);
        },
        __response: function(content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, {
                content: content
            });
            if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                this._suggest(content);
                this._trigger("open");
            } else {
                this._close();
            }
        },
        close: function(event) {
            this.cancelSearch = true;
            this._close(event);
        },
        _close: function(event) {
            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },
        _change: function(event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, {
                    item: this.selectedItem
                });
            }
        },
        _normalize: function(items) {
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function(item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }
                return $.extend({}, item, {
                    label: item.label || item.value,
                    value: item.value || item.label
                });
            });
        },
        _suggest: function(items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items);
            this.isNewMenu = true;
            this.menu.refresh();
            ul.show();
            this._resizeMenu();
            ul.position($.extend({
                of: this.element
            }, this.options.position));
            if (this.options.autoFocus) {
                this.menu.next();
            }
        },
        _resizeMenu: function() {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(ul.width("").outerWidth() + 1, this.element.outerWidth()));
        },
        _renderMenu: function(ul, items) {
            var that = this;
            $.each(items, function(index, item) {
                that._renderItemData(ul, item);
            });
        },
        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },
        _renderItem: function(ul, item) {
            return $("<li>").text(item.label).appendTo(ul);
        },
        _move: function(direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
                if (!this.isMultiLine) {
                    this._value(this.term);
                }
                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },
        widget: function() {
            return this.menu.element;
        },
        _value: function() {
            return this.valueMethod.apply(this.element, arguments);
        },
        _keyEvent: function(keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);
                event.preventDefault();
            }
        }
    });
    $.extend($.ui.autocomplete, {
        escapeRegex: function(value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function(array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function(value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function(amount) {
                    return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
                }
            }
        },
        __response: function(content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.children().hide();
            $("<div>").text(message).appendTo(this.liveRegion);
        }
    });
    var autocomplete = $.ui.autocomplete;
    var lastActive, baseClasses = "ui-button ui-widget ui-state-default ui-corner-all", typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only", formResetHandler = function() {
        var form = $(this);
        setTimeout(function() {
            form.find(":ui-button").button("refresh");
        }, 1);
    }, radioGroup = function(radio) {
        var name = radio.name, form = radio.form, radios = $([]);
        if (name) {
            name = name.replace(/'/g, "\\'");
            if (form) {
                radios = $(form).find("[name='" + name + "'][type=radio]");
            } else {
                radios = $("[name='" + name + "'][type=radio]", radio.ownerDocument).filter(function() {
                    return !this.form;
                });
            }
        }
        return radios;
    };
    $.widget("ui.button", {
        version: "1.11.4",
        defaultElement: "<button>",
        options: {
            disabled: null,
            text: true,
            label: null,
            icons: {
                primary: null,
                secondary: null
            }
        },
        _create: function() {
            this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, formResetHandler);
            if (typeof this.options.disabled !== "boolean") {
                this.options.disabled = !!this.element.prop("disabled");
            } else {
                this.element.prop("disabled", this.options.disabled);
            }
            this._determineButtonType();
            this.hasTitle = !!this.buttonElement.attr("title");
            var that = this, options = this.options, toggleButton = this.type === "checkbox" || this.type === "radio", activeClass = !toggleButton ? "ui-state-active" : "";
            if (options.label === null) {
                options.label = this.type === "input" ? this.buttonElement.val() : this.buttonElement.html();
            }
            this._hoverable(this.buttonElement);
            this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter" + this.eventNamespace, function() {
                if (options.disabled) {
                    return;
                }
                if (this === lastActive) {
                    $(this).addClass("ui-state-active");
                }
            }).bind("mouseleave" + this.eventNamespace, function() {
                if (options.disabled) {
                    return;
                }
                $(this).removeClass(activeClass);
            }).bind("click" + this.eventNamespace, function(event) {
                if (options.disabled) {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }
            });
            this._on({
                focus: function() {
                    this.buttonElement.addClass("ui-state-focus");
                },
                blur: function() {
                    this.buttonElement.removeClass("ui-state-focus");
                }
            });
            if (toggleButton) {
                this.element.bind("change" + this.eventNamespace, function() {
                    that.refresh();
                });
            }
            if (this.type === "checkbox") {
                this.buttonElement.bind("click" + this.eventNamespace, function() {
                    if (options.disabled) {
                        return false;
                    }
                });
            } else if (this.type === "radio") {
                this.buttonElement.bind("click" + this.eventNamespace, function() {
                    if (options.disabled) {
                        return false;
                    }
                    $(this).addClass("ui-state-active");
                    that.buttonElement.attr("aria-pressed", "true");
                    var radio = that.element[0];
                    radioGroup(radio).not(radio).map(function() {
                        return $(this).button("widget")[0];
                    }).removeClass("ui-state-active").attr("aria-pressed", "false");
                });
            } else {
                this.buttonElement.bind("mousedown" + this.eventNamespace, function() {
                    if (options.disabled) {
                        return false;
                    }
                    $(this).addClass("ui-state-active");
                    lastActive = this;
                    that.document.one("mouseup", function() {
                        lastActive = null;
                    });
                }).bind("mouseup" + this.eventNamespace, function() {
                    if (options.disabled) {
                        return false;
                    }
                    $(this).removeClass("ui-state-active");
                }).bind("keydown" + this.eventNamespace, function(event) {
                    if (options.disabled) {
                        return false;
                    }
                    if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
                        $(this).addClass("ui-state-active");
                    }
                }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                    $(this).removeClass("ui-state-active");
                });
                if (this.buttonElement.is("a")) {
                    this.buttonElement.keyup(function(event) {
                        if (event.keyCode === $.ui.keyCode.SPACE) {
                            $(this).click();
                        }
                    });
                }
            }
            this._setOption("disabled", options.disabled);
            this._resetButton();
        },
        _determineButtonType: function() {
            var ancestor, labelSelector, checked;
            if (this.element.is("[type=checkbox]")) {
                this.type = "checkbox";
            } else if (this.element.is("[type=radio]")) {
                this.type = "radio";
            } else if (this.element.is("input")) {
                this.type = "input";
            } else {
                this.type = "button";
            }
            if (this.type === "checkbox" || this.type === "radio") {
                ancestor = this.element.parents().last();
                labelSelector = "label[for='" + this.element.attr("id") + "']";
                this.buttonElement = ancestor.find(labelSelector);
                if (!this.buttonElement.length) {
                    ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
                    this.buttonElement = ancestor.filter(labelSelector);
                    if (!this.buttonElement.length) {
                        this.buttonElement = ancestor.find(labelSelector);
                    }
                }
                this.element.addClass("ui-helper-hidden-accessible");
                checked = this.element.is(":checked");
                if (checked) {
                    this.buttonElement.addClass("ui-state-active");
                }
                this.buttonElement.prop("aria-pressed", checked);
            } else {
                this.buttonElement = this.element;
            }
        },
        widget: function() {
            return this.buttonElement;
        },
        _destroy: function() {
            this.element.removeClass("ui-helper-hidden-accessible");
            this.buttonElement.removeClass(baseClasses + " ui-state-active " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());
            if (!this.hasTitle) {
                this.buttonElement.removeAttr("title");
            }
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "disabled") {
                this.widget().toggleClass("ui-state-disabled", !!value);
                this.element.prop("disabled", !!value);
                if (value) {
                    if (this.type === "checkbox" || this.type === "radio") {
                        this.buttonElement.removeClass("ui-state-focus");
                    } else {
                        this.buttonElement.removeClass("ui-state-focus ui-state-active");
                    }
                }
                return;
            }
            this._resetButton();
        },
        refresh: function() {
            var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
            if (isDisabled !== this.options.disabled) {
                this._setOption("disabled", isDisabled);
            }
            if (this.type === "radio") {
                radioGroup(this.element[0]).each(function() {
                    if ($(this).is(":checked")) {
                        $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true");
                    } else {
                        $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false");
                    }
                });
            } else if (this.type === "checkbox") {
                if (this.element.is(":checked")) {
                    this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true");
                } else {
                    this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false");
                }
            }
        },
        _resetButton: function() {
            if (this.type === "input") {
                if (this.options.label) {
                    this.element.val(this.options.label);
                }
                return;
            }
            var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = [];
            if (icons.primary || icons.secondary) {
                if (this.options.text) {
                    buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : icons.primary ? "-primary" : "-secondary"));
                }
                if (icons.primary) {
                    buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
                }
                if (icons.secondary) {
                    buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
                }
                if (!this.options.text) {
                    buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only");
                    if (!this.hasTitle) {
                        buttonElement.attr("title", $.trim(buttonText));
                    }
                }
            } else {
                buttonClasses.push("ui-button-text-only");
            }
            buttonElement.addClass(buttonClasses.join(" "));
        }
    });
    $.widget("ui.buttonset", {
        version: "1.11.4",
        options: {
            items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
        },
        _create: function() {
            this.element.addClass("ui-buttonset");
        },
        _init: function() {
            this.refresh();
        },
        _setOption: function(key, value) {
            if (key === "disabled") {
                this.buttons.button("option", key, value);
            }
            this._super(key, value);
        },
        refresh: function() {
            var rtl = this.element.css("direction") === "rtl", allButtons = this.element.find(this.options.items), existingButtons = allButtons.filter(":ui-button");
            allButtons.not(":ui-button").button();
            existingButtons.button("refresh");
            this.buttons = allButtons.map(function() {
                return $(this).button("widget")[0];
            }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end();
        },
        _destroy: function() {
            this.element.removeClass("ui-buttonset");
            this.buttons.map(function() {
                return $(this).button("widget")[0];
            }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
        }
    });
    var button = $.ui.button;
    $.extend($.ui, {
        datepicker: {
            version: "1.11.4"
        }
    });
    var datepicker_instActive;
    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {
            position = elem.css("position");
            if (position === "absolute" || position === "relative" || position === "fixed") {
                value = parseInt(elem.css("zIndex"), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }
        return 0;
    }
    function Datepicker() {
        this._curInst = null;
        this._keyEvent = false;
        this._disabledInputs = [];
        this._datepickerShowing = false;
        this._inDialog = false;
        this._mainDivId = "ui-datepicker-div";
        this._inlineClass = "ui-datepicker-inline";
        this._appendClass = "ui-datepicker-append";
        this._triggerClass = "ui-datepicker-trigger";
        this._dialogClass = "ui-datepicker-dialog";
        this._disableClass = "ui-datepicker-disabled";
        this._unselectableClass = "ui-datepicker-unselectable";
        this._currentClass = "ui-datepicker-current-day";
        this._dayOverClass = "ui-datepicker-days-cell-over";
        this.regional = [];
        this.regional[""] = {
            closeText: "Done",
            prevText: "Prev",
            nextText: "Next",
            currentText: "Today",
            monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
            dayNamesMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
            weekHeader: "Wk",
            dateFormat: "mm/dd/yy",
            firstDay: 0,
            isRTL: false,
            showMonthAfterYear: false,
            yearSuffix: ""
        };
        this._defaults = {
            showOn: "focus",
            showAnim: "fadeIn",
            showOptions: {},
            defaultDate: null,
            appendText: "",
            buttonText: "...",
            buttonImage: "",
            buttonImageOnly: false,
            hideIfNoPrevNext: false,
            navigationAsDateFormat: false,
            gotoCurrent: false,
            changeMonth: false,
            changeYear: false,
            yearRange: "c-10:c+10",
            showOtherMonths: false,
            selectOtherMonths: false,
            showWeek: false,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: "+10",
            minDate: null,
            maxDate: null,
            duration: "fast",
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: "",
            altFormat: "",
            constrainInput: true,
            showButtonPanel: false,
            autoSize: false,
            disabled: false
        };
        $.extend(this._defaults, this.regional[""]);
        this.regional.en = $.extend(true, {}, this.regional[""]);
        this.regional["en-US"] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }
    $.extend(Datepicker.prototype, {
        markerClassName: "hasDatepicker",
        maxRows: 4,
        _widgetDatepicker: function() {
            return this.dpDiv;
        },
        setDefaults: function(settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },
        _attachDatepicker: function(target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = nodeName === "div" || nodeName === "span";
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },
        _newInst: function(target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
            return {
                id: id,
                input: target,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: inline,
                dpDiv: !inline ? this.dpDiv : datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
            };
        },
        _connectDatepicker: function(target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
            this._autoSize(inst);
            $.data(target, "datepicker", inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },
        _attachments: function(input, inst) {
            var showOn, buttonText, buttonImage, appendText = this._get(inst, "appendText"), isRTL = this._get(inst, "isRTL");
            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                input[isRTL ? "before" : "after"](inst.append);
            }
            input.unbind("focus", this._showDatepicker);
            if (inst.trigger) {
                inst.trigger.remove();
            }
            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") {
                input.focus(this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") {
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");
                inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                })));
                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.click(function() {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },
        _autoSize: function(inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), dateFormat = this._get(inst, "dateFormat");
                if (dateFormat.match(/[DM]/)) {
                    findMax = function(names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort")));
                    date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay());
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },
        _inlineDatepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, "datepicker", inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            inst.dpDiv.css("display", "block");
        },
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
                this._dialogInput.keydown(this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], "datepicker", inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
            this._dialogInput.val(date);
            this._pos = pos ? pos.length ? pos : [ pos.pageX, pos.pageY ] : null;
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = [ browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY ];
            }
            this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], "datepicker", inst);
            return this;
        },
        _destroyDatepicker: function(target) {
            var nodeName, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, "datepicker");
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }
            if (datepicker_instActive === inst) {
                datepicker_instActive = null;
            }
        },
        _enableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger.filter("button").each(function() {
                    this.disabled = false;
                }).end().filter("img").css({
                    opacity: "1.0",
                    cursor: ""
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
            }
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            });
        },
        _disableDatepicker: function(target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, "datepicker");
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger.filter("button").each(function() {
                    this.disabled = true;
                }).end().filter("img").css({
                    opacity: "0.5",
                    cursor: "default"
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
            }
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return value === target ? null : value;
            });
            this._disabledInputs[this._disabledInputs.length] = target;
        },
        _isDisabledDatepicker: function(target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },
        _getInst: function(target) {
            try {
                return $.data(target, "datepicker");
            } catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },
        _optionDatepicker: function(target, name, value) {
            var settings, date, minDate, maxDate, inst = this._getInst(target);
            if (arguments.length === 2 && typeof name === "string") {
                return name === "defaults" ? $.extend({}, $.datepicker._defaults) : inst ? name === "all" ? $.extend({}, inst.settings) : this._get(inst, name) : null;
            }
            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }
                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                datepicker_extendRemove(inst.settings, settings);
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },
        _changeDatepicker: function(target, name, value) {
            this._optionDatepicker(target, name, value);
        },
        _refreshDatepicker: function(target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },
        _setDateDatepicker: function(target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },
        _getDateDatepicker: function(target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return inst ? this._getDate(inst) : null;
        },
        _doKeyDown: function(event) {
            var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                  case 9:
                    $.datepicker._hideDatepicker();
                    handled = false;
                    break;

                  case 13:
                    sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
                    if (sel[0]) {
                        $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                    }
                    onSelect = $.datepicker._get(inst, "onSelect");
                    if (onSelect) {
                        dateStr = $.datepicker._formatDate(inst);
                        onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
                    } else {
                        $.datepicker._hideDatepicker();
                    }
                    return false;

                  case 27:
                    $.datepicker._hideDatepicker();
                    break;

                  case 33:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    break;

                  case 34:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    break;

                  case 35:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._clearDate(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 36:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._gotoToday(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 37:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    }
                    break;

                  case 38:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, -7, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  case 39:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    }
                    break;

                  case 40:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, +7, "D");
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;

                  default:
                    handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) {
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },
        _doKeyPress: function(event) {
            var chars, chr, inst = $.datepicker._getInst(event.target);
            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
            }
        },
        _doKeyUp: function(event) {
            var date, inst = $.datepicker._getInst(event.target);
            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
                    if (date) {
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {}
            }
            return true;
        },
        _showDatepicker: function(input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") {
                input = $("input", input.parentNode)[0];
            }
            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
                return;
            }
            var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }
            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [ input, inst ]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);
            if ($.datepicker._inDialog) {
                input.value = "";
            }
            if (!$.datepicker._pos) {
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight;
            }
            isFixed = false;
            $(input).parents().each(function() {
                isFixed |= $(this).css("position") === "fixed";
                return !isFixed;
            });
            offset = {
                left: $.datepicker._pos[0],
                top: $.datepicker._pos[1]
            };
            $.datepicker._pos = null;
            inst.dpDiv.empty();
            inst.dpDiv.css({
                position: "absolute",
                display: "block",
                top: "-1000px"
            });
            $.datepicker._updateDatepicker(inst);
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
                display: "none",
                left: offset.left + "px",
                top: offset.top + "px"
            });
            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;
                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }
                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.focus();
                }
                $.datepicker._curInst = inst;
            }
        },
        _updateDatepicker: function(inst) {
            this.maxRows = 4;
            datepicker_instActive = inst;
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);
            var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17, activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");
            if (activeCell.length > 0) {
                datepicker_handleMouseover.apply(activeCell.get(0));
            }
            inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
            if (cols > 1) {
                inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em");
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.focus();
            }
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function() {
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },
        _shouldFocusInput: function(inst) {
            return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },
        _checkOffset: function(inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
            offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0;
            offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
            offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
            return offset;
        },
        _findPos: function(obj) {
            var position, inst = this._getInst(obj), isRTL = this._get(inst, "isRTL");
            while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }
            position = $(obj).offset();
            return [ position.left, position.top ];
        },
        _hideDatepicker: function(input) {
            var showAnim, duration, postProcess, onClose, inst = this._curInst;
            if (!inst || input && inst !== $.data(input, "datepicker")) {
                return;
            }
            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function() {
                    $.datepicker._tidyDialog(inst);
                };
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                } else {
                    inst.dpDiv[showAnim === "slideDown" ? "slideUp" : showAnim === "fadeIn" ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess);
                }
                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;
                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply(inst.input ? inst.input[0] : null, [ inst.input ? inst.input.val() : "", inst ]);
                }
                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px"
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },
        _tidyDialog: function(inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
        },
        _checkExternalClick: function(event) {
            if (!$.datepicker._curInst) {
                return;
            }
            var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
            if ($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
                $.datepicker._hideDatepicker();
            }
        },
        _adjustDate: function(id, offset, period) {
            var target = $(id), inst = this._getInst(target[0]);
            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), period);
            this._updateDatepicker(inst);
        },
        _gotoToday: function(id) {
            var date, target = $(id), inst = this._getInst(target[0]);
            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectMonthYear: function(id, select, period) {
            var target = $(id), inst = this._getInst(target[0]);
            inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectDay: function(id, month, year, td) {
            var inst, target = $(id);
            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }
            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $("a", td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
        },
        _clearDate: function(id) {
            var target = $(id);
            this._selectDate(target, "");
        },
        _selectDate: function(id, dateStr) {
            var onSelect, target = $(id), inst = this._getInst(target[0]);
            dateStr = dateStr != null ? dateStr : this._formatDate(inst);
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);
            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply(inst.input ? inst.input[0] : null, [ dateStr, inst ]);
            } else if (inst.input) {
                inst.input.trigger("change");
            }
            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof inst.input[0] !== "object") {
                    inst.input.focus();
                }
                this._lastInput = null;
            }
        },
        _updateAlternate: function(inst) {
            var altFormat, date, dateStr, altField = this._get(inst, "altField");
            if (altField) {
                altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).each(function() {
                    $(this).val(dateStr);
                });
            }
        },
        noWeekends: function(date) {
            var day = date.getDay();
            return [ day > 0 && day < 6, "" ];
        },
        iso8601Week: function(date) {
            var time, checkDate = new Date(date.getTime());
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
        },
        parseDate: function(format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }
            value = typeof value === "object" ? value.toString() : value + "";
            if (value === "") {
                return null;
            }
            var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            }, getNumber = function(match) {
                var isDoubled = lookAhead(match), size = match === "@" ? 14 : match === "!" ? 20 : match === "y" && isDoubled ? 4 : match === "o" ? 3 : 2, minSize = match === "y" ? size : 1, digits = new RegExp("^\\d{" + minSize + "," + size + "}"), num = value.substring(iValue).match(digits);
                if (!num) {
                    throw "Missing number at position " + iValue;
                }
                iValue += num[0].length;
                return parseInt(num[0], 10);
            }, getName = function(match, shortNames, longNames) {
                var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                    return [ [ k, v ] ];
                }).sort(function(a, b) {
                    return -(a[1].length - b[1].length);
                });
                $.each(names, function(i, pair) {
                    var name = pair[1];
                    if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                        index = pair[0];
                        iValue += name.length;
                        return false;
                    }
                });
                if (index !== -1) {
                    return index + 1;
                } else {
                    throw "Unknown name at position " + iValue;
                }
            }, checkLiteral = function() {
                if (value.charAt(iValue) !== format.charAt(iFormat)) {
                    throw "Unexpected literal at position " + iValue;
                }
                iValue++;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                      case "d":
                        day = getNumber("d");
                        break;

                      case "D":
                        getName("D", dayNamesShort, dayNames);
                        break;

                      case "o":
                        doy = getNumber("o");
                        break;

                      case "m":
                        month = getNumber("m");
                        break;

                      case "M":
                        month = getName("M", monthNamesShort, monthNames);
                        break;

                      case "y":
                        year = getNumber("y");
                        break;

                      case "@":
                        date = new Date(getNumber("@"));
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;

                      case "!":
                        date = new Date((getNumber("!") - this._ticksTo1970) / 1e4);
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;

                      case "'":
                        if (lookAhead("'")) {
                            checkLiteral();
                        } else {
                            literal = true;
                        }
                        break;

                      default:
                        checkLiteral();
                    }
                }
            }
            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }
            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
            }
            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }
            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw "Invalid date";
            }
            return date;
        },
        ATOM: "yy-mm-dd",
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y",
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd",
        _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 1e7,
        formatDate: function(format, date, settings) {
            if (!date) {
                return "";
            }
            var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            }, formatNumber = function(match, value, len) {
                var num = "" + value;
                if (lookAhead(match)) {
                    while (num.length < len) {
                        num = "0" + num;
                    }
                }
                return num;
            }, formatName = function(match, value, shortNames, longNames) {
                return lookAhead(match) ? longNames[value] : shortNames[value];
            }, output = "", literal = false;
            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                          case "d":
                            output += formatNumber("d", date.getDate(), 2);
                            break;

                          case "D":
                            output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                            break;

                          case "o":
                            output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                            break;

                          case "m":
                            output += formatNumber("m", date.getMonth() + 1, 2);
                            break;

                          case "M":
                            output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                            break;

                          case "y":
                            output += lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100;
                            break;

                          case "@":
                            output += date.getTime();
                            break;

                          case "!":
                            output += date.getTime() * 1e4 + this._ticksTo1970;
                            break;

                          case "'":
                            if (lookAhead("'")) {
                                output += "'";
                            } else {
                                literal = true;
                            }
                            break;

                          default:
                            output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },
        _possibleChars: function(format) {
            var iFormat, chars = "", literal = false, lookAhead = function(match) {
                var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                if (matches) {
                    iFormat++;
                }
                return matches;
            };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                      case "d":
                      case "m":
                      case "y":
                      case "@":
                        chars += "0123456789";
                        break;

                      case "D":
                      case "M":
                        return null;

                      case "'":
                        if (lookAhead("'")) {
                            chars += "'";
                        } else {
                            literal = true;
                        }
                        break;

                      default:
                        chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },
        _get: function(inst, name) {
            return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
        },
        _setDateFromField: function(inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }
            var dateFormat = this._get(inst, "dateFormat"), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = noDefault ? "" : dates;
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = dates ? date.getDate() : 0;
            inst.currentMonth = dates ? date.getMonth() : 0;
            inst.currentYear = dates ? date.getFullYear() : 0;
            this._adjustInstDate(inst);
        },
        _getDefaultDate: function(inst) {
            return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },
        _determineDate: function(inst, date, defaultDate) {
            var offsetNumeric = function(offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date;
            }, offsetString = function(offset) {
                try {
                    return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
                } catch (e) {}
                var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
                while (matches) {
                    switch (matches[2] || "d") {
                      case "d":
                      case "D":
                        day += parseInt(matches[1], 10);
                        break;

                      case "w":
                      case "W":
                        day += parseInt(matches[1], 10) * 7;
                        break;

                      case "m":
                      case "M":
                        month += parseInt(matches[1], 10);
                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;

                      case "y":
                      case "Y":
                        year += parseInt(matches[1], 10);
                        day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                        break;
                    }
                    matches = pattern.exec(offset);
                }
                return new Date(year, month, day);
            }, newDate = date == null || date === "" ? defaultDate : typeof date === "string" ? offsetString(date) : typeof date === "number" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
            newDate = newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate;
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },
        _daylightSavingAdjust: function(date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },
        _setDate: function(inst, date, noChange) {
            var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },
        _getDate: function(inst) {
            var startDate = !inst.currentYear || inst.input && inst.input.val() === "" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return startDate;
        },
        _attachHandlers: function(inst) {
            var stepMonths = this._get(inst, "stepMonths"), id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function() {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function() {
                        $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                        return false;
                    },
                    selectMonth: function() {
                        $.datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function() {
                        $.datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    }
                };
                $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },
        _generateHTML: function(inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), isRTL = this._get(inst, "isRTL"), showButtonPanel = this._get(inst, "showButtonPanel"), hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"), navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, "showCurrentAtPos"), stepMonths = this._get(inst, "stepMonths"), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
                maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
            prevText = this._get(inst, "prevText");
            prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
            prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>";
            nextText = this._get(inst, "nextText");
            nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
            next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>";
            currentText = this._get(inst, "currentText");
            gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today;
            currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
            controls = !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "";
            buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = isNaN(firstDay) ? 0 : firstDay;
            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";
            dow;
            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                              case 0:
                                calender += " ui-datepicker-group-first";
                                cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                break;

                              case numMonths[1] - 1:
                                calender += " ui-datepicker-group-last";
                                cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                break;

                              default:
                                calender += " ui-datepicker-group-middle";
                                cornerClass = "";
                                break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
                    thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "";
                    for (dow = 0; dow < 7; dow++) {
                        day = (dow + firstDay) % 7;
                        thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7);
                    numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) {
                        calender += "<tr>";
                        tbody = !showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>";
                        for (dow = 0; dow < 7; dow++) {
                            daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [ printDate ]) : [ true, "" ];
                            otherMonth = printDate.getMonth() !== drawMonth;
                            unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                            tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>") + "</td>";
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, "changeMonth"), changeYear = this._get(inst, "changeYear"), showMonthAfterYear = this._get(inst, "showMonthAfterYear"), html = "<div class='ui-datepicker-title'>", monthHtml = "";
            if (secondary || !changeMonth) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
            } else {
                inMinYear = minDate && minDate.getFullYear() === drawYear;
                inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }
            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function(value) {
                        var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                        return isNaN(year) ? thisYear : year;
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = minDate ? Math.max(year, minDate.getFullYear()) : year;
                    endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for (;year <= endYear; year++) {
                        inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";
                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
            }
            html += "</div>";
            return html;
        },
        _adjustInstDate: function(inst, offset, period) {
            var year = inst.drawYear + (period === "Y" ? offset : 0), month = inst.drawMonth + (period === "M" ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },
        _restrictMinMax: function(inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), newDate = minDate && date < minDate ? minDate : date;
            return maxDate && newDate > maxDate ? maxDate : newDate;
        },
        _notifyChange: function(inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply(inst.input ? inst.input[0] : null, [ inst.selectedYear, inst.selectedMonth + 1, inst ]);
            }
        },
        _getNumberOfMonths: function(inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return numMonths == null ? [ 1, 1 ] : typeof numMonths === "number" ? [ 1, numMonths ] : numMonths;
        },
        _getMinMaxDate: function(inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },
        _getDaysInMonth: function(year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay();
        },
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },
        _isInRange: function(inst, date) {
            var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), minYear = null, maxYear = null, years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }
            return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
        },
        _getFormatConfig: function(inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"),
                dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"),
                monthNames: this._get(inst, "monthNames")
            };
        },
        _formatDate: function(inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = day ? typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    });
    function datepicker_bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.delegate(selector, "mouseout", function() {
            $(this).removeClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).removeClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).removeClass("ui-datepicker-next-hover");
            }
        }).delegate(selector, "mouseover", datepicker_handleMouseover);
    }
    function datepicker_handleMouseover() {
        if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
            $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
            $(this).addClass("ui-state-hover");
            if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                $(this).addClass("ui-datepicker-prev-hover");
            }
            if (this.className.indexOf("ui-datepicker-next") !== -1) {
                $(this).addClass("ui-datepicker-next-hover");
            }
        }
    }
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }
    $.fn.datepicker = function(options) {
        if (!this.length) {
            return this;
        }
        if (!$.datepicker.initialized) {
            $(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this[0] ].concat(otherArgs));
        }
        return this.each(function() {
            typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [ this ].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
        });
    };
    $.datepicker = new Datepicker();
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.11.4";
    var datepicker = $.datepicker;
    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "drag",
        options: {
            addClasses: true,
            appendTo: "parent",
            axis: false,
            connectToSortable: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            grid: false,
            handle: false,
            helper: "original",
            iframeFix: false,
            opacity: false,
            refreshPositions: false,
            revert: false,
            revertDuration: 500,
            scope: "default",
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: false,
            snapMode: "both",
            snapTolerance: 20,
            stack: false,
            zIndex: false,
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
            if (this.options.helper === "original") {
                this._setPositionRelative();
            }
            if (this.options.addClasses) {
                this.element.addClass("ui-draggable");
            }
            if (this.options.disabled) {
                this.element.addClass("ui-draggable-disabled");
            }
            this._setHandleClassName();
            this._mouseInit();
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "handle") {
                this._removeHandleClassName();
                this._setHandleClassName();
            }
        },
        _destroy: function() {
            if ((this.helper || this.element).is(".ui-draggable-dragging")) {
                this.destroyOnClear = true;
                return;
            }
            this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
            this._removeHandleClassName();
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var o = this.options;
            this._blurActiveElement(event);
            if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
                return false;
            }
            this.handle = this._getHandle(event);
            if (!this.handle) {
                return false;
            }
            this._blockFrames(o.iframeFix === true ? "iframe" : o.iframeFix);
            return true;
        },
        _blockFrames: function(selector) {
            this.iframeBlocks = this.document.find(selector).map(function() {
                var iframe = $(this);
                return $("<div>").css("position", "absolute").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];
            });
        },
        _unblockFrames: function() {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },
        _blurActiveElement: function(event) {
            var document = this.document[0];
            if (!this.handleElement.is(event.target)) {
                return;
            }
            try {
                if (document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body") {
                    $(document.activeElement).blur();
                }
            } catch (error) {}
        },
        _mouseStart: function(event) {
            var o = this.options;
            this.helper = this._createHelper(event);
            this.helper.addClass("ui-draggable-dragging");
            this._cacheHelperProportions();
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }
            this._cacheMargins();
            this.cssPosition = this.helper.css("position");
            this.scrollParent = this.helper.scrollParent(true);
            this.offsetParent = this.helper.offsetParent();
            this.hasFixedAncestor = this.helper.parents().filter(function() {
                return $(this).css("position") === "fixed";
            }).length > 0;
            this.positionAbs = this.element.offset();
            this._refreshOffsets(event);
            this.originalPosition = this.position = this._generatePosition(event, false);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
            this._setContainment();
            if (this._trigger("start", event) === false) {
                this._clear();
                return false;
            }
            this._cacheHelperProportions();
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }
            this._normalizeRightBottom();
            this._mouseDrag(event, true);
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStart(this, event);
            }
            return true;
        },
        _refreshOffsets: function(event) {
            this.offset = {
                top: this.positionAbs.top - this.margins.top,
                left: this.positionAbs.left - this.margins.left,
                scroll: false,
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            };
            this.offset.click = {
                left: event.pageX - this.offset.left,
                top: event.pageY - this.offset.top
            };
        },
        _mouseDrag: function(event, noPropagation) {
            if (this.hasFixedAncestor) {
                this.offset.parent = this._getParentOffset();
            }
            this.position = this._generatePosition(event, true);
            this.positionAbs = this._convertPositionTo("absolute");
            if (!noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === false) {
                    this._mouseUp({});
                    return false;
                }
                this.position = ui.position;
            }
            this.helper[0].style.left = this.position.left + "px";
            this.helper[0].style.top = this.position.top + "px";
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }
            return false;
        },
        _mouseStop: function(event) {
            var that = this, dropped = false;
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                dropped = $.ui.ddmanager.drop(this, event);
            }
            if (this.dropped) {
                dropped = this.dropped;
                this.dropped = false;
            }
            if (this.options.revert === "invalid" && !dropped || this.options.revert === "valid" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
                $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                    if (that._trigger("stop", event) !== false) {
                        that._clear();
                    }
                });
            } else {
                if (this._trigger("stop", event) !== false) {
                    this._clear();
                }
            }
            return false;
        },
        _mouseUp: function(event) {
            this._unblockFrames();
            if ($.ui.ddmanager) {
                $.ui.ddmanager.dragStop(this, event);
            }
            if (this.handleElement.is(event.target)) {
                this.element.focus();
            }
            return $.ui.mouse.prototype._mouseUp.call(this, event);
        },
        cancel: function() {
            if (this.helper.is(".ui-draggable-dragging")) {
                this._mouseUp({});
            } else {
                this._clear();
            }
            return this;
        },
        _getHandle: function(event) {
            return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
        },
        _setHandleClassName: function() {
            this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;
            this.handleElement.addClass("ui-draggable-handle");
        },
        _removeHandleClassName: function() {
            this.handleElement.removeClass("ui-draggable-handle");
        },
        _createHelper: function(event) {
            var o = this.options, helperIsFunction = $.isFunction(o.helper), helper = helperIsFunction ? $(o.helper.apply(this.element[0], [ event ])) : o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element;
            if (!helper.parents("body").length) {
                helper.appendTo(o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo);
            }
            if (helperIsFunction && helper[0] === this.element[0]) {
                this._setPositionRelative();
            }
            if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css("position"))) {
                helper.css("position", "absolute");
            }
            return helper;
        },
        _setPositionRelative: function() {
            if (!/^(?:r|a|f)/.test(this.element.css("position"))) {
                this.element[0].style.position = "relative";
            }
        },
        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },
        _isRootNode: function(element) {
            return /(html|body)/i.test(element.tagName) || element === this.document[0];
        },
        _getParentOffset: function() {
            var po = this.offsetParent.offset(), document = this.document[0];
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }
            if (this._isRootNode(this.offsetParent[0])) {
                po = {
                    top: 0,
                    left: 0
                };
            }
            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if (this.cssPosition !== "relative") {
                return {
                    top: 0,
                    left: 0
                };
            }
            var p = this.element.position(), scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return {
                top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
                left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
            };
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var isUserScrollable, c, ce, o = this.options, document = this.document[0];
            this.relativeContainer = null;
            if (!o.containment) {
                this.containment = null;
                return;
            }
            if (o.containment === "window") {
                this.containment = [ $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                return;
            }
            if (o.containment === "document") {
                this.containment = [ 0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
                return;
            }
            if (o.containment.constructor === Array) {
                this.containment = o.containment;
                return;
            }
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            c = $(o.containment);
            ce = c[0];
            if (!ce) {
                return;
            }
            isUserScrollable = /(scroll|auto)/.test(c.css("overflow"));
            this.containment = [ (parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ];
            this.relativeContainer = c;
        },
        _convertPositionTo: function(d, pos) {
            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1, scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod
            };
        },
        _generatePosition: function(event, constrainPosition) {
            var containment, co, top, left, o = this.options, scrollIsRootNode = this._isRootNode(this.scrollParent[0]), pageX = event.pageX, pageY = event.pageY;
            if (!scrollIsRootNode || !this.offset.scroll) {
                this.offset.scroll = {
                    top: this.scrollParent.scrollTop(),
                    left: this.scrollParent.scrollLeft()
                };
            }
            if (constrainPosition) {
                if (this.containment) {
                    if (this.relativeContainer) {
                        co = this.relativeContainer.offset();
                        containment = [ this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top ];
                    } else {
                        containment = this.containment;
                    }
                    if (event.pageX - this.offset.click.left < containment[0]) {
                        pageX = containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < containment[1]) {
                        pageY = containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > containment[2]) {
                        pageX = containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > containment[3]) {
                        pageY = containment[3] + this.offset.click.top;
                    }
                }
                if (o.grid) {
                    top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
                    pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                    left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
                    pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                }
                if (o.axis === "y") {
                    pageX = this.originalPageX;
                }
                if (o.axis === "x") {
                    pageY = this.originalPageY;
                }
            }
            return {
                top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),
                left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)
            };
        },
        _clear: function() {
            this.helper.removeClass("ui-draggable-dragging");
            if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
                this.helper.remove();
            }
            this.helper = null;
            this.cancelHelperRemoval = false;
            if (this.destroyOnClear) {
                this.destroy();
            }
        },
        _normalizeRightBottom: function() {
            if (this.options.axis !== "y" && this.helper.css("right") !== "auto") {
                this.helper.width(this.helper.width());
                this.helper.css("right", "auto");
            }
            if (this.options.axis !== "x" && this.helper.css("bottom") !== "auto") {
                this.helper.height(this.helper.height());
                this.helper.css("bottom", "auto");
            }
        },
        _trigger: function(type, event, ui) {
            ui = ui || this._uiHash();
            $.ui.plugin.call(this, type, [ event, ui, this ], true);
            if (/^(drag|start|stop)/.test(type)) {
                this.positionAbs = this._convertPositionTo("absolute");
                ui.offset = this.positionAbs;
            }
            return $.Widget.prototype._trigger.call(this, type, event, ui);
        },
        plugins: {},
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }
    });
    $.ui.plugin.add("draggable", "connectToSortable", {
        start: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });
            draggable.sortables = [];
            $(draggable.options.connectToSortable).each(function() {
                var sortable = $(this).sortable("instance");
                if (sortable && !sortable.options.disabled) {
                    draggable.sortables.push(sortable);
                    sortable.refreshPositions();
                    sortable._trigger("activate", event, uiSortable);
                }
            });
        },
        stop: function(event, ui, draggable) {
            var uiSortable = $.extend({}, ui, {
                item: draggable.element
            });
            draggable.cancelHelperRemoval = false;
            $.each(draggable.sortables, function() {
                var sortable = this;
                if (sortable.isOver) {
                    sortable.isOver = 0;
                    draggable.cancelHelperRemoval = true;
                    sortable.cancelHelperRemoval = false;
                    sortable._storedCSS = {
                        position: sortable.placeholder.css("position"),
                        top: sortable.placeholder.css("top"),
                        left: sortable.placeholder.css("left")
                    };
                    sortable._mouseStop(event);
                    sortable.options.helper = sortable.options._helper;
                } else {
                    sortable.cancelHelperRemoval = true;
                    sortable._trigger("deactivate", event, uiSortable);
                }
            });
        },
        drag: function(event, ui, draggable) {
            $.each(draggable.sortables, function() {
                var innermostIntersecting = false, sortable = this;
                sortable.positionAbs = draggable.positionAbs;
                sortable.helperProportions = draggable.helperProportions;
                sortable.offset.click = draggable.offset.click;
                if (sortable._intersectsWith(sortable.containerCache)) {
                    innermostIntersecting = true;
                    $.each(draggable.sortables, function() {
                        this.positionAbs = draggable.positionAbs;
                        this.helperProportions = draggable.helperProportions;
                        this.offset.click = draggable.offset.click;
                        if (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) {
                            innermostIntersecting = false;
                        }
                        return innermostIntersecting;
                    });
                }
                if (innermostIntersecting) {
                    if (!sortable.isOver) {
                        sortable.isOver = 1;
                        draggable._parent = ui.helper.parent();
                        sortable.currentItem = ui.helper.appendTo(sortable.element).data("ui-sortable-item", true);
                        sortable.options._helper = sortable.options.helper;
                        sortable.options.helper = function() {
                            return ui.helper[0];
                        };
                        event.target = sortable.currentItem[0];
                        sortable._mouseCapture(event, true);
                        sortable._mouseStart(event, true, true);
                        sortable.offset.click.top = draggable.offset.click.top;
                        sortable.offset.click.left = draggable.offset.click.left;
                        sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;
                        sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;
                        draggable._trigger("toSortable", event);
                        draggable.dropped = sortable.element;
                        $.each(draggable.sortables, function() {
                            this.refreshPositions();
                        });
                        draggable.currentItem = draggable.element;
                        sortable.fromOutside = draggable;
                    }
                    if (sortable.currentItem) {
                        sortable._mouseDrag(event);
                        ui.position = sortable.position;
                    }
                } else {
                    if (sortable.isOver) {
                        sortable.isOver = 0;
                        sortable.cancelHelperRemoval = true;
                        sortable.options._revert = sortable.options.revert;
                        sortable.options.revert = false;
                        sortable._trigger("out", event, sortable._uiHash(sortable));
                        sortable._mouseStop(event, true);
                        sortable.options.revert = sortable.options._revert;
                        sortable.options.helper = sortable.options._helper;
                        if (sortable.placeholder) {
                            sortable.placeholder.remove();
                        }
                        ui.helper.appendTo(draggable._parent);
                        draggable._refreshOffsets(event);
                        ui.position = draggable._generatePosition(event, true);
                        draggable._trigger("fromSortable", event);
                        draggable.dropped = false;
                        $.each(draggable.sortables, function() {
                            this.refreshPositions();
                        });
                    }
                }
            });
        }
    });
    $.ui.plugin.add("draggable", "cursor", {
        start: function(event, ui, instance) {
            var t = $("body"), o = instance.options;
            if (t.css("cursor")) {
                o._cursor = t.css("cursor");
            }
            t.css("cursor", o.cursor);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._cursor) {
                $("body").css("cursor", o._cursor);
            }
        }
    });
    $.ui.plugin.add("draggable", "opacity", {
        start: function(event, ui, instance) {
            var t = $(ui.helper), o = instance.options;
            if (t.css("opacity")) {
                o._opacity = t.css("opacity");
            }
            t.css("opacity", o.opacity);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._opacity) {
                $(ui.helper).css("opacity", o._opacity);
            }
        }
    });
    $.ui.plugin.add("draggable", "scroll", {
        start: function(event, ui, i) {
            if (!i.scrollParentNotHidden) {
                i.scrollParentNotHidden = i.helper.scrollParent(false);
            }
            if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== "HTML") {
                i.overflowOffset = i.scrollParentNotHidden.offset();
            }
        },
        drag: function(event, ui, i) {
            var o = i.options, scrolled = false, scrollParent = i.scrollParentNotHidden[0], document = i.document[0];
            if (scrollParent !== document && scrollParent.tagName !== "HTML") {
                if (!o.axis || o.axis !== "x") {
                    if (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
                    } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
                        scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
                    }
                }
                if (!o.axis || o.axis !== "y") {
                    if (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
                        scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
                    }
                }
            } else {
                if (!o.axis || o.axis !== "x") {
                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }
                }
                if (!o.axis || o.axis !== "y") {
                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }
                }
            }
            if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(i, event);
            }
        }
    });
    $.ui.plugin.add("draggable", "snap", {
        start: function(event, ui, i) {
            var o = i.options;
            i.snapElements = [];
            $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function() {
                var $t = $(this), $o = $t.offset();
                if (this !== i.element[0]) {
                    i.snapElements.push({
                        item: this,
                        width: $t.outerWidth(),
                        height: $t.outerHeight(),
                        top: $o.top,
                        left: $o.left
                    });
                }
            });
        },
        drag: function(event, ui, inst) {
            var ts, bs, ls, rs, l, r, t, b, i, first, o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
            for (i = inst.snapElements.length - 1; i >= 0; i--) {
                l = inst.snapElements[i].left - inst.margins.left;
                r = l + inst.snapElements[i].width;
                t = inst.snapElements[i].top - inst.margins.top;
                b = t + inst.snapElements[i].height;
                if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
                    if (inst.snapElements[i].snapping) {
                        inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                            snapItem: inst.snapElements[i].item
                        }));
                    }
                    inst.snapElements[i].snapping = false;
                    continue;
                }
                if (o.snapMode !== "inner") {
                    ts = Math.abs(t - y2) <= d;
                    bs = Math.abs(b - y1) <= d;
                    ls = Math.abs(l - x2) <= d;
                    rs = Math.abs(r - x1) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t - inst.helperProportions.height,
                            left: 0
                        }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b,
                            left: 0
                        }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l - inst.helperProportions.width
                        }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r
                        }).left;
                    }
                }
                first = ts || bs || ls || rs;
                if (o.snapMode !== "outer") {
                    ts = Math.abs(t - y1) <= d;
                    bs = Math.abs(b - y2) <= d;
                    ls = Math.abs(l - x1) <= d;
                    rs = Math.abs(r - x2) <= d;
                    if (ts) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: t,
                            left: 0
                        }).top;
                    }
                    if (bs) {
                        ui.position.top = inst._convertPositionTo("relative", {
                            top: b - inst.helperProportions.height,
                            left: 0
                        }).top;
                    }
                    if (ls) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: l
                        }).left;
                    }
                    if (rs) {
                        ui.position.left = inst._convertPositionTo("relative", {
                            top: 0,
                            left: r - inst.helperProportions.width
                        }).left;
                    }
                }
                if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
                    inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                        snapItem: inst.snapElements[i].item
                    }));
                }
                inst.snapElements[i].snapping = ts || bs || ls || rs || first;
            }
        }
    });
    $.ui.plugin.add("draggable", "stack", {
        start: function(event, ui, instance) {
            var min, o = instance.options, group = $.makeArray($(o.stack)).sort(function(a, b) {
                return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
            });
            if (!group.length) {
                return;
            }
            min = parseInt($(group[0]).css("zIndex"), 10) || 0;
            $(group).each(function(i) {
                $(this).css("zIndex", min + i);
            });
            this.css("zIndex", min + group.length);
        }
    });
    $.ui.plugin.add("draggable", "zIndex", {
        start: function(event, ui, instance) {
            var t = $(ui.helper), o = instance.options;
            if (t.css("zIndex")) {
                o._zIndex = t.css("zIndex");
            }
            t.css("zIndex", o.zIndex);
        },
        stop: function(event, ui, instance) {
            var o = instance.options;
            if (o._zIndex) {
                $(ui.helper).css("zIndex", o._zIndex);
            }
        }
    });
    var draggable = $.ui.draggable;
    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: false,
            animate: false,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: false,
            autoHide: false,
            containment: false,
            ghost: false,
            grid: false,
            handles: "e,s,se",
            helper: false,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            zIndex: 90,
            resize: null,
            start: null,
            stop: null
        },
        _num: function(value) {
            return parseInt(value, 10) || 0;
        },
        _isNumber: function(value) {
            return !isNaN(parseInt(value, 10));
        },
        _hasScroll: function(el, a) {
            if ($(el).css("overflow") === "hidden") {
                return false;
            }
            var scroll = a && a === "left" ? "scrollLeft" : "scrollTop", has = false;
            if (el[scroll] > 0) {
                return true;
            }
            el[scroll] = 1;
            has = el[scroll] > 0;
            el[scroll] = 0;
            return has;
        },
        _create: function() {
            var n, i, handle, axis, hname, that = this, o = this.options;
            this.element.addClass("ui-resizable");
            $.extend(this, {
                _aspectRatio: !!o.aspectRatio,
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            });
            if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {
                this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                    position: this.element.css("position"),
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    top: this.element.css("top"),
                    left: this.element.css("left")
                }));
                this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance"));
                this.elementIsWrapper = true;
                this.element.css({
                    marginLeft: this.originalElement.css("marginLeft"),
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom")
                });
                this.originalElement.css({
                    marginLeft: 0,
                    marginTop: 0,
                    marginRight: 0,
                    marginBottom: 0
                });
                this.originalResizeStyle = this.originalElement.css("resize");
                this.originalElement.css("resize", "none");
                this._proportionallyResizeElements.push(this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                }));
                this.originalElement.css({
                    margin: this.originalElement.css("margin")
                });
                this._proportionallyResize();
            }
            this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            });
            this._handles = $();
            if (this.handles.constructor === String) {
                if (this.handles === "all") {
                    this.handles = "n,e,s,w,se,sw,ne,nw";
                }
                n = this.handles.split(",");
                this.handles = {};
                for (i = 0; i < n.length; i++) {
                    handle = $.trim(n[i]);
                    hname = "ui-resizable-" + handle;
                    axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
                    axis.css({
                        zIndex: o.zIndex
                    });
                    if ("se" === handle) {
                        axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
                    }
                    this.handles[handle] = ".ui-resizable-" + handle;
                    this.element.append(axis);
                }
            }
            this._renderAxis = function(target) {
                var i, axis, padPos, padWrapper;
                target = target || this.element;
                for (i in this.handles) {
                    if (this.handles[i].constructor === String) {
                        this.handles[i] = this.element.children(this.handles[i]).first().show();
                    } else if (this.handles[i].jquery || this.handles[i].nodeType) {
                        this.handles[i] = $(this.handles[i]);
                        this._on(this.handles[i], {
                            mousedown: that._mouseDown
                        });
                    }
                    if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {
                        axis = $(this.handles[i], this.element);
                        padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
                        padPos = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join("");
                        target.css(padPos, padWrapper);
                        this._proportionallyResize();
                    }
                    this._handles = this._handles.add(this.handles[i]);
                }
            };
            this._renderAxis(this.element);
            this._handles = this._handles.add(this.element.find(".ui-resizable-handle"));
            this._handles.disableSelection();
            this._handles.mouseover(function() {
                if (!that.resizing) {
                    if (this.className) {
                        axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
                    }
                    that.axis = axis && axis[1] ? axis[1] : "se";
                }
            });
            if (o.autoHide) {
                this._handles.hide();
                $(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
                    if (o.disabled) {
                        return;
                    }
                    $(this).removeClass("ui-resizable-autohide");
                    that._handles.show();
                }).mouseleave(function() {
                    if (o.disabled) {
                        return;
                    }
                    if (!that.resizing) {
                        $(this).addClass("ui-resizable-autohide");
                        that._handles.hide();
                    }
                });
            }
            this._mouseInit();
        },
        _destroy: function() {
            this._mouseDestroy();
            var wrapper, _destroy = function(exp) {
                $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
            };
            if (this.elementIsWrapper) {
                _destroy(this.element);
                wrapper = this.element;
                this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter(wrapper);
                wrapper.remove();
            }
            this.originalElement.css("resize", this.originalResizeStyle);
            _destroy(this.originalElement);
            return this;
        },
        _mouseCapture: function(event) {
            var i, handle, capture = false;
            for (i in this.handles) {
                handle = $(this.handles[i])[0];
                if (handle === event.target || $.contains(handle, event.target)) {
                    capture = true;
                }
            }
            return !this.options.disabled && capture;
        },
        _mouseStart: function(event) {
            var curleft, curtop, cursor, o = this.options, el = this.element;
            this.resizing = true;
            this._renderProxy();
            curleft = this._num(this.helper.css("left"));
            curtop = this._num(this.helper.css("top"));
            if (o.containment) {
                curleft += $(o.containment).scrollLeft() || 0;
                curtop += $(o.containment).scrollTop() || 0;
            }
            this.offset = this.helper.offset();
            this.position = {
                left: curleft,
                top: curtop
            };
            this.size = this._helper ? {
                width: this.helper.width(),
                height: this.helper.height()
            } : {
                width: el.width(),
                height: el.height()
            };
            this.originalSize = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            };
            this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            };
            this.originalPosition = {
                left: curleft,
                top: curtop
            };
            this.originalMousePosition = {
                left: event.pageX,
                top: event.pageY
            };
            this.aspectRatio = typeof o.aspectRatio === "number" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
            cursor = $(".ui-resizable-" + this.axis).css("cursor");
            $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
            el.addClass("ui-resizable-resizing");
            this._propagate("start", event);
            return true;
        },
        _mouseDrag: function(event) {
            var data, props, smp = this.originalMousePosition, a = this.axis, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
            this._updatePrevProperties();
            if (!trigger) {
                return false;
            }
            data = trigger.apply(this, [ event, dx, dy ]);
            this._updateVirtualBoundaries(event.shiftKey);
            if (this._aspectRatio || event.shiftKey) {
                data = this._updateRatio(data, event);
            }
            data = this._respectSize(data, event);
            this._updateCache(data);
            this._propagate("resize", event);
            props = this._applyChanges();
            if (!this._helper && this._proportionallyResizeElements.length) {
                this._proportionallyResize();
            }
            if (!$.isEmptyObject(props)) {
                this._updatePrevProperties();
                this._trigger("resize", event, this.ui());
                this._applyChanges();
            }
            return false;
        },
        _mouseStop: function(event) {
            this.resizing = false;
            var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
            if (this._helper) {
                pr = this._proportionallyResizeElements;
                ista = pr.length && /textarea/i.test(pr[0].nodeName);
                soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
                soffsetw = ista ? 0 : that.sizeDiff.width;
                s = {
                    width: that.helper.width() - soffsetw,
                    height: that.helper.height() - soffseth
                };
                left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null;
                top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
                if (!o.animate) {
                    this.element.css($.extend(s, {
                        top: top,
                        left: left
                    }));
                }
                that.helper.height(that.size.height);
                that.helper.width(that.size.width);
                if (this._helper && !o.animate) {
                    this._proportionallyResize();
                }
            }
            $("body").css("cursor", "auto");
            this.element.removeClass("ui-resizable-resizing");
            this._propagate("stop", event);
            if (this._helper) {
                this.helper.remove();
            }
            return false;
        },
        _updatePrevProperties: function() {
            this.prevPosition = {
                top: this.position.top,
                left: this.position.left
            };
            this.prevSize = {
                width: this.size.width,
                height: this.size.height
            };
        },
        _applyChanges: function() {
            var props = {};
            if (this.position.top !== this.prevPosition.top) {
                props.top = this.position.top + "px";
            }
            if (this.position.left !== this.prevPosition.left) {
                props.left = this.position.left + "px";
            }
            if (this.size.width !== this.prevSize.width) {
                props.width = this.size.width + "px";
            }
            if (this.size.height !== this.prevSize.height) {
                props.height = this.size.height + "px";
            }
            this.helper.css(props);
            return props;
        },
        _updateVirtualBoundaries: function(forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
            b = {
                minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
                minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
            };
            if (this._aspectRatio || forceAspectRatio) {
                pMinWidth = b.minHeight * this.aspectRatio;
                pMinHeight = b.minWidth / this.aspectRatio;
                pMaxWidth = b.maxHeight * this.aspectRatio;
                pMaxHeight = b.maxWidth / this.aspectRatio;
                if (pMinWidth > b.minWidth) {
                    b.minWidth = pMinWidth;
                }
                if (pMinHeight > b.minHeight) {
                    b.minHeight = pMinHeight;
                }
                if (pMaxWidth < b.maxWidth) {
                    b.maxWidth = pMaxWidth;
                }
                if (pMaxHeight < b.maxHeight) {
                    b.maxHeight = pMaxHeight;
                }
            }
            this._vBoundaries = b;
        },
        _updateCache: function(data) {
            this.offset = this.helper.offset();
            if (this._isNumber(data.left)) {
                this.position.left = data.left;
            }
            if (this._isNumber(data.top)) {
                this.position.top = data.top;
            }
            if (this._isNumber(data.height)) {
                this.size.height = data.height;
            }
            if (this._isNumber(data.width)) {
                this.size.width = data.width;
            }
        },
        _updateRatio: function(data) {
            var cpos = this.position, csize = this.size, a = this.axis;
            if (this._isNumber(data.height)) {
                data.width = data.height * this.aspectRatio;
            } else if (this._isNumber(data.width)) {
                data.height = data.width / this.aspectRatio;
            }
            if (a === "sw") {
                data.left = cpos.left + (csize.width - data.width);
                data.top = null;
            }
            if (a === "nw") {
                data.top = cpos.top + (csize.height - data.height);
                data.left = cpos.left + (csize.width - data.width);
            }
            return data;
        },
        _respectSize: function(data) {
            var o = this._vBoundaries, a = this.axis, ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
            if (isminw) {
                data.width = o.minWidth;
            }
            if (isminh) {
                data.height = o.minHeight;
            }
            if (ismaxw) {
                data.width = o.maxWidth;
            }
            if (ismaxh) {
                data.height = o.maxHeight;
            }
            if (isminw && cw) {
                data.left = dw - o.minWidth;
            }
            if (ismaxw && cw) {
                data.left = dw - o.maxWidth;
            }
            if (isminh && ch) {
                data.top = dh - o.minHeight;
            }
            if (ismaxh && ch) {
                data.top = dh - o.maxHeight;
            }
            if (!data.width && !data.height && !data.left && data.top) {
                data.top = null;
            } else if (!data.width && !data.height && !data.top && data.left) {
                data.left = null;
            }
            return data;
        },
        _getPaddingPlusBorderDimensions: function(element) {
            var i = 0, widths = [], borders = [ element.css("borderTopWidth"), element.css("borderRightWidth"), element.css("borderBottomWidth"), element.css("borderLeftWidth") ], paddings = [ element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft") ];
            for (;i < 4; i++) {
                widths[i] = parseInt(borders[i], 10) || 0;
                widths[i] += parseInt(paddings[i], 10) || 0;
            }
            return {
                height: widths[0] + widths[2],
                width: widths[1] + widths[3]
            };
        },
        _proportionallyResize: function() {
            if (!this._proportionallyResizeElements.length) {
                return;
            }
            var prel, i = 0, element = this.helper || this.element;
            for (;i < this._proportionallyResizeElements.length; i++) {
                prel = this._proportionallyResizeElements[i];
                if (!this.outerDimensions) {
                    this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
                }
                prel.css({
                    height: element.height() - this.outerDimensions.height || 0,
                    width: element.width() - this.outerDimensions.width || 0
                });
            }
        },
        _renderProxy: function() {
            var el = this.element, o = this.options;
            this.elementOffset = el.offset();
            if (this._helper) {
                this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
                this.helper.addClass(this._helper).css({
                    width: this.element.outerWidth() - 1,
                    height: this.element.outerHeight() - 1,
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex
                });
                this.helper.appendTo("body").disableSelection();
            } else {
                this.helper = this.element;
            }
        },
        _change: {
            e: function(event, dx) {
                return {
                    width: this.originalSize.width + dx
                };
            },
            w: function(event, dx) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    left: sp.left + dx,
                    width: cs.width - dx
                };
            },
            n: function(event, dx, dy) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    top: sp.top + dy,
                    height: cs.height - dy
                };
            },
            s: function(event, dx, dy) {
                return {
                    height: this.originalSize.height + dy
                };
            },
            se: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            sw: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            },
            ne: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            nw: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            }
        },
        _propagate: function(n, event) {
            $.ui.plugin.call(this, n, [ event, this.ui() ]);
            n !== "resize" && this._trigger(n, event, this.ui());
        },
        plugins: {},
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }
    });
    $.ui.plugin.add("resizable", "animate", {
        stop: function(event) {
            var that = $(this).resizable("instance"), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
                width: that.size.width - soffsetw,
                height: that.size.height - soffseth
            }, left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
            that.element.animate($.extend(style, top && left ? {
                top: top,
                left: left
            } : {}), {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function() {
                    var data = {
                        width: parseInt(that.element.css("width"), 10),
                        height: parseInt(that.element.css("height"), 10),
                        top: parseInt(that.element.css("top"), 10),
                        left: parseInt(that.element.css("left"), 10)
                    };
                    if (pr && pr.length) {
                        $(pr[0]).css({
                            width: data.width,
                            height: data.height
                        });
                    }
                    that._updateCache(data);
                    that._propagate("resize", event);
                }
            });
        }
    });
    $.ui.plugin.add("resizable", "containment", {
        start: function() {
            var element, p, co, ch, cw, width, height, that = $(this).resizable("instance"), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
            if (!ce) {
                return;
            }
            that.containerElement = $(ce);
            if (/document/.test(oc) || oc === document) {
                that.containerOffset = {
                    left: 0,
                    top: 0
                };
                that.containerPosition = {
                    left: 0,
                    top: 0
                };
                that.parentData = {
                    element: $(document),
                    left: 0,
                    top: 0,
                    width: $(document).width(),
                    height: $(document).height() || document.body.parentNode.scrollHeight
                };
            } else {
                element = $(ce);
                p = [];
                $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) {
                    p[i] = that._num(element.css("padding" + name));
                });
                that.containerOffset = element.offset();
                that.containerPosition = element.position();
                that.containerSize = {
                    height: element.innerHeight() - p[3],
                    width: element.innerWidth() - p[1]
                };
                co = that.containerOffset;
                ch = that.containerSize.height;
                cw = that.containerSize.width;
                width = that._hasScroll(ce, "left") ? ce.scrollWidth : cw;
                height = that._hasScroll(ce) ? ce.scrollHeight : ch;
                that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                };
            }
        },
        resize: function(event) {
            var woset, hoset, isParent, isOffsetRelative, that = $(this).resizable("instance"), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
                top: 0,
                left: 0
            }, ce = that.containerElement, continueResize = true;
            if (ce[0] !== document && /static/.test(ce.css("position"))) {
                cop = co;
            }
            if (cp.left < (that._helper ? co.left : 0)) {
                that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
                that.position.left = o.helper ? co.left : 0;
            }
            if (cp.top < (that._helper ? co.top : 0)) {
                that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
                that.position.top = that._helper ? co.top : 0;
            }
            isParent = that.containerElement.get(0) === that.element.parent().get(0);
            isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
            if (isParent && isOffsetRelative) {
                that.offset.left = that.parentData.left + that.position.left;
                that.offset.top = that.parentData.top + that.position.top;
            } else {
                that.offset.left = that.element.offset().left;
                that.offset.top = that.element.offset().top;
            }
            woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));
            hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));
            if (woset + that.size.width >= that.parentData.width) {
                that.size.width = that.parentData.width - woset;
                if (pRatio) {
                    that.size.height = that.size.width / that.aspectRatio;
                    continueResize = false;
                }
            }
            if (hoset + that.size.height >= that.parentData.height) {
                that.size.height = that.parentData.height - hoset;
                if (pRatio) {
                    that.size.width = that.size.height * that.aspectRatio;
                    continueResize = false;
                }
            }
            if (!continueResize) {
                that.position.left = that.prevPosition.left;
                that.position.top = that.prevPosition.top;
                that.size.width = that.prevSize.width;
                that.size.height = that.prevSize.height;
            }
        },
        stop: function() {
            var that = $(this).resizable("instance"), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
            if (that._helper && !o.animate && /relative/.test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
            if (that._helper && !o.animate && /static/.test(ce.css("position"))) {
                $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                });
            }
        }
    });
    $.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
            var that = $(this).resizable("instance"), o = that.options;
            $(o.alsoResize).each(function() {
                var el = $(this);
                el.data("ui-resizable-alsoresize", {
                    width: parseInt(el.width(), 10),
                    height: parseInt(el.height(), 10),
                    left: parseInt(el.css("left"), 10),
                    top: parseInt(el.css("top"), 10)
                });
            });
        },
        resize: function(event, ui) {
            var that = $(this).resizable("instance"), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
                height: that.size.height - os.height || 0,
                width: that.size.width - os.width || 0,
                top: that.position.top - op.top || 0,
                left: that.position.left - op.left || 0
            };
            $(o.alsoResize).each(function() {
                var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {}, css = el.parents(ui.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                $.each(css, function(i, prop) {
                    var sum = (start[prop] || 0) + (delta[prop] || 0);
                    if (sum && sum >= 0) {
                        style[prop] = sum || null;
                    }
                });
                el.css(style);
            });
        },
        stop: function() {
            $(this).removeData("resizable-alsoresize");
        }
    });
    $.ui.plugin.add("resizable", "ghost", {
        start: function() {
            var that = $(this).resizable("instance"), o = that.options, cs = that.size;
            that.ghost = that.originalElement.clone();
            that.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0
            }).addClass("ui-resizable-ghost").addClass(typeof o.ghost === "string" ? o.ghost : "");
            that.ghost.appendTo(that.helper);
        },
        resize: function() {
            var that = $(this).resizable("instance");
            if (that.ghost) {
                that.ghost.css({
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width
                });
            }
        },
        stop: function() {
            var that = $(this).resizable("instance");
            if (that.ghost && that.helper) {
                that.helper.get(0).removeChild(that.ghost.get(0));
            }
        }
    });
    $.ui.plugin.add("resizable", "grid", {
        resize: function() {
            var outerDimensions, that = $(this).resizable("instance"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
            o.grid = grid;
            if (isMinWidth) {
                newWidth += gridX;
            }
            if (isMinHeight) {
                newHeight += gridY;
            }
            if (isMaxWidth) {
                newWidth -= gridX;
            }
            if (isMaxHeight) {
                newHeight -= gridY;
            }
            if (/^(se|s|e)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
            } else if (/^(ne)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.top = op.top - oy;
            } else if (/^(sw)$/.test(a)) {
                that.size.width = newWidth;
                that.size.height = newHeight;
                that.position.left = op.left - ox;
            } else {
                if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
                    outerDimensions = that._getPaddingPlusBorderDimensions(this);
                }
                if (newHeight - gridY > 0) {
                    that.size.height = newHeight;
                    that.position.top = op.top - oy;
                } else {
                    newHeight = gridY - outerDimensions.height;
                    that.size.height = newHeight;
                    that.position.top = op.top + os.height - newHeight;
                }
                if (newWidth - gridX > 0) {
                    that.size.width = newWidth;
                    that.position.left = op.left - ox;
                } else {
                    newWidth = gridX - outerDimensions.width;
                    that.size.width = newWidth;
                    that.position.left = op.left + os.width - newWidth;
                }
            }
        }
    });
    var resizable = $.ui.resizable;
    var dialog = $.widget("ui.dialog", {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoOpen: true,
            buttons: [],
            closeOnEscape: true,
            closeText: "Close",
            dialogClass: "",
            draggable: true,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: false,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                using: function(pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    if (topOffset < 0) {
                        $(this).css("top", pos.top - topOffset);
                    }
                }
            },
            resizable: true,
            show: null,
            title: null,
            width: 300,
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },
        sizeRelatedOptions: {
            buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
        },
        resizableRelatedOptions: {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
        },
        _create: function() {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            };
            this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            };
            this.originalTitle = this.element.attr("title");
            this.options.title = this.options.title || this.originalTitle;
            this._createWrapper();
            this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog);
            this._createTitlebar();
            this._createButtonPane();
            if (this.options.draggable && $.fn.draggable) {
                this._makeDraggable();
            }
            if (this.options.resizable && $.fn.resizable) {
                this._makeResizable();
            }
            this._isOpen = false;
            this._trackFocus();
        },
        _init: function() {
            if (this.options.autoOpen) {
                this.open();
            }
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            if (element && (element.jquery || element.nodeType)) {
                return $(element);
            }
            return this.document.find(element || "body").eq(0);
        },
        _destroy: function() {
            var next, originalPosition = this.originalPosition;
            this._untrackInstance();
            this._destroyOverlay();
            this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach();
            this.uiDialog.stop(true, true).remove();
            if (this.originalTitle) {
                this.element.attr("title", this.originalTitle);
            }
            next = originalPosition.parent.children().eq(originalPosition.index);
            if (next.length && next[0] !== this.element[0]) {
                next.before(this.element);
            } else {
                originalPosition.parent.append(this.element);
            }
        },
        widget: function() {
            return this.uiDialog;
        },
        disable: $.noop,
        enable: $.noop,
        close: function(event) {
            var activeElement, that = this;
            if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                return;
            }
            this._isOpen = false;
            this._focusedElement = null;
            this._destroyOverlay();
            this._untrackInstance();
            if (!this.opener.filter(":focusable").focus().length) {
                try {
                    activeElement = this.document[0].activeElement;
                    if (activeElement && activeElement.nodeName.toLowerCase() !== "body") {
                        $(activeElement).blur();
                    }
                } catch (error) {}
            }
            this._hide(this.uiDialog, this.options.hide, function() {
                that._trigger("close", event);
            });
        },
        isOpen: function() {
            return this._isOpen;
        },
        moveToTop: function() {
            this._moveToTop();
        },
        _moveToTop: function(event, silent) {
            var moved = false, zIndices = this.uiDialog.siblings(".ui-front:visible").map(function() {
                return +$(this).css("z-index");
            }).get(), zIndexMax = Math.max.apply(null, zIndices);
            if (zIndexMax >= +this.uiDialog.css("z-index")) {
                this.uiDialog.css("z-index", zIndexMax + 1);
                moved = true;
            }
            if (moved && !silent) {
                this._trigger("focus", event);
            }
            return moved;
        },
        open: function() {
            var that = this;
            if (this._isOpen) {
                if (this._moveToTop()) {
                    this._focusTabbable();
                }
                return;
            }
            this._isOpen = true;
            this.opener = $(this.document[0].activeElement);
            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop(null, true);
            if (this.overlay) {
                this.overlay.css("z-index", this.uiDialog.css("z-index") - 1);
            }
            this._show(this.uiDialog, this.options.show, function() {
                that._focusTabbable();
                that._trigger("focus");
            });
            this._makeFocusTarget();
            this._trigger("open");
        },
        _focusTabbable: function() {
            var hasFocus = this._focusedElement;
            if (!hasFocus) {
                hasFocus = this.element.find("[autofocus]");
            }
            if (!hasFocus.length) {
                hasFocus = this.element.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogButtonPane.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.uiDialog;
            }
            hasFocus.eq(0).focus();
        },
        _keepFocus: function(event) {
            function checkFocus() {
                var activeElement = this.document[0].activeElement, isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
                if (!isActive) {
                    this._focusTabbable();
                }
            }
            event.preventDefault();
            checkFocus.call(this);
            this._delay(checkFocus);
        },
        _createWrapper: function() {
            this.uiDialog = $("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
                tabIndex: -1,
                role: "dialog"
            }).appendTo(this._appendTo());
            this._on(this.uiDialog, {
                keydown: function(event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
                        event.preventDefault();
                        this.close(event);
                        return;
                    }
                    if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
                        return;
                    }
                    var tabbables = this.uiDialog.find(":tabbable"), first = tabbables.filter(":first"), last = tabbables.filter(":last");
                    if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
                        this._delay(function() {
                            first.focus();
                        });
                        event.preventDefault();
                    } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
                        this._delay(function() {
                            last.focus();
                        });
                        event.preventDefault();
                    }
                },
                mousedown: function(event) {
                    if (this._moveToTop(event)) {
                        this._focusTabbable();
                    }
                }
            });
            if (!this.element.find("[aria-describedby]").length) {
                this.uiDialog.attr({
                    "aria-describedby": this.element.uniqueId().attr("id")
                });
            }
        },
        _createTitlebar: function() {
            var uiDialogTitle;
            this.uiDialogTitlebar = $("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog);
            this._on(this.uiDialogTitlebar, {
                mousedown: function(event) {
                    if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
                        this.uiDialog.focus();
                    }
                }
            });
            this.uiDialogTitlebarClose = $("<button type='button'></button>").button({
                label: this.options.closeText,
                icons: {
                    primary: "ui-icon-closethick"
                },
                text: false
            }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar);
            this._on(this.uiDialogTitlebarClose, {
                click: function(event) {
                    event.preventDefault();
                    this.close(event);
                }
            });
            uiDialogTitle = $("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar);
            this._title(uiDialogTitle);
            this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id")
            });
        },
        _title: function(title) {
            if (!this.options.title) {
                title.html("&#160;");
            }
            title.text(this.options.title);
        },
        _createButtonPane: function() {
            this.uiDialogButtonPane = $("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");
            this.uiButtonSet = $("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane);
            this._createButtons();
        },
        _createButtons: function() {
            var that = this, buttons = this.options.buttons;
            this.uiDialogButtonPane.remove();
            this.uiButtonSet.empty();
            if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {
                this.uiDialog.removeClass("ui-dialog-buttons");
                return;
            }
            $.each(buttons, function(name, props) {
                var click, buttonOptions;
                props = $.isFunction(props) ? {
                    click: props,
                    text: name
                } : props;
                props = $.extend({
                    type: "button"
                }, props);
                click = props.click;
                props.click = function() {
                    click.apply(that.element[0], arguments);
                };
                buttonOptions = {
                    icons: props.icons,
                    text: props.showText
                };
                delete props.icons;
                delete props.showText;
                $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet);
            });
            this.uiDialog.addClass("ui-dialog-buttons");
            this.uiDialogButtonPane.appendTo(this.uiDialog);
        },
        _makeDraggable: function() {
            var that = this, options = this.options;
            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }
            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function(event, ui) {
                    $(this).addClass("ui-dialog-dragging");
                    that._blockFrames();
                    that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function(event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    var left = ui.offset.left - that.document.scrollLeft(), top = ui.offset.top - that.document.scrollTop();
                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    $(this).removeClass("ui-dialog-dragging");
                    that._unblockFrames();
                    that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },
        _makeResizable: function() {
            var that = this, options = this.options, handles = options.resizable, position = this.uiDialog.css("position"), resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";
            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }
            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function(event, ui) {
                    $(this).addClass("ui-dialog-resizing");
                    that._blockFrames();
                    that._trigger("resizeStart", event, filteredUi(ui));
                },
                resize: function(event, ui) {
                    that._trigger("resize", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    var offset = that.uiDialog.offset(), left = offset.left - that.document.scrollLeft(), top = offset.top - that.document.scrollTop();
                    options.height = that.uiDialog.height();
                    options.width = that.uiDialog.width();
                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    $(this).removeClass("ui-dialog-resizing");
                    that._unblockFrames();
                    that._trigger("resizeStop", event, filteredUi(ui));
                }
            }).css("position", position);
        },
        _trackFocus: function() {
            this._on(this.widget(), {
                focusin: function(event) {
                    this._makeFocusTarget();
                    this._focusedElement = $(event.target);
                }
            });
        },
        _makeFocusTarget: function() {
            this._untrackInstance();
            this._trackingInstances().unshift(this);
        },
        _untrackInstance: function() {
            var instances = this._trackingInstances(), exists = $.inArray(this, instances);
            if (exists !== -1) {
                instances.splice(exists, 1);
            }
        },
        _trackingInstances: function() {
            var instances = this.document.data("ui-dialog-instances");
            if (!instances) {
                instances = [];
                this.document.data("ui-dialog-instances", instances);
            }
            return instances;
        },
        _minHeight: function() {
            var options = this.options;
            return options.height === "auto" ? options.minHeight : Math.min(options.minHeight, options.height);
        },
        _position: function() {
            var isVisible = this.uiDialog.is(":visible");
            if (!isVisible) {
                this.uiDialog.show();
            }
            this.uiDialog.position(this.options.position);
            if (!isVisible) {
                this.uiDialog.hide();
            }
        },
        _setOptions: function(options) {
            var that = this, resize = false, resizableOptions = {};
            $.each(options, function(key, value) {
                that._setOption(key, value);
                if (key in that.sizeRelatedOptions) {
                    resize = true;
                }
                if (key in that.resizableRelatedOptions) {
                    resizableOptions[key] = value;
                }
            });
            if (resize) {
                this._size();
                this._position();
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", resizableOptions);
            }
        },
        _setOption: function(key, value) {
            var isDraggable, isResizable, uiDialog = this.uiDialog;
            if (key === "dialogClass") {
                uiDialog.removeClass(this.options.dialogClass).addClass(value);
            }
            if (key === "disabled") {
                return;
            }
            this._super(key, value);
            if (key === "appendTo") {
                this.uiDialog.appendTo(this._appendTo());
            }
            if (key === "buttons") {
                this._createButtons();
            }
            if (key === "closeText") {
                this.uiDialogTitlebarClose.button({
                    label: "" + value
                });
            }
            if (key === "draggable") {
                isDraggable = uiDialog.is(":data(ui-draggable)");
                if (isDraggable && !value) {
                    uiDialog.draggable("destroy");
                }
                if (!isDraggable && value) {
                    this._makeDraggable();
                }
            }
            if (key === "position") {
                this._position();
            }
            if (key === "resizable") {
                isResizable = uiDialog.is(":data(ui-resizable)");
                if (isResizable && !value) {
                    uiDialog.resizable("destroy");
                }
                if (isResizable && typeof value === "string") {
                    uiDialog.resizable("option", "handles", value);
                }
                if (!isResizable && value !== false) {
                    this._makeResizable();
                }
            }
            if (key === "title") {
                this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
            }
        },
        _size: function() {
            var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            });
            if (options.minWidth > options.width) {
                options.width = options.minWidth;
            }
            nonContentHeight = this.uiDialog.css({
                height: "auto",
                width: options.width
            }).outerHeight();
            minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
            maxContentHeight = typeof options.maxHeight === "number" ? Math.max(0, options.maxHeight - nonContentHeight) : "none";
            if (options.height === "auto") {
                this.element.css({
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto"
                });
            } else {
                this.element.height(Math.max(0, options.height - nonContentHeight));
            }
            if (this.uiDialog.is(":data(ui-resizable)")) {
                this.uiDialog.resizable("option", "minHeight", this._minHeight());
            }
        },
        _blockFrames: function() {
            this.iframeBlocks = this.document.find("iframe").map(function() {
                var iframe = $(this);
                return $("<div>").css({
                    position: "absolute",
                    width: iframe.outerWidth(),
                    height: iframe.outerHeight()
                }).appendTo(iframe.parent()).offset(iframe.offset())[0];
            });
        },
        _unblockFrames: function() {
            if (this.iframeBlocks) {
                this.iframeBlocks.remove();
                delete this.iframeBlocks;
            }
        },
        _allowInteraction: function(event) {
            if ($(event.target).closest(".ui-dialog").length) {
                return true;
            }
            return !!$(event.target).closest(".ui-datepicker").length;
        },
        _createOverlay: function() {
            if (!this.options.modal) {
                return;
            }
            var isOpening = true;
            this._delay(function() {
                isOpening = false;
            });
            if (!this.document.data("ui-dialog-overlays")) {
                this._on(this.document, {
                    focusin: function(event) {
                        if (isOpening) {
                            return;
                        }
                        if (!this._allowInteraction(event)) {
                            event.preventDefault();
                            this._trackingInstances()[0]._focusTabbable();
                        }
                    }
                });
            }
            this.overlay = $("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo());
            this._on(this.overlay, {
                mousedown: "_keepFocus"
            });
            this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1);
        },
        _destroyOverlay: function() {
            if (!this.options.modal) {
                return;
            }
            if (this.overlay) {
                var overlays = this.document.data("ui-dialog-overlays") - 1;
                if (!overlays) {
                    this.document.unbind("focusin").removeData("ui-dialog-overlays");
                } else {
                    this.document.data("ui-dialog-overlays", overlays);
                }
                this.overlay.remove();
                this.overlay = null;
            }
        }
    });
    $.widget("ui.droppable", {
        version: "1.11.4",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: false,
            addClasses: true,
            greedy: false,
            hoverClass: false,
            scope: "default",
            tolerance: "intersect",
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
            var proportions, o = this.options, accept = o.accept;
            this.isover = false;
            this.isout = true;
            this.accept = $.isFunction(accept) ? accept : function(d) {
                return d.is(accept);
            };
            this.proportions = function() {
                if (arguments.length) {
                    proportions = arguments[0];
                } else {
                    return proportions ? proportions : proportions = {
                        width: this.element[0].offsetWidth,
                        height: this.element[0].offsetHeight
                    };
                }
            };
            this._addToManager(o.scope);
            o.addClasses && this.element.addClass("ui-droppable");
        },
        _addToManager: function(scope) {
            $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
            $.ui.ddmanager.droppables[scope].push(this);
        },
        _splice: function(drop) {
            var i = 0;
            for (;i < drop.length; i++) {
                if (drop[i] === this) {
                    drop.splice(i, 1);
                }
            }
        },
        _destroy: function() {
            var drop = $.ui.ddmanager.droppables[this.options.scope];
            this._splice(drop);
            this.element.removeClass("ui-droppable ui-droppable-disabled");
        },
        _setOption: function(key, value) {
            if (key === "accept") {
                this.accept = $.isFunction(value) ? value : function(d) {
                    return d.is(value);
                };
            } else if (key === "scope") {
                var drop = $.ui.ddmanager.droppables[this.options.scope];
                this._splice(drop);
                this._addToManager(value);
            }
            this._super(key, value);
        },
        _activate: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (this.options.activeClass) {
                this.element.addClass(this.options.activeClass);
            }
            if (draggable) {
                this._trigger("activate", event, this.ui(draggable));
            }
        },
        _deactivate: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (this.options.activeClass) {
                this.element.removeClass(this.options.activeClass);
            }
            if (draggable) {
                this._trigger("deactivate", event, this.ui(draggable));
            }
        },
        _over: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                if (this.options.hoverClass) {
                    this.element.addClass(this.options.hoverClass);
                }
                this._trigger("over", event, this.ui(draggable));
            }
        },
        _out: function(event) {
            var draggable = $.ui.ddmanager.current;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
                this._trigger("out", event, this.ui(draggable));
            }
        },
        _drop: function(event, custom) {
            var draggable = custom || $.ui.ddmanager.current, childrenIntersection = false;
            if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
                return false;
            }
            this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                var inst = $(this).droppable("instance");
                if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, {
                    offset: inst.element.offset()
                }), inst.options.tolerance, event)) {
                    childrenIntersection = true;
                    return false;
                }
            });
            if (childrenIntersection) {
                return false;
            }
            if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                if (this.options.activeClass) {
                    this.element.removeClass(this.options.activeClass);
                }
                if (this.options.hoverClass) {
                    this.element.removeClass(this.options.hoverClass);
                }
                this._trigger("drop", event, this.ui(draggable));
                return this.element;
            }
            return false;
        },
        ui: function(c) {
            return {
                draggable: c.currentItem || c.element,
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        }
    });
    $.ui.intersect = function() {
        function isOverAxis(x, reference, size) {
            return x >= reference && x < reference + size;
        }
        return function(draggable, droppable, toleranceMode, event) {
            if (!droppable.offset) {
                return false;
            }
            var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left, y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top, x2 = x1 + draggable.helperProportions.width, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, t = droppable.offset.top, r = l + droppable.proportions().width, b = t + droppable.proportions().height;
            switch (toleranceMode) {
              case "fit":
                return l <= x1 && x2 <= r && t <= y1 && y2 <= b;

              case "intersect":
                return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;

              case "pointer":
                return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);

              case "touch":
                return (y1 >= t && y1 <= b || y2 >= t && y2 <= b || y1 < t && y2 > b) && (x1 >= l && x1 <= r || x2 >= l && x2 <= r || x1 < l && x2 > r);

              default:
                return false;
            }
        };
    }();
    $.ui.ddmanager = {
        current: null,
        droppables: {
            default: []
        },
        prepareOffsets: function(t, event) {
            var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null, list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            droppablesLoop: for (i = 0; i < m.length; i++) {
                if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {
                    continue;
                }
                for (j = 0; j < list.length; j++) {
                    if (list[j] === m[i].element[0]) {
                        m[i].proportions().height = 0;
                        continue droppablesLoop;
                    }
                }
                m[i].visible = m[i].element.css("display") !== "none";
                if (!m[i].visible) {
                    continue;
                }
                if (type === "mousedown") {
                    m[i]._activate.call(m[i], event);
                }
                m[i].offset = m[i].element.offset();
                m[i].proportions({
                    width: m[i].element[0].offsetWidth,
                    height: m[i].element[0].offsetHeight
                });
            }
        },
        drop: function(draggable, event) {
            var dropped = false;
            $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
                if (!this.options) {
                    return;
                }
                if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event)) {
                    dropped = this._drop.call(this, event) || dropped;
                }
                if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
                    this.isout = true;
                    this.isover = false;
                    this._deactivate.call(this, event);
                }
            });
            return dropped;
        },
        dragStart: function(draggable, event) {
            draggable.element.parentsUntil("body").bind("scroll.droppable", function() {
                if (!draggable.options.refreshPositions) {
                    $.ui.ddmanager.prepareOffsets(draggable, event);
                }
            });
        },
        drag: function(draggable, event) {
            if (draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                if (this.options.disabled || this.greedyChild || !this.visible) {
                    return;
                }
                var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance, event), c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                if (!c) {
                    return;
                }
                if (this.options.greedy) {
                    scope = this.options.scope;
                    parent = this.element.parents(":data(ui-droppable)").filter(function() {
                        return $(this).droppable("instance").options.scope === scope;
                    });
                    if (parent.length) {
                        parentInstance = $(parent[0]).droppable("instance");
                        parentInstance.greedyChild = c === "isover";
                    }
                }
                if (parentInstance && c === "isover") {
                    parentInstance.isover = false;
                    parentInstance.isout = true;
                    parentInstance._out.call(parentInstance, event);
                }
                this[c] = true;
                this[c === "isout" ? "isover" : "isout"] = false;
                this[c === "isover" ? "_over" : "_out"].call(this, event);
                if (parentInstance && c === "isout") {
                    parentInstance.isout = false;
                    parentInstance.isover = true;
                    parentInstance._over.call(parentInstance, event);
                }
            });
        },
        dragStop: function(draggable, event) {
            draggable.element.parentsUntil("body").unbind("scroll.droppable");
            if (!draggable.options.refreshPositions) {
                $.ui.ddmanager.prepareOffsets(draggable, event);
            }
        }
    };
    var droppable = $.ui.droppable;
    var dataSpace = "ui-effects-", jQuery = $;
    $.effects = {
        effect: {}
    };
    (function(jQuery, undefined) {
        var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor", rplusequals = /^([\-+])=\s*(\d+\.?\d*)/, stringParsers = [ {
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
                return [ execResult[1], execResult[2], execResult[3], execResult[4] ];
            }
        }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
                return [ execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4] ];
            }
        }, {
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse: function(execResult) {
                return [ parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16) ];
            }
        }, {
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse: function(execResult) {
                return [ parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16) ];
            }
        }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function(execResult) {
                return [ execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4] ];
            }
        } ], color = jQuery.Color = function(color, green, blue, alpha) {
            return new jQuery.Color.fn.parse(color, green, blue, alpha);
        }, spaces = {
            rgba: {
                props: {
                    red: {
                        idx: 0,
                        type: "byte"
                    },
                    green: {
                        idx: 1,
                        type: "byte"
                    },
                    blue: {
                        idx: 2,
                        type: "byte"
                    }
                }
            },
            hsla: {
                props: {
                    hue: {
                        idx: 0,
                        type: "degrees"
                    },
                    saturation: {
                        idx: 1,
                        type: "percent"
                    },
                    lightness: {
                        idx: 2,
                        type: "percent"
                    }
                }
            }
        }, propTypes = {
            byte: {
                floor: true,
                max: 255
            },
            percent: {
                max: 1
            },
            degrees: {
                mod: 360,
                floor: true
            }
        }, support = color.support = {}, supportElem = jQuery("<p>")[0], colors, each = jQuery.each;
        supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
        support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;
        each(spaces, function(spaceName, space) {
            space.cache = "_" + spaceName;
            space.props.alpha = {
                idx: 3,
                type: "percent",
                def: 1
            };
        });
        function clamp(value, prop, allowEmpty) {
            var type = propTypes[prop.type] || {};
            if (value == null) {
                return allowEmpty || !prop.def ? null : prop.def;
            }
            value = type.floor ? ~~value : parseFloat(value);
            if (isNaN(value)) {
                return prop.def;
            }
            if (type.mod) {
                return (value + type.mod) % type.mod;
            }
            return 0 > value ? 0 : type.max < value ? type.max : value;
        }
        function stringParse(string) {
            var inst = color(), rgba = inst._rgba = [];
            string = string.toLowerCase();
            each(stringParsers, function(i, parser) {
                var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || "rgba";
                if (values) {
                    parsed = inst[spaceName](values);
                    inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
                    rgba = inst._rgba = parsed._rgba;
                    return false;
                }
            });
            if (rgba.length) {
                if (rgba.join() === "0,0,0,0") {
                    jQuery.extend(rgba, colors.transparent);
                }
                return inst;
            }
            return colors[string];
        }
        color.fn = jQuery.extend(color.prototype, {
            parse: function(red, green, blue, alpha) {
                if (red === undefined) {
                    this._rgba = [ null, null, null, null ];
                    return this;
                }
                if (red.jquery || red.nodeType) {
                    red = jQuery(red).css(green);
                    green = undefined;
                }
                var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
                if (green !== undefined) {
                    red = [ red, green, blue, alpha ];
                    type = "array";
                }
                if (type === "string") {
                    return this.parse(stringParse(red) || colors._default);
                }
                if (type === "array") {
                    each(spaces.rgba.props, function(key, prop) {
                        rgba[prop.idx] = clamp(red[prop.idx], prop);
                    });
                    return this;
                }
                if (type === "object") {
                    if (red instanceof color) {
                        each(spaces, function(spaceName, space) {
                            if (red[space.cache]) {
                                inst[space.cache] = red[space.cache].slice();
                            }
                        });
                    } else {
                        each(spaces, function(spaceName, space) {
                            var cache = space.cache;
                            each(space.props, function(key, prop) {
                                if (!inst[cache] && space.to) {
                                    if (key === "alpha" || red[key] == null) {
                                        return;
                                    }
                                    inst[cache] = space.to(inst._rgba);
                                }
                                inst[cache][prop.idx] = clamp(red[key], prop, true);
                            });
                            if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                                inst[cache][3] = 1;
                                if (space.from) {
                                    inst._rgba = space.from(inst[cache]);
                                }
                            }
                        });
                    }
                    return this;
                }
            },
            is: function(compare) {
                var is = color(compare), same = true, inst = this;
                each(spaces, function(_, space) {
                    var localCache, isCache = is[space.cache];
                    if (isCache) {
                        localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
                        each(space.props, function(_, prop) {
                            if (isCache[prop.idx] != null) {
                                same = isCache[prop.idx] === localCache[prop.idx];
                                return same;
                            }
                        });
                    }
                    return same;
                });
                return same;
            },
            _space: function() {
                var used = [], inst = this;
                each(spaces, function(spaceName, space) {
                    if (inst[space.cache]) {
                        used.push(spaceName);
                    }
                });
                return used.pop();
            },
            transition: function(other, distance) {
                var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = this.alpha() === 0 ? color("transparent") : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
                end = end[space.cache];
                each(space.props, function(key, prop) {
                    var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
                    if (endValue === null) {
                        return;
                    }
                    if (startValue === null) {
                        result[index] = endValue;
                    } else {
                        if (type.mod) {
                            if (endValue - startValue > type.mod / 2) {
                                startValue += type.mod;
                            } else if (startValue - endValue > type.mod / 2) {
                                startValue -= type.mod;
                            }
                        }
                        result[index] = clamp((endValue - startValue) * distance + startValue, prop);
                    }
                });
                return this[spaceName](result);
            },
            blend: function(opaque) {
                if (this._rgba[3] === 1) {
                    return this;
                }
                var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
                return color(jQuery.map(rgb, function(v, i) {
                    return (1 - a) * blend[i] + a * v;
                }));
            },
            toRgbaString: function() {
                var prefix = "rgba(", rgba = jQuery.map(this._rgba, function(v, i) {
                    return v == null ? i > 2 ? 1 : 0 : v;
                });
                if (rgba[3] === 1) {
                    rgba.pop();
                    prefix = "rgb(";
                }
                return prefix + rgba.join() + ")";
            },
            toHslaString: function() {
                var prefix = "hsla(", hsla = jQuery.map(this.hsla(), function(v, i) {
                    if (v == null) {
                        v = i > 2 ? 1 : 0;
                    }
                    if (i && i < 3) {
                        v = Math.round(v * 100) + "%";
                    }
                    return v;
                });
                if (hsla[3] === 1) {
                    hsla.pop();
                    prefix = "hsl(";
                }
                return prefix + hsla.join() + ")";
            },
            toHexString: function(includeAlpha) {
                var rgba = this._rgba.slice(), alpha = rgba.pop();
                if (includeAlpha) {
                    rgba.push(~~(alpha * 255));
                }
                return "#" + jQuery.map(rgba, function(v) {
                    v = (v || 0).toString(16);
                    return v.length === 1 ? "0" + v : v;
                }).join("");
            },
            toString: function() {
                return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
            }
        });
        color.fn.parse.prototype = color.fn;
        function hue2rgb(p, q, h) {
            h = (h + 1) % 1;
            if (h * 6 < 1) {
                return p + (q - p) * h * 6;
            }
            if (h * 2 < 1) {
                return q;
            }
            if (h * 3 < 2) {
                return p + (q - p) * (2 / 3 - h) * 6;
            }
            return p;
        }
        spaces.hsla.to = function(rgba) {
            if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
                return [ null, null, null, rgba[3] ];
            }
            var r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = add * .5, h, s;
            if (min === max) {
                h = 0;
            } else if (r === max) {
                h = 60 * (g - b) / diff + 360;
            } else if (g === max) {
                h = 60 * (b - r) / diff + 120;
            } else {
                h = 60 * (r - g) / diff + 240;
            }
            if (diff === 0) {
                s = 0;
            } else if (l <= .5) {
                s = diff / add;
            } else {
                s = diff / (2 - add);
            }
            return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
        };
        spaces.hsla.from = function(hsla) {
            if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
                return [ null, null, null, hsla[3] ];
            }
            var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = l <= .5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
            return [ Math.round(hue2rgb(p, q, h + 1 / 3) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - 1 / 3) * 255), a ];
        };
        each(spaces, function(spaceName, space) {
            var props = space.props, cache = space.cache, to = space.to, from = space.from;
            color.fn[spaceName] = function(value) {
                if (to && !this[cache]) {
                    this[cache] = to(this._rgba);
                }
                if (value === undefined) {
                    return this[cache].slice();
                }
                var ret, type = jQuery.type(value), arr = type === "array" || type === "object" ? value : arguments, local = this[cache].slice();
                each(props, function(key, prop) {
                    var val = arr[type === "object" ? key : prop.idx];
                    if (val == null) {
                        val = local[prop.idx];
                    }
                    local[prop.idx] = clamp(val, prop);
                });
                if (from) {
                    ret = color(from(local));
                    ret[cache] = local;
                    return ret;
                } else {
                    return color(local);
                }
            };
            each(props, function(key, prop) {
                if (color.fn[key]) {
                    return;
                }
                color.fn[key] = function(value) {
                    var vtype = jQuery.type(value), fn = key === "alpha" ? this._hsla ? "hsla" : "rgba" : spaceName, local = this[fn](), cur = local[prop.idx], match;
                    if (vtype === "undefined") {
                        return cur;
                    }
                    if (vtype === "function") {
                        value = value.call(this, cur);
                        vtype = jQuery.type(value);
                    }
                    if (value == null && prop.empty) {
                        return this;
                    }
                    if (vtype === "string") {
                        match = rplusequals.exec(value);
                        if (match) {
                            value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
                        }
                    }
                    local[prop.idx] = value;
                    return this[fn](local);
                };
            });
        });
        color.hook = function(hook) {
            var hooks = hook.split(" ");
            each(hooks, function(i, hook) {
                jQuery.cssHooks[hook] = {
                    set: function(elem, value) {
                        var parsed, curElem, backgroundColor = "";
                        if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                            value = color(parsed || value);
                            if (!support.rgba && value._rgba[3] !== 1) {
                                curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                                while ((backgroundColor === "" || backgroundColor === "transparent") && curElem && curElem.style) {
                                    try {
                                        backgroundColor = jQuery.css(curElem, "backgroundColor");
                                        curElem = curElem.parentNode;
                                    } catch (e) {}
                                }
                                value = value.blend(backgroundColor && backgroundColor !== "transparent" ? backgroundColor : "_default");
                            }
                            value = value.toRgbaString();
                        }
                        try {
                            elem.style[hook] = value;
                        } catch (e) {}
                    }
                };
                jQuery.fx.step[hook] = function(fx) {
                    if (!fx.colorInit) {
                        fx.start = color(fx.elem, hook);
                        fx.end = color(fx.end);
                        fx.colorInit = true;
                    }
                    jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
                };
            });
        };
        color.hook(stepHooks);
        jQuery.cssHooks.borderColor = {
            expand: function(value) {
                var expanded = {};
                each([ "Top", "Right", "Bottom", "Left" ], function(i, part) {
                    expanded["border" + part + "Color"] = value;
                });
                return expanded;
            }
        };
        colors = jQuery.Color.names = {
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00",
            transparent: [ null, null, null, 0 ],
            _default: "#ffffff"
        };
    })(jQuery);
    (function() {
        var classAnimationActions = [ "add", "remove", "toggle" ], shorthandStyles = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
        };
        $.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function(_, prop) {
            $.fx.step[prop] = function(fx) {
                if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
                    jQuery.style(fx.elem, prop, fx.end);
                    fx.setAttr = true;
                }
            };
        });
        function getElementStyles(elem) {
            var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
            if (style && style.length && style[0] && style[style[0]]) {
                len = style.length;
                while (len--) {
                    key = style[len];
                    if (typeof style[key] === "string") {
                        styles[$.camelCase(key)] = style[key];
                    }
                }
            } else {
                for (key in style) {
                    if (typeof style[key] === "string") {
                        styles[key] = style[key];
                    }
                }
            }
            return styles;
        }
        function styleDifference(oldStyle, newStyle) {
            var diff = {}, name, value;
            for (name in newStyle) {
                value = newStyle[name];
                if (oldStyle[name] !== value) {
                    if (!shorthandStyles[name]) {
                        if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                            diff[name] = value;
                        }
                    }
                }
            }
            return diff;
        }
        if (!$.fn.addBack) {
            $.fn.addBack = function(selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            };
        }
        $.effects.animateClass = function(value, duration, easing, callback) {
            var o = $.speed(duration, easing, callback);
            return this.queue(function() {
                var animated = $(this), baseClass = animated.attr("class") || "", applyClassChange, allAnimations = o.children ? animated.find("*").addBack() : animated;
                allAnimations = allAnimations.map(function() {
                    var el = $(this);
                    return {
                        el: el,
                        start: getElementStyles(this)
                    };
                });
                applyClassChange = function() {
                    $.each(classAnimationActions, function(i, action) {
                        if (value[action]) {
                            animated[action + "Class"](value[action]);
                        }
                    });
                };
                applyClassChange();
                allAnimations = allAnimations.map(function() {
                    this.end = getElementStyles(this.el[0]);
                    this.diff = styleDifference(this.start, this.end);
                    return this;
                });
                animated.attr("class", baseClass);
                allAnimations = allAnimations.map(function() {
                    var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
                        queue: false,
                        complete: function() {
                            dfd.resolve(styleInfo);
                        }
                    });
                    this.el.animate(this.diff, opts);
                    return dfd.promise();
                });
                $.when.apply($, allAnimations.get()).done(function() {
                    applyClassChange();
                    $.each(arguments, function() {
                        var el = this.el;
                        $.each(this.diff, function(key) {
                            el.css(key, "");
                        });
                    });
                    o.complete.call(animated[0]);
                });
            });
        };
        $.fn.extend({
            addClass: function(orig) {
                return function(classNames, speed, easing, callback) {
                    return speed ? $.effects.animateClass.call(this, {
                        add: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments);
                };
            }($.fn.addClass),
            removeClass: function(orig) {
                return function(classNames, speed, easing, callback) {
                    return arguments.length > 1 ? $.effects.animateClass.call(this, {
                        remove: classNames
                    }, speed, easing, callback) : orig.apply(this, arguments);
                };
            }($.fn.removeClass),
            toggleClass: function(orig) {
                return function(classNames, force, speed, easing, callback) {
                    if (typeof force === "boolean" || force === undefined) {
                        if (!speed) {
                            return orig.apply(this, arguments);
                        } else {
                            return $.effects.animateClass.call(this, force ? {
                                add: classNames
                            } : {
                                remove: classNames
                            }, speed, easing, callback);
                        }
                    } else {
                        return $.effects.animateClass.call(this, {
                            toggle: classNames
                        }, force, speed, easing);
                    }
                };
            }($.fn.toggleClass),
            switchClass: function(remove, add, speed, easing, callback) {
                return $.effects.animateClass.call(this, {
                    add: add,
                    remove: remove
                }, speed, easing, callback);
            }
        });
    })();
    (function() {
        $.extend($.effects, {
            version: "1.11.4",
            save: function(element, set) {
                for (var i = 0; i < set.length; i++) {
                    if (set[i] !== null) {
                        element.data(dataSpace + set[i], element[0].style[set[i]]);
                    }
                }
            },
            restore: function(element, set) {
                var val, i;
                for (i = 0; i < set.length; i++) {
                    if (set[i] !== null) {
                        val = element.data(dataSpace + set[i]);
                        if (val === undefined) {
                            val = "";
                        }
                        element.css(set[i], val);
                    }
                }
            },
            setMode: function(el, mode) {
                if (mode === "toggle") {
                    mode = el.is(":hidden") ? "show" : "hide";
                }
                return mode;
            },
            getBaseline: function(origin, original) {
                var y, x;
                switch (origin[0]) {
                  case "top":
                    y = 0;
                    break;

                  case "middle":
                    y = .5;
                    break;

                  case "bottom":
                    y = 1;
                    break;

                  default:
                    y = origin[0] / original.height;
                }
                switch (origin[1]) {
                  case "left":
                    x = 0;
                    break;

                  case "center":
                    x = .5;
                    break;

                  case "right":
                    x = 1;
                    break;

                  default:
                    x = origin[1] / original.width;
                }
                return {
                    x: x,
                    y: y
                };
            },
            createWrapper: function(element) {
                if (element.parent().is(".ui-effects-wrapper")) {
                    return element.parent();
                }
                var props = {
                    width: element.outerWidth(true),
                    height: element.outerHeight(true),
                    float: element.css("float")
                }, wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                    fontSize: "100%",
                    background: "transparent",
                    border: "none",
                    margin: 0,
                    padding: 0
                }), size = {
                    width: element.width(),
                    height: element.height()
                }, active = document.activeElement;
                try {
                    active.id;
                } catch (e) {
                    active = document.body;
                }
                element.wrap(wrapper);
                if (element[0] === active || $.contains(element[0], active)) {
                    $(active).focus();
                }
                wrapper = element.parent();
                if (element.css("position") === "static") {
                    wrapper.css({
                        position: "relative"
                    });
                    element.css({
                        position: "relative"
                    });
                } else {
                    $.extend(props, {
                        position: element.css("position"),
                        zIndex: element.css("z-index")
                    });
                    $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                        props[pos] = element.css(pos);
                        if (isNaN(parseInt(props[pos], 10))) {
                            props[pos] = "auto";
                        }
                    });
                    element.css({
                        position: "relative",
                        top: 0,
                        left: 0,
                        right: "auto",
                        bottom: "auto"
                    });
                }
                element.css(size);
                return wrapper.css(props).show();
            },
            removeWrapper: function(element) {
                var active = document.activeElement;
                if (element.parent().is(".ui-effects-wrapper")) {
                    element.parent().replaceWith(element);
                    if (element[0] === active || $.contains(element[0], active)) {
                        $(active).focus();
                    }
                }
                return element;
            },
            setTransition: function(element, list, factor, value) {
                value = value || {};
                $.each(list, function(i, x) {
                    var unit = element.cssUnit(x);
                    if (unit[0] > 0) {
                        value[x] = unit[0] * factor + unit[1];
                    }
                });
                return value;
            }
        });
        function _normalizeArguments(effect, options, speed, callback) {
            if ($.isPlainObject(effect)) {
                options = effect;
                effect = effect.effect;
            }
            effect = {
                effect: effect
            };
            if (options == null) {
                options = {};
            }
            if ($.isFunction(options)) {
                callback = options;
                speed = null;
                options = {};
            }
            if (typeof options === "number" || $.fx.speeds[options]) {
                callback = speed;
                speed = options;
                options = {};
            }
            if ($.isFunction(speed)) {
                callback = speed;
                speed = null;
            }
            if (options) {
                $.extend(effect, options);
            }
            speed = speed || options.duration;
            effect.duration = $.fx.off ? 0 : typeof speed === "number" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
            effect.complete = callback || options.complete;
            return effect;
        }
        function standardAnimationOption(option) {
            if (!option || typeof option === "number" || $.fx.speeds[option]) {
                return true;
            }
            if (typeof option === "string" && !$.effects.effect[option]) {
                return true;
            }
            if ($.isFunction(option)) {
                return true;
            }
            if (typeof option === "object" && !option.effect) {
                return true;
            }
            return false;
        }
        $.fn.extend({
            effect: function() {
                var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = $.effects.effect[args.effect];
                if ($.fx.off || !effectMethod) {
                    if (mode) {
                        return this[mode](args.duration, args.complete);
                    } else {
                        return this.each(function() {
                            if (args.complete) {
                                args.complete.call(this);
                            }
                        });
                    }
                }
                function run(next) {
                    var elem = $(this), complete = args.complete, mode = args.mode;
                    function done() {
                        if ($.isFunction(complete)) {
                            complete.call(elem[0]);
                        }
                        if ($.isFunction(next)) {
                            next();
                        }
                    }
                    if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
                        elem[mode]();
                        done();
                    } else {
                        effectMethod.call(elem[0], args, done);
                    }
                }
                return queue === false ? this.each(run) : this.queue(queue || "fx", run);
            },
            show: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "show";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.show),
            hide: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option)) {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "hide";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.hide),
            toggle: function(orig) {
                return function(option) {
                    if (standardAnimationOption(option) || typeof option === "boolean") {
                        return orig.apply(this, arguments);
                    } else {
                        var args = _normalizeArguments.apply(this, arguments);
                        args.mode = "toggle";
                        return this.effect.call(this, args);
                    }
                };
            }($.fn.toggle),
            cssUnit: function(key) {
                var style = this.css(key), val = [];
                $.each([ "em", "px", "%", "pt" ], function(i, unit) {
                    if (style.indexOf(unit) > 0) {
                        val = [ parseFloat(style), unit ];
                    }
                });
                return val;
            }
        });
    })();
    (function() {
        var baseEasings = {};
        $.each([ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function(i, name) {
            baseEasings[name] = function(p) {
                return Math.pow(p, i + 2);
            };
        });
        $.extend(baseEasings, {
            Sine: function(p) {
                return 1 - Math.cos(p * Math.PI / 2);
            },
            Circ: function(p) {
                return 1 - Math.sqrt(1 - p * p);
            },
            Elastic: function(p) {
                return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
            },
            Back: function(p) {
                return p * p * (3 * p - 2);
            },
            Bounce: function(p) {
                var pow2, bounce = 4;
                while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
                return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
            }
        });
        $.each(baseEasings, function(name, easeIn) {
            $.easing["easeIn" + name] = easeIn;
            $.easing["easeOut" + name] = function(p) {
                return 1 - easeIn(1 - p);
            };
            $.easing["easeInOut" + name] = function(p) {
                return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
            };
        });
    })();
    var effect = $.effects;
    var effectBlind = $.effects.effect.blind = function(o, done) {
        var el = $(this), rvertical = /up|down|vertical/, rpositivemotion = /up|left|vertical|horizontal/, props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), direction = o.direction || "up", vertical = rvertical.test(direction), ref = vertical ? "height" : "width", ref2 = vertical ? "top" : "left", motion = rpositivemotion.test(direction), animation = {}, show = mode === "show", wrapper, distance, margin;
        if (el.parent().is(".ui-effects-wrapper")) {
            $.effects.save(el.parent(), props);
        } else {
            $.effects.save(el, props);
        }
        el.show();
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        distance = wrapper[ref]();
        margin = parseFloat(wrapper.css(ref2)) || 0;
        animation[ref] = show ? distance : 0;
        if (!motion) {
            el.css(vertical ? "bottom" : "right", 0).css(vertical ? "top" : "left", "auto").css({
                position: "absolute"
            });
            animation[ref2] = show ? margin : distance + margin;
        }
        if (show) {
            wrapper.css(ref, 0);
            if (!motion) {
                wrapper.css(ref2, margin + distance);
            }
        }
        wrapper.animate(animation, {
            duration: o.duration,
            easing: o.easing,
            queue: false,
            complete: function() {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
    var effectBounce = $.effects.effect.bounce = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "effect"), hide = mode === "hide", show = mode === "show", direction = o.direction || "up", distance = o.distance, times = o.times || 5, anims = times * 2 + (show || hide ? 1 : 0), speed = o.duration / anims, easing = o.easing, ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left", i, upAnim, downAnim, queue = el.queue(), queuelen = queue.length;
        if (show || hide) {
            props.push("opacity");
        }
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        if (!distance) {
            distance = el[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
        }
        if (show) {
            downAnim = {
                opacity: 1
            };
            downAnim[ref] = 0;
            el.css("opacity", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
        }
        if (hide) {
            distance = distance / Math.pow(2, times - 1);
        }
        downAnim = {};
        downAnim[ref] = 0;
        for (i = 0; i < times; i++) {
            upAnim = {};
            upAnim[ref] = (motion ? "-=" : "+=") + distance;
            el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
            distance = hide ? distance * 2 : distance / 2;
        }
        if (hide) {
            upAnim = {
                opacity: 0
            };
            upAnim[ref] = (motion ? "-=" : "+=") + distance;
            el.animate(upAnim, speed, easing);
        }
        el.queue(function() {
            if (hide) {
                el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
        });
        if (queuelen > 1) {
            queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();
    };
    var effectClip = $.effects.effect.clip = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", direction = o.direction || "vertical", vert = direction === "vertical", size = vert ? "height" : "width", position = vert ? "top" : "left", animation = {}, wrapper, animate, distance;
        $.effects.save(el, props);
        el.show();
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        animate = el[0].tagName === "IMG" ? wrapper : el;
        distance = animate[size]();
        if (show) {
            animate.css(size, 0);
            animate.css(position, distance / 2);
        }
        animation[size] = show ? distance : 0;
        animation[position] = show ? 0 : distance / 2;
        animate.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (!show) {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
    var effectDrop = $.effects.effect.drop = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", direction = o.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", motion = direction === "up" || direction === "left" ? "pos" : "neg", animation = {
            opacity: show ? 1 : 0
        }, distance;
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;
        if (show) {
            el.css("opacity", 0).css(ref, motion === "pos" ? -distance : distance);
        }
        animation[ref] = (show ? motion === "pos" ? "+=" : "-=" : motion === "pos" ? "-=" : "+=") + distance;
        el.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
    var effectExplode = $.effects.effect.explode = function(o, done) {
        var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3, cells = rows, el = $(this), mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", offset = el.show().css("visibility", "hidden").offset(), width = Math.ceil(el.outerWidth() / cells), height = Math.ceil(el.outerHeight() / rows), pieces = [], i, j, left, top, mx, my;
        function childComplete() {
            pieces.push(this);
            if (pieces.length === rows * cells) {
                animComplete();
            }
        }
        for (i = 0; i < rows; i++) {
            top = offset.top + i * height;
            my = i - (rows - 1) / 2;
            for (j = 0; j < cells; j++) {
                left = offset.left + j * width;
                mx = j - (cells - 1) / 2;
                el.clone().appendTo("body").wrap("<div></div>").css({
                    position: "absolute",
                    visibility: "visible",
                    left: -j * width,
                    top: -i * height
                }).parent().addClass("ui-effects-explode").css({
                    position: "absolute",
                    overflow: "hidden",
                    width: width,
                    height: height,
                    left: left + (show ? mx * width : 0),
                    top: top + (show ? my * height : 0),
                    opacity: show ? 0 : 1
                }).animate({
                    left: left + (show ? 0 : mx * width),
                    top: top + (show ? 0 : my * height),
                    opacity: show ? 1 : 0
                }, o.duration || 500, o.easing, childComplete);
            }
        }
        function animComplete() {
            el.css({
                visibility: "visible"
            });
            $(pieces).remove();
            if (!show) {
                el.hide();
            }
            done();
        }
    };
    var effectFade = $.effects.effect.fade = function(o, done) {
        var el = $(this), mode = $.effects.setMode(el, o.mode || "toggle");
        el.animate({
            opacity: mode
        }, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: done
        });
    };
    var effectFold = $.effects.effect.fold = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "hide"), show = mode === "show", hide = mode === "hide", size = o.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!o.horizFirst, widthFirst = show !== horizFirst, ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ], duration = o.duration / 2, wrapper, distance, animation1 = {}, animation2 = {};
        $.effects.save(el, props);
        el.show();
        wrapper = $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        distance = widthFirst ? [ wrapper.width(), wrapper.height() ] : [ wrapper.height(), wrapper.width() ];
        if (percent) {
            size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
        }
        if (show) {
            wrapper.css(horizFirst ? {
                height: 0,
                width: size
            } : {
                height: size,
                width: 0
            });
        }
        animation1[ref[0]] = show ? distance[0] : size;
        animation2[ref[1]] = show ? distance[1] : 0;
        wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function() {
            if (hide) {
                el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
        });
    };
    var effectHighlight = $.effects.effect.highlight = function(o, done) {
        var elem = $(this), props = [ "backgroundImage", "backgroundColor", "opacity" ], mode = $.effects.setMode(elem, o.mode || "show"), animation = {
            backgroundColor: elem.css("backgroundColor")
        };
        if (mode === "hide") {
            animation.opacity = 0;
        }
        $.effects.save(elem, props);
        elem.show().css({
            backgroundImage: "none",
            backgroundColor: o.color || "#ffff99"
        }).animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (mode === "hide") {
                    elem.hide();
                }
                $.effects.restore(elem, props);
                done();
            }
        });
    };
    var effectSize = $.effects.effect.size = function(o, done) {
        var original, baseline, factor, el = $(this), props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ], props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ], props2 = [ "width", "height", "overflow" ], cProps = [ "fontSize" ], vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ], hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ], mode = $.effects.setMode(el, o.mode || "effect"), restore = o.restore || mode !== "effect", scale = o.scale || "both", origin = o.origin || [ "middle", "center" ], position = el.css("position"), props = restore ? props0 : props1, zero = {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        };
        if (mode === "show") {
            el.show();
        }
        original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        };
        if (o.mode === "toggle" && mode === "show") {
            el.from = o.to || zero;
            el.to = o.from || original;
        } else {
            el.from = o.from || (mode === "show" ? zero : original);
            el.to = o.to || (mode === "hide" ? zero : original);
        }
        factor = {
            from: {
                y: el.from.height / original.height,
                x: el.from.width / original.width
            },
            to: {
                y: el.to.height / original.height,
                x: el.to.width / original.width
            }
        };
        if (scale === "box" || scale === "both") {
            if (factor.from.y !== factor.to.y) {
                props = props.concat(vProps);
                el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
                el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
            }
            if (factor.from.x !== factor.to.x) {
                props = props.concat(hProps);
                el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
                el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
            }
        }
        if (scale === "content" || scale === "both") {
            if (factor.from.y !== factor.to.y) {
                props = props.concat(cProps).concat(props2);
                el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
                el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
            }
        }
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        el.css("overflow", "hidden").css(el.from);
        if (origin) {
            baseline = $.effects.getBaseline(origin, original);
            el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
            el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
            el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
            el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
        }
        el.css(el.from);
        if (scale === "content" || scale === "both") {
            vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
            hProps = hProps.concat([ "marginLeft", "marginRight" ]);
            props2 = props0.concat(vProps).concat(hProps);
            el.find("*[width]").each(function() {
                var child = $(this), c_original = {
                    height: child.height(),
                    width: child.width(),
                    outerHeight: child.outerHeight(),
                    outerWidth: child.outerWidth()
                };
                if (restore) {
                    $.effects.save(child, props2);
                }
                child.from = {
                    height: c_original.height * factor.from.y,
                    width: c_original.width * factor.from.x,
                    outerHeight: c_original.outerHeight * factor.from.y,
                    outerWidth: c_original.outerWidth * factor.from.x
                };
                child.to = {
                    height: c_original.height * factor.to.y,
                    width: c_original.width * factor.to.x,
                    outerHeight: c_original.height * factor.to.y,
                    outerWidth: c_original.width * factor.to.x
                };
                if (factor.from.y !== factor.to.y) {
                    child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
                    child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
                }
                if (factor.from.x !== factor.to.x) {
                    child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
                    child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
                }
                child.css(child.from);
                child.animate(child.to, o.duration, o.easing, function() {
                    if (restore) {
                        $.effects.restore(child, props2);
                    }
                });
            });
        }
        el.animate(el.to, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (el.to.opacity === 0) {
                    el.css("opacity", el.from.opacity);
                }
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                if (!restore) {
                    if (position === "static") {
                        el.css({
                            position: "relative",
                            top: el.to.top,
                            left: el.to.left
                        });
                    } else {
                        $.each([ "top", "left" ], function(idx, pos) {
                            el.css(pos, function(_, str) {
                                var val = parseInt(str, 10), toRef = idx ? el.to.left : el.to.top;
                                if (str === "auto") {
                                    return toRef + "px";
                                }
                                return val + toRef + "px";
                            });
                        });
                    }
                }
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
    var effectScale = $.effects.effect.scale = function(o, done) {
        var el = $(this), options = $.extend(true, {}, o), mode = $.effects.setMode(el, o.mode || "effect"), percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === "hide" ? 0 : 100), direction = o.direction || "both", origin = o.origin, original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
        }, factor = {
            y: direction !== "horizontal" ? percent / 100 : 1,
            x: direction !== "vertical" ? percent / 100 : 1
        };
        options.effect = "size";
        options.queue = false;
        options.complete = done;
        if (mode !== "effect") {
            options.origin = origin || [ "middle", "center" ];
            options.restore = true;
        }
        options.from = o.from || (mode === "show" ? {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
        } : original);
        options.to = {
            height: original.height * factor.y,
            width: original.width * factor.x,
            outerHeight: original.outerHeight * factor.y,
            outerWidth: original.outerWidth * factor.x
        };
        if (options.fade) {
            if (mode === "show") {
                options.from.opacity = 0;
                options.to.opacity = 1;
            }
            if (mode === "hide") {
                options.from.opacity = 1;
                options.to.opacity = 0;
            }
        }
        el.effect(options);
    };
    var effectPuff = $.effects.effect.puff = function(o, done) {
        var elem = $(this), mode = $.effects.setMode(elem, o.mode || "hide"), hide = mode === "hide", percent = parseInt(o.percent, 10) || 150, factor = percent / 100, original = {
            height: elem.height(),
            width: elem.width(),
            outerHeight: elem.outerHeight(),
            outerWidth: elem.outerWidth()
        };
        $.extend(o, {
            effect: "scale",
            queue: false,
            fade: true,
            mode: mode,
            complete: done,
            percent: hide ? percent : 100,
            from: hide ? original : {
                height: original.height * factor,
                width: original.width * factor,
                outerHeight: original.outerHeight * factor,
                outerWidth: original.outerWidth * factor
            }
        });
        elem.effect(o);
    };
    var effectPulsate = $.effects.effect.pulsate = function(o, done) {
        var elem = $(this), mode = $.effects.setMode(elem, o.mode || "show"), show = mode === "show", hide = mode === "hide", showhide = show || mode === "hide", anims = (o.times || 5) * 2 + (showhide ? 1 : 0), duration = o.duration / anims, animateTo = 0, queue = elem.queue(), queuelen = queue.length, i;
        if (show || !elem.is(":visible")) {
            elem.css("opacity", 0).show();
            animateTo = 1;
        }
        for (i = 1; i < anims; i++) {
            elem.animate({
                opacity: animateTo
            }, duration, o.easing);
            animateTo = 1 - animateTo;
        }
        elem.animate({
            opacity: animateTo
        }, duration, o.easing);
        elem.queue(function() {
            if (hide) {
                elem.hide();
            }
            done();
        });
        if (queuelen > 1) {
            queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
        }
        elem.dequeue();
    };
    var effectShake = $.effects.effect.shake = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "height", "width" ], mode = $.effects.setMode(el, o.mode || "effect"), direction = o.direction || "left", distance = o.distance || 20, times = o.times || 3, anims = times * 2 + 1, speed = Math.round(o.duration / anims), ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", animation = {}, animation1 = {}, animation2 = {}, i, queue = el.queue(), queuelen = queue.length;
        $.effects.save(el, props);
        el.show();
        $.effects.createWrapper(el);
        animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
        animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
        animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;
        el.animate(animation, speed, o.easing);
        for (i = 1; i < times; i++) {
            el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
        }
        el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function() {
            if (mode === "hide") {
                el.hide();
            }
            $.effects.restore(el, props);
            $.effects.removeWrapper(el);
            done();
        });
        if (queuelen > 1) {
            queue.splice.apply(queue, [ 1, 0 ].concat(queue.splice(queuelen, anims + 1)));
        }
        el.dequeue();
    };
    var effectSlide = $.effects.effect.slide = function(o, done) {
        var el = $(this), props = [ "position", "top", "bottom", "left", "right", "width", "height" ], mode = $.effects.setMode(el, o.mode || "show"), show = mode === "show", direction = o.direction || "left", ref = direction === "up" || direction === "down" ? "top" : "left", positiveMotion = direction === "up" || direction === "left", distance, animation = {};
        $.effects.save(el, props);
        el.show();
        distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true);
        $.effects.createWrapper(el).css({
            overflow: "hidden"
        });
        if (show) {
            el.css(ref, positiveMotion ? isNaN(distance) ? "-" + distance : -distance : distance);
        }
        animation[ref] = (show ? positiveMotion ? "+=" : "-=" : positiveMotion ? "-=" : "+=") + distance;
        el.animate(animation, {
            queue: false,
            duration: o.duration,
            easing: o.easing,
            complete: function() {
                if (mode === "hide") {
                    el.hide();
                }
                $.effects.restore(el, props);
                $.effects.removeWrapper(el);
                done();
            }
        });
    };
    var effectTransfer = $.effects.effect.transfer = function(o, done) {
        var elem = $(this), target = $(o.to), targetFixed = target.css("position") === "fixed", body = $("body"), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
            top: endPosition.top - fixTop,
            left: endPosition.left - fixLeft,
            height: target.innerHeight(),
            width: target.innerWidth()
        }, startPosition = elem.offset(), transfer = $("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(o.className).css({
            top: startPosition.top - fixTop,
            left: startPosition.left - fixLeft,
            height: elem.innerHeight(),
            width: elem.innerWidth(),
            position: targetFixed ? "fixed" : "absolute"
        }).animate(animation, o.duration, o.easing, function() {
            transfer.remove();
            done();
        });
    };
    var progressbar = $.widget("ui.progressbar", {
        version: "1.11.4",
        options: {
            max: 100,
            value: 0,
            change: null,
            complete: null
        },
        min: 0,
        _create: function() {
            this.oldValue = this.options.value = this._constrainedValue();
            this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
                role: "progressbar",
                "aria-valuemin": this.min
            });
            this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);
            this._refreshValue();
        },
        _destroy: function() {
            this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
            this.valueDiv.remove();
        },
        value: function(newValue) {
            if (newValue === undefined) {
                return this.options.value;
            }
            this.options.value = this._constrainedValue(newValue);
            this._refreshValue();
        },
        _constrainedValue: function(newValue) {
            if (newValue === undefined) {
                newValue = this.options.value;
            }
            this.indeterminate = newValue === false;
            if (typeof newValue !== "number") {
                newValue = 0;
            }
            return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
        },
        _setOptions: function(options) {
            var value = options.value;
            delete options.value;
            this._super(options);
            this.options.value = this._constrainedValue(value);
            this._refreshValue();
        },
        _setOption: function(key, value) {
            if (key === "max") {
                value = Math.max(this.min, value);
            }
            if (key === "disabled") {
                this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
            }
            this._super(key, value);
        },
        _percentage: function() {
            return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
        },
        _refreshValue: function() {
            var value = this.options.value, percentage = this._percentage();
            this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass("ui-corner-right", value === this.options.max).width(percentage.toFixed(0) + "%");
            this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate);
            if (this.indeterminate) {
                this.element.removeAttr("aria-valuenow");
                if (!this.overlayDiv) {
                    this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
                }
            } else {
                this.element.attr({
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value
                });
                if (this.overlayDiv) {
                    this.overlayDiv.remove();
                    this.overlayDiv = null;
                }
            }
            if (this.oldValue !== value) {
                this.oldValue = value;
                this._trigger("change");
            }
            if (value === this.options.max) {
                this._trigger("complete");
            }
        }
    });
    var selectable = $.widget("ui.selectable", $.ui.mouse, {
        version: "1.11.4",
        options: {
            appendTo: "body",
            autoRefresh: true,
            distance: 0,
            filter: "*",
            tolerance: "touch",
            selected: null,
            selecting: null,
            start: null,
            stop: null,
            unselected: null,
            unselecting: null
        },
        _create: function() {
            var selectees, that = this;
            this.element.addClass("ui-selectable");
            this.dragged = false;
            this.refresh = function() {
                selectees = $(that.options.filter, that.element[0]);
                selectees.addClass("ui-selectee");
                selectees.each(function() {
                    var $this = $(this), pos = $this.offset();
                    $.data(this, "selectable-item", {
                        element: this,
                        $element: $this,
                        left: pos.left,
                        top: pos.top,
                        right: pos.left + $this.outerWidth(),
                        bottom: pos.top + $this.outerHeight(),
                        startselected: false,
                        selected: $this.hasClass("ui-selected"),
                        selecting: $this.hasClass("ui-selecting"),
                        unselecting: $this.hasClass("ui-unselecting")
                    });
                });
            };
            this.refresh();
            this.selectees = selectees.addClass("ui-selectee");
            this._mouseInit();
            this.helper = $("<div class='ui-selectable-helper'></div>");
        },
        _destroy: function() {
            this.selectees.removeClass("ui-selectee").removeData("selectable-item");
            this.element.removeClass("ui-selectable ui-selectable-disabled");
            this._mouseDestroy();
        },
        _mouseStart: function(event) {
            var that = this, options = this.options;
            this.opos = [ event.pageX, event.pageY ];
            if (this.options.disabled) {
                return;
            }
            this.selectees = $(options.filter, this.element[0]);
            this._trigger("start", event);
            $(options.appendTo).append(this.helper);
            this.helper.css({
                left: event.pageX,
                top: event.pageY,
                width: 0,
                height: 0
            });
            if (options.autoRefresh) {
                this.refresh();
            }
            this.selectees.filter(".ui-selected").each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.startselected = true;
                if (!event.metaKey && !event.ctrlKey) {
                    selectee.$element.removeClass("ui-selected");
                    selectee.selected = false;
                    selectee.$element.addClass("ui-unselecting");
                    selectee.unselecting = true;
                    that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    });
                }
            });
            $(event.target).parents().addBack().each(function() {
                var doSelect, selectee = $.data(this, "selectable-item");
                if (selectee) {
                    doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass("ui-selected");
                    selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected").addClass(doSelect ? "ui-selecting" : "ui-unselecting");
                    selectee.unselecting = !doSelect;
                    selectee.selecting = doSelect;
                    selectee.selected = doSelect;
                    if (doSelect) {
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    } else {
                        that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        });
                    }
                    return false;
                }
            });
        },
        _mouseDrag: function(event) {
            this.dragged = true;
            if (this.options.disabled) {
                return;
            }
            var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            this.helper.css({
                left: x1,
                top: y1,
                width: x2 - x1,
                height: y2 - y1
            });
            this.selectees.each(function() {
                var selectee = $.data(this, "selectable-item"), hit = false;
                if (!selectee || selectee.element === that.element[0]) {
                    return;
                }
                if (options.tolerance === "touch") {
                    hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);
                } else if (options.tolerance === "fit") {
                    hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;
                }
                if (hit) {
                    if (selectee.selected) {
                        selectee.$element.removeClass("ui-selected");
                        selectee.selected = false;
                    }
                    if (selectee.unselecting) {
                        selectee.$element.removeClass("ui-unselecting");
                        selectee.unselecting = false;
                    }
                    if (!selectee.selecting) {
                        selectee.$element.addClass("ui-selecting");
                        selectee.selecting = true;
                        that._trigger("selecting", event, {
                            selecting: selectee.element
                        });
                    }
                } else {
                    if (selectee.selecting) {
                        if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                            selectee.$element.removeClass("ui-selecting");
                            selectee.selecting = false;
                            selectee.$element.addClass("ui-selected");
                            selectee.selected = true;
                        } else {
                            selectee.$element.removeClass("ui-selecting");
                            selectee.selecting = false;
                            if (selectee.startselected) {
                                selectee.$element.addClass("ui-unselecting");
                                selectee.unselecting = true;
                            }
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                    if (selectee.selected) {
                        if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                            selectee.$element.removeClass("ui-selected");
                            selectee.selected = false;
                            selectee.$element.addClass("ui-unselecting");
                            selectee.unselecting = true;
                            that._trigger("unselecting", event, {
                                unselecting: selectee.element
                            });
                        }
                    }
                }
            });
            return false;
        },
        _mouseStop: function(event) {
            var that = this;
            this.dragged = false;
            $(".ui-unselecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-unselecting");
                selectee.unselecting = false;
                selectee.startselected = false;
                that._trigger("unselected", event, {
                    unselected: selectee.element
                });
            });
            $(".ui-selecting", this.element[0]).each(function() {
                var selectee = $.data(this, "selectable-item");
                selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
                selectee.selecting = false;
                selectee.selected = true;
                selectee.startselected = true;
                that._trigger("selected", event, {
                    selected: selectee.element
                });
            });
            this._trigger("stop", event);
            this.helper.remove();
            return false;
        }
    });
    var selectmenu = $.widget("ui.selectmenu", {
        version: "1.11.4",
        defaultElement: "<select>",
        options: {
            appendTo: null,
            disabled: null,
            icons: {
                button: "ui-icon-triangle-1-s"
            },
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            width: null,
            change: null,
            close: null,
            focus: null,
            open: null,
            select: null
        },
        _create: function() {
            var selectmenuId = this.element.uniqueId().attr("id");
            this.ids = {
                element: selectmenuId,
                button: selectmenuId + "-button",
                menu: selectmenuId + "-menu"
            };
            this._drawButton();
            this._drawMenu();
            if (this.options.disabled) {
                this.disable();
            }
        },
        _drawButton: function() {
            var that = this;
            this.label = $("label[for='" + this.ids.element + "']").attr("for", this.ids.button);
            this._on(this.label, {
                click: function(event) {
                    this.button.focus();
                    event.preventDefault();
                }
            });
            this.element.hide();
            this.button = $("<span>", {
                class: "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
                tabindex: this.options.disabled ? -1 : 0,
                id: this.ids.button,
                role: "combobox",
                "aria-expanded": "false",
                "aria-autocomplete": "list",
                "aria-owns": this.ids.menu,
                "aria-haspopup": "true"
            }).insertAfter(this.element);
            $("<span>", {
                class: "ui-icon " + this.options.icons.button
            }).prependTo(this.button);
            this.buttonText = $("<span>", {
                class: "ui-selectmenu-text"
            }).appendTo(this.button);
            this._setText(this.buttonText, this.element.find("option:selected").text());
            this._resizeButton();
            this._on(this.button, this._buttonEvents);
            this.button.one("focusin", function() {
                if (!that.menuItems) {
                    that._refreshMenu();
                }
            });
            this._hoverable(this.button);
            this._focusable(this.button);
        },
        _drawMenu: function() {
            var that = this;
            this.menu = $("<ul>", {
                "aria-hidden": "true",
                "aria-labelledby": this.ids.button,
                id: this.ids.menu
            });
            this.menuWrap = $("<div>", {
                class: "ui-selectmenu-menu ui-front"
            }).append(this.menu).appendTo(this._appendTo());
            this.menuInstance = this.menu.menu({
                role: "listbox",
                select: function(event, ui) {
                    event.preventDefault();
                    that._setSelection();
                    that._select(ui.item.data("ui-selectmenu-item"), event);
                },
                focus: function(event, ui) {
                    var item = ui.item.data("ui-selectmenu-item");
                    if (that.focusIndex != null && item.index !== that.focusIndex) {
                        that._trigger("focus", event, {
                            item: item
                        });
                        if (!that.isOpen) {
                            that._select(item, event);
                        }
                    }
                    that.focusIndex = item.index;
                    that.button.attr("aria-activedescendant", that.menuItems.eq(item.index).attr("id"));
                }
            }).menu("instance");
            this.menu.addClass("ui-corner-bottom").removeClass("ui-corner-all");
            this.menuInstance._off(this.menu, "mouseleave");
            this.menuInstance._closeOnDocumentClick = function() {
                return false;
            };
            this.menuInstance._isDivider = function() {
                return false;
            };
        },
        refresh: function() {
            this._refreshMenu();
            this._setText(this.buttonText, this._getSelectedItem().text());
            if (!this.options.width) {
                this._resizeButton();
            }
        },
        _refreshMenu: function() {
            this.menu.empty();
            var item, options = this.element.find("option");
            if (!options.length) {
                return;
            }
            this._parseOptions(options);
            this._renderMenu(this.menu, this.items);
            this.menuInstance.refresh();
            this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup");
            item = this._getSelectedItem();
            this.menuInstance.focus(null, item);
            this._setAria(item.data("ui-selectmenu-item"));
            this._setOption("disabled", this.element.prop("disabled"));
        },
        open: function(event) {
            if (this.options.disabled) {
                return;
            }
            if (!this.menuItems) {
                this._refreshMenu();
            } else {
                this.menu.find(".ui-state-focus").removeClass("ui-state-focus");
                this.menuInstance.focus(null, this._getSelectedItem());
            }
            this.isOpen = true;
            this._toggleAttr();
            this._resizeMenu();
            this._position();
            this._on(this.document, this._documentClick);
            this._trigger("open", event);
        },
        _position: function() {
            this.menuWrap.position($.extend({
                of: this.button
            }, this.options.position));
        },
        close: function(event) {
            if (!this.isOpen) {
                return;
            }
            this.isOpen = false;
            this._toggleAttr();
            this.range = null;
            this._off(this.document);
            this._trigger("close", event);
        },
        widget: function() {
            return this.button;
        },
        menuWidget: function() {
            return this.menu;
        },
        _renderMenu: function(ul, items) {
            var that = this, currentOptgroup = "";
            $.each(items, function(index, item) {
                if (item.optgroup !== currentOptgroup) {
                    $("<li>", {
                        class: "ui-selectmenu-optgroup ui-menu-divider" + (item.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : ""),
                        text: item.optgroup
                    }).appendTo(ul);
                    currentOptgroup = item.optgroup;
                }
                that._renderItemData(ul, item);
            });
        },
        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-selectmenu-item", item);
        },
        _renderItem: function(ul, item) {
            var li = $("<li>");
            if (item.disabled) {
                li.addClass("ui-state-disabled");
            }
            this._setText(li, item.label);
            return li.appendTo(ul);
        },
        _setText: function(element, value) {
            if (value) {
                element.text(value);
            } else {
                element.html("&#160;");
            }
        },
        _move: function(direction, event) {
            var item, next, filter = ".ui-menu-item";
            if (this.isOpen) {
                item = this.menuItems.eq(this.focusIndex);
            } else {
                item = this.menuItems.eq(this.element[0].selectedIndex);
                filter += ":not(.ui-state-disabled)";
            }
            if (direction === "first" || direction === "last") {
                next = item[direction === "first" ? "prevAll" : "nextAll"](filter).eq(-1);
            } else {
                next = item[direction + "All"](filter).eq(0);
            }
            if (next.length) {
                this.menuInstance.focus(event, next);
            }
        },
        _getSelectedItem: function() {
            return this.menuItems.eq(this.element[0].selectedIndex);
        },
        _toggle: function(event) {
            this[this.isOpen ? "close" : "open"](event);
        },
        _setSelection: function() {
            var selection;
            if (!this.range) {
                return;
            }
            if (window.getSelection) {
                selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(this.range);
            } else {
                this.range.select();
            }
            this.button.focus();
        },
        _documentClick: {
            mousedown: function(event) {
                if (!this.isOpen) {
                    return;
                }
                if (!$(event.target).closest(".ui-selectmenu-menu, #" + this.ids.button).length) {
                    this.close(event);
                }
            }
        },
        _buttonEvents: {
            mousedown: function() {
                var selection;
                if (window.getSelection) {
                    selection = window.getSelection();
                    if (selection.rangeCount) {
                        this.range = selection.getRangeAt(0);
                    }
                } else {
                    this.range = document.selection.createRange();
                }
            },
            click: function(event) {
                this._setSelection();
                this._toggle(event);
            },
            keydown: function(event) {
                var preventDefault = true;
                switch (event.keyCode) {
                  case $.ui.keyCode.TAB:
                  case $.ui.keyCode.ESCAPE:
                    this.close(event);
                    preventDefault = false;
                    break;

                  case $.ui.keyCode.ENTER:
                    if (this.isOpen) {
                        this._selectFocusedItem(event);
                    }
                    break;

                  case $.ui.keyCode.UP:
                    if (event.altKey) {
                        this._toggle(event);
                    } else {
                        this._move("prev", event);
                    }
                    break;

                  case $.ui.keyCode.DOWN:
                    if (event.altKey) {
                        this._toggle(event);
                    } else {
                        this._move("next", event);
                    }
                    break;

                  case $.ui.keyCode.SPACE:
                    if (this.isOpen) {
                        this._selectFocusedItem(event);
                    } else {
                        this._toggle(event);
                    }
                    break;

                  case $.ui.keyCode.LEFT:
                    this._move("prev", event);
                    break;

                  case $.ui.keyCode.RIGHT:
                    this._move("next", event);
                    break;

                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.PAGE_UP:
                    this._move("first", event);
                    break;

                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_DOWN:
                    this._move("last", event);
                    break;

                  default:
                    this.menu.trigger(event);
                    preventDefault = false;
                }
                if (preventDefault) {
                    event.preventDefault();
                }
            }
        },
        _selectFocusedItem: function(event) {
            var item = this.menuItems.eq(this.focusIndex);
            if (!item.hasClass("ui-state-disabled")) {
                this._select(item.data("ui-selectmenu-item"), event);
            }
        },
        _select: function(item, event) {
            var oldIndex = this.element[0].selectedIndex;
            this.element[0].selectedIndex = item.index;
            this._setText(this.buttonText, item.label);
            this._setAria(item);
            this._trigger("select", event, {
                item: item
            });
            if (item.index !== oldIndex) {
                this._trigger("change", event, {
                    item: item
                });
            }
            this.close(event);
        },
        _setAria: function(item) {
            var id = this.menuItems.eq(item.index).attr("id");
            this.button.attr({
                "aria-labelledby": id,
                "aria-activedescendant": id
            });
            this.menu.attr("aria-activedescendant", id);
        },
        _setOption: function(key, value) {
            if (key === "icons") {
                this.button.find("span.ui-icon").removeClass(this.options.icons.button).addClass(value.button);
            }
            this._super(key, value);
            if (key === "appendTo") {
                this.menuWrap.appendTo(this._appendTo());
            }
            if (key === "disabled") {
                this.menuInstance.option("disabled", value);
                this.button.toggleClass("ui-state-disabled", value).attr("aria-disabled", value);
                this.element.prop("disabled", value);
                if (value) {
                    this.button.attr("tabindex", -1);
                    this.close();
                } else {
                    this.button.attr("tabindex", 0);
                }
            }
            if (key === "width") {
                this._resizeButton();
            }
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            if (element) {
                element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
            }
            if (!element || !element[0]) {
                element = this.element.closest(".ui-front");
            }
            if (!element.length) {
                element = this.document[0].body;
            }
            return element;
        },
        _toggleAttr: function() {
            this.button.toggleClass("ui-corner-top", this.isOpen).toggleClass("ui-corner-all", !this.isOpen).attr("aria-expanded", this.isOpen);
            this.menuWrap.toggleClass("ui-selectmenu-open", this.isOpen);
            this.menu.attr("aria-hidden", !this.isOpen);
        },
        _resizeButton: function() {
            var width = this.options.width;
            if (!width) {
                width = this.element.show().outerWidth();
                this.element.hide();
            }
            this.button.outerWidth(width);
        },
        _resizeMenu: function() {
            this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1));
        },
        _getCreateOptions: function() {
            return {
                disabled: this.element.prop("disabled")
            };
        },
        _parseOptions: function(options) {
            var data = [];
            options.each(function(index, item) {
                var option = $(item), optgroup = option.parent("optgroup");
                data.push({
                    element: option,
                    index: index,
                    value: option.val(),
                    label: option.text(),
                    optgroup: optgroup.attr("label") || "",
                    disabled: optgroup.prop("disabled") || option.prop("disabled")
                });
            });
            this.items = data;
        },
        _destroy: function() {
            this.menuWrap.remove();
            this.button.remove();
            this.element.show();
            this.element.removeUniqueId();
            this.label.attr("for", this.ids.element);
        }
    });
    var slider = $.widget("ui.slider", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "slide",
        options: {
            animate: false,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,
            change: null,
            slide: null,
            start: null,
            stop: null
        },
        numPages: 5,
        _create: function() {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();
            this._calculateNewMax();
            this.element.addClass("ui-slider" + " ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all");
            this._refresh();
            this._setOption("disabled", this.options.disabled);
            this._animateOff = false;
        },
        _refresh: function() {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },
        _createHandles: function() {
            var i, handleCount, options = this.options, existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"), handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>", handles = [];
            handleCount = options.values && options.values.length || 1;
            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }
            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }
            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));
            this.handle = this.handles.eq(0);
            this.handles.each(function(i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },
        _createRange: function() {
            var options = this.options, classes = "";
            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [ this._valueMin(), this._valueMin() ];
                    } else if (options.values.length && options.values.length !== 2) {
                        options.values = [ options.values[0], options.values[0] ];
                    } else if ($.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }
                if (!this.range || !this.range.length) {
                    this.range = $("<div></div>").appendTo(this.element);
                    classes = "ui-slider-range" + " ui-widget-header ui-corner-all";
                } else {
                    this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                        left: "",
                        bottom: ""
                    });
                }
                this.range.addClass(classes + (options.range === "min" || options.range === "max" ? " ui-slider-range-" + options.range : ""));
            } else {
                if (this.range) {
                    this.range.remove();
                }
                this.range = null;
            }
        },
        _setupEvents: function() {
            this._off(this.handles);
            this._on(this.handles, this._handleEvents);
            this._hoverable(this.handles);
            this._focusable(this.handles);
        },
        _destroy: function() {
            this.handles.remove();
            if (this.range) {
                this.range.remove();
            }
            this.element.removeClass("ui-slider" + " ui-slider-horizontal" + " ui-slider-vertical" + " ui-widget" + " ui-widget-content" + " ui-corner-all");
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
            if (o.disabled) {
                return false;
            }
            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();
            position = {
                x: event.pageX,
                y: event.pageY
            };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });
            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;
            this._handleIndex = index;
            closestHandle.addClass("ui-state-active").focus();
            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - closestHandle.width() / 2,
                top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
            };
            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },
        _mouseStart: function() {
            return true;
        },
        _mouseDrag: function(event) {
            var position = {
                x: event.pageX,
                y: event.pageY
            }, normValue = this._normValueFromMouse(position);
            this._slide(event, this._handleIndex, normValue);
            return false;
        },
        _mouseStop: function(event) {
            this.handles.removeClass("ui-state-active");
            this._mouseSliding = false;
            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);
            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;
            return false;
        },
        _detectOrientation: function() {
            this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal";
        },
        _normValueFromMouse: function(position) {
            var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
            }
            percentMouse = pixelMouse / pixelTotal;
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }
            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;
            return this._trimAlignValue(valueMouse);
        },
        _start: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            return this._trigger("start", event, uiHash);
        },
        _slide: function(event, index, newVal) {
            var otherVal, newValues, allowed;
            if (this.options.values && this.options.values.length) {
                otherVal = this.values(index ? 0 : 1);
                if (this.options.values.length === 2 && this.options.range === true && (index === 0 && newVal > otherVal || index === 1 && newVal < otherVal)) {
                    newVal = otherVal;
                }
                if (newVal !== this.values(index)) {
                    newValues = this.values();
                    newValues[index] = newVal;
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal,
                        values: newValues
                    });
                    otherVal = this.values(index ? 0 : 1);
                    if (allowed !== false) {
                        this.values(index, newVal);
                    }
                }
            } else {
                if (newVal !== this.value()) {
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal
                    });
                    if (allowed !== false) {
                        this.value(newVal);
                    }
                }
            }
        },
        _stop: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            this._trigger("stop", event, uiHash);
        },
        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }
                this._lastChangedValue = index;
                this._trigger("change", event, uiHash);
            }
        },
        value: function(newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }
            return this._value();
        },
        values: function(index, newValue) {
            var vals, newValues, i;
            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }
            if (arguments.length) {
                if ($.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this.options.values && this.options.values.length) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },
        _setOption: function(key, value) {
            var i, valsLength = 0;
            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(this.options.values.length - 1);
                    this.options.values = null;
                }
            }
            if ($.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }
            if (key === "disabled") {
                this.element.toggleClass("ui-state-disabled", !!value);
            }
            this._super(key, value);
            switch (key) {
              case "orientation":
                this._detectOrientation();
                this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation);
                this._refreshValue();
                this.handles.css(value === "horizontal" ? "bottom" : "left", "");
                break;

              case "value":
                this._animateOff = true;
                this._refreshValue();
                this._change(null, 0);
                this._animateOff = false;
                break;

              case "values":
                this._animateOff = true;
                this._refreshValue();
                for (i = 0; i < valsLength; i += 1) {
                    this._change(null, i);
                }
                this._animateOff = false;
                break;

              case "step":
              case "min":
              case "max":
                this._animateOff = true;
                this._calculateNewMax();
                this._refreshValue();
                this._animateOff = false;
                break;

              case "range":
                this._animateOff = true;
                this._refresh();
                this._animateOff = false;
                break;
            }
        },
        _value: function() {
            var val = this.options.value;
            val = this._trimAlignValue(val);
            return val;
        },
        _values: function(index) {
            var val, vals, i;
            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);
                return val;
            } else if (this.options.values && this.options.values.length) {
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }
                return vals;
            } else {
                return [];
            }
        },
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += valModStep > 0 ? step : -step;
            }
            return parseFloat(alignValue.toFixed(5));
        },
        _calculateNewMax: function() {
            var max = this.options.max, min = this._valueMin(), step = this.options.step, aboveMin = Math.floor(+(max - min).toFixed(this._precision()) / step) * step;
            max = aboveMin + min;
            this.max = parseFloat(max.toFixed(this._precision()));
        },
        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },
        _precisionOf: function(num) {
            var str = num.toString(), decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },
        _valueMin: function() {
            return this.options.min;
        },
        _valueMax: function() {
            return this.max;
        },
        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = !this._animateOff ? o.animate : false, _set = {};
            if (this.options.values && this.options.values.length) {
                this.handles.each(function(i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                    _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    left: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    width: valPercent - lastValPercent + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        } else {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    bottom: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    height: valPercent - lastValPercent + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
                _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        width: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range[animate ? "animate" : "css"]({
                        width: 100 - valPercent + "%"
                    }, {
                        queue: false,
                        duration: o.animate
                    });
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        height: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range[animate ? "animate" : "css"]({
                        height: 100 - valPercent + "%"
                    }, {
                        queue: false,
                        duration: o.animate
                    });
                }
            }
        },
        _handleEvents: {
            keydown: function(event) {
                var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                  case $.ui.keyCode.END:
                  case $.ui.keyCode.PAGE_UP:
                  case $.ui.keyCode.PAGE_DOWN:
                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    event.preventDefault();
                    if (!this._keySliding) {
                        this._keySliding = true;
                        $(event.target).addClass("ui-state-active");
                        allowed = this._start(event, index);
                        if (allowed === false) {
                            return;
                        }
                    }
                    break;
                }
                step = this.options.step;
                if (this.options.values && this.options.values.length) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }
                switch (event.keyCode) {
                  case $.ui.keyCode.HOME:
                    newVal = this._valueMin();
                    break;

                  case $.ui.keyCode.END:
                    newVal = this._valueMax();
                    break;

                  case $.ui.keyCode.PAGE_UP:
                    newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / this.numPages);
                    break;

                  case $.ui.keyCode.PAGE_DOWN:
                    newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / this.numPages);
                    break;

                  case $.ui.keyCode.UP:
                  case $.ui.keyCode.RIGHT:
                    if (curVal === this._valueMax()) {
                        return;
                    }
                    newVal = this._trimAlignValue(curVal + step);
                    break;

                  case $.ui.keyCode.DOWN:
                  case $.ui.keyCode.LEFT:
                    if (curVal === this._valueMin()) {
                        return;
                    }
                    newVal = this._trimAlignValue(curVal - step);
                    break;
                }
                this._slide(event, index, newVal);
            },
            keyup: function(event) {
                var index = $(event.target).data("ui-slider-handle-index");
                if (this._keySliding) {
                    this._keySliding = false;
                    this._stop(event, index);
                    this._change(event, index);
                    $(event.target).removeClass("ui-state-active");
                }
            }
        }
    });
    var sortable = $.widget("ui.sortable", $.ui.mouse, {
        version: "1.11.4",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1e3,
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _isOverAxis: function(x, reference, size) {
            return x >= reference && x < reference + size;
        },
        _isFloating: function(item) {
            return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"));
        },
        _create: function() {
            this.containerCache = {};
            this.element.addClass("ui-sortable");
            this.refresh();
            this.offset = this.element.offset();
            this._mouseInit();
            this._setHandleClassName();
            this.ready = true;
        },
        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "handle") {
                this._setHandleClassName();
            }
        },
        _setHandleClassName: function() {
            this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle");
            $.each(this.items, function() {
                (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle");
            });
        },
        _destroy: function() {
            this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle");
            this._mouseDestroy();
            for (var i = this.items.length - 1; i >= 0; i--) {
                this.items[i].item.removeData(this.widgetName + "-item");
            }
            return this;
        },
        _mouseCapture: function(event, overrideHandle) {
            var currentItem = null, validHandle = false, that = this;
            if (this.reverting) {
                return false;
            }
            if (this.options.disabled || this.options.type === "static") {
                return false;
            }
            this._refreshItems(event);
            $(event.target).parents().each(function() {
                if ($.data(this, that.widgetName + "-item") === that) {
                    currentItem = $(this);
                    return false;
                }
            });
            if ($.data(event.target, that.widgetName + "-item") === that) {
                currentItem = $(event.target);
            }
            if (!currentItem) {
                return false;
            }
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem).find("*").addBack().each(function() {
                    if (this === event.target) {
                        validHandle = true;
                    }
                });
                if (!validHandle) {
                    return false;
                }
            }
            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;
        },
        _mouseStart: function(event, overrideHandle, noActivation) {
            var i, body, o = this.options;
            this.currentContainer = this;
            this.refreshPositions();
            this.helper = this._createHelper(event);
            this._cacheHelperProportions();
            this._cacheMargins();
            this.scrollParent = this.helper.scrollParent();
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };
            $.extend(this.offset, {
                click: {
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            });
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");
            this.originalPosition = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;
            o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
            this.domPosition = {
                prev: this.currentItem.prev()[0],
                parent: this.currentItem.parent()[0]
            };
            if (this.helper[0] !== this.currentItem[0]) {
                this.currentItem.hide();
            }
            this._createPlaceholder();
            if (o.containment) {
                this._setContainment();
            }
            if (o.cursor && o.cursor !== "auto") {
                body = this.document.find("body");
                this.storedCursor = body.css("cursor");
                body.css("cursor", o.cursor);
                this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
            }
            if (o.opacity) {
                if (this.helper.css("opacity")) {
                    this._storedOpacity = this.helper.css("opacity");
                }
                this.helper.css("opacity", o.opacity);
            }
            if (o.zIndex) {
                if (this.helper.css("zIndex")) {
                    this._storedZIndex = this.helper.css("zIndex");
                }
                this.helper.css("zIndex", o.zIndex);
            }
            if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                this.overflowOffset = this.scrollParent.offset();
            }
            this._trigger("start", event, this._uiHash());
            if (!this._preserveHelperProportions) {
                this._cacheHelperProportions();
            }
            if (!noActivation) {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("activate", event, this._uiHash(this));
                }
            }
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }
            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }
            this.dragging = true;
            this.helper.addClass("ui-sortable-helper");
            this._mouseDrag(event);
            return true;
        },
        _mouseDrag: function(event) {
            var i, item, itemElement, intersection, o = this.options, scrolled = false;
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");
            if (!this.lastPositionAbs) {
                this.lastPositionAbs = this.positionAbs;
            }
            if (this.options.scroll) {
                if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
                    if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                    }
                    if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }
                } else {
                    if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
                    } else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
                        scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
                    }
                    if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
                    } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
                        scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
                    }
                }
                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
            }
            this.positionAbs = this._convertPositionTo("absolute");
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }
            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) {
                    continue;
                }
                if (item.instance !== this.currentContainer) {
                    continue;
                }
                if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
                    this.direction = intersection === 1 ? "down" : "up";
                    if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                        this._rearrange(event, item);
                    } else {
                        break;
                    }
                    this._trigger("change", event, this._uiHash());
                    break;
                }
            }
            this._contactContainers(event);
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }
            this._trigger("sort", event, this._uiHash());
            this.lastPositionAbs = this.positionAbs;
            return false;
        },
        _mouseStop: function(event, noPropagation) {
            if (!event) {
                return;
            }
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                $.ui.ddmanager.drop(this, event);
            }
            if (this.options.revert) {
                var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
                if (!axis || axis === "x") {
                    animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
                }
                if (!axis || axis === "y") {
                    animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
                }
                this.reverting = true;
                $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
                    that._clear(event);
                });
            } else {
                this._clear(event, noPropagation);
            }
            return false;
        },
        cancel: function() {
            if (this.dragging) {
                this._mouseUp({
                    target: null
                });
                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", null, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }
            }
            if (this.placeholder) {
                if (this.placeholder[0].parentNode) {
                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                }
                if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                    this.helper.remove();
                }
                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                });
                if (this.domPosition.prev) {
                    $(this.domPosition.prev).after(this.currentItem);
                } else {
                    $(this.domPosition.parent).prepend(this.currentItem);
                }
            }
            return this;
        },
        serialize: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected), str = [];
            o = o || {};
            $(items).each(function() {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                if (res) {
                    str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                }
            });
            if (!str.length && o.key) {
                str.push(o.key + "=");
            }
            return str.join("&");
        },
        toArray: function(o) {
            var items = this._getItemsAsjQuery(o && o.connected), ret = [];
            o = o || {};
            items.each(function() {
                ret.push($(o.item || this).attr(o.attribute || "id") || "");
            });
            return ret;
        },
        _intersectsWith: function(item) {
            var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = this.options.axis === "x" || y1 + dyClick > t && y1 + dyClick < b, isOverElementWidth = this.options.axis === "y" || x1 + dxClick > l && x1 + dxClick < r, isOverElement = isOverElementHeight && isOverElementWidth;
            if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"]) {
                return isOverElement;
            } else {
                return l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b;
            }
        },
        _intersectsWithPointer: function(item) {
            var isOverElementHeight = this.options.axis === "x" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = this.options.axis === "y" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            if (!isOverElement) {
                return false;
            }
            return this.floating ? horizontalDirection && horizontalDirection === "right" || verticalDirection === "down" ? 2 : 1 : verticalDirection && (verticalDirection === "down" ? 2 : 1);
        },
        _intersectsWithSides: function(item) {
            var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
            if (this.floating && horizontalDirection) {
                return horizontalDirection === "right" && isOverRightHalf || horizontalDirection === "left" && !isOverRightHalf;
            } else {
                return verticalDirection && (verticalDirection === "down" && isOverBottomHalf || verticalDirection === "up" && !isOverBottomHalf);
            }
        },
        _getDragVerticalDirection: function() {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up");
        },
        _getDragHorizontalDirection: function() {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left");
        },
        refresh: function(event) {
            this._refreshItems(event);
            this._setHandleClassName();
            this.refreshPositions();
            return this;
        },
        _connectWith: function() {
            var options = this.options;
            return options.connectWith.constructor === String ? [ options.connectWith ] : options.connectWith;
        },
        _getItemsAsjQuery: function(connected) {
            var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
            if (connectWith && connected) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst ]);
                        }
                    }
                }
            }
            queries.push([ $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                options: this.options,
                item: this.currentItem
            }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this ]);
            function addItems() {
                items.push(this);
            }
            for (i = queries.length - 1; i >= 0; i--) {
                queries[i][0].each(addItems);
            }
            return $(items);
        },
        _removeCurrentsFromItems: function() {
            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
            this.items = $.grep(this.items, function(item) {
                for (var j = 0; j < list.length; j++) {
                    if (list[j] === item.item[0]) {
                        return false;
                    }
                }
                return true;
            });
        },
        _refreshItems: function(event) {
            this.items = [];
            this.containers = [ this ];
            var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [ [ $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                item: this.currentItem
            }) : $(this.options.items, this.element), this ] ], connectWith = this._connectWith();
            if (connectWith && this.ready) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i], this.document[0]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([ $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                                item: this.currentItem
                            }) : $(inst.options.items, inst.element), inst ]);
                            this.containers.push(inst);
                        }
                    }
                }
            }
            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];
                for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                    item = $(_queries[j]);
                    item.data(this.widgetName + "-item", targetData);
                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    });
                }
            }
        },
        refreshPositions: function(fast) {
            this.floating = this.items.length ? this.options.axis === "x" || this._isFloating(this.items[0].item) : false;
            if (this.offsetParent && this.helper) {
                this.offset.parent = this._getParentOffset();
            }
            var i, item, t, p;
            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];
                if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                    continue;
                }
                t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }
                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }
            if (this.options.custom && this.options.custom.refreshContainers) {
                this.options.custom.refreshContainers.call(this);
            } else {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                }
            }
            return this;
        },
        _createPlaceholder: function(that) {
            that = that || this;
            var className, o = that.options;
            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                o.placeholder = {
                    element: function() {
                        var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                        if (nodeName === "tbody") {
                            that._createTrPlaceholder(that.currentItem.find("tr").eq(0), $("<tr>", that.document[0]).appendTo(element));
                        } else if (nodeName === "tr") {
                            that._createTrPlaceholder(that.currentItem, element);
                        } else if (nodeName === "img") {
                            element.attr("src", that.currentItem.attr("src"));
                        }
                        if (!className) {
                            element.css("visibility", "hidden");
                        }
                        return element;
                    },
                    update: function(container, p) {
                        if (className && !o.forcePlaceholderSize) {
                            return;
                        }
                        if (!p.height()) {
                            p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
                        }
                        if (!p.width()) {
                            p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
                        }
                    }
                };
            }
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
            that.currentItem.after(that.placeholder);
            o.placeholder.update(that, that.placeholder);
        },
        _createTrPlaceholder: function(sourceTr, targetTr) {
            var that = this;
            sourceTr.children().each(function() {
                $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(targetTr);
            });
        },
        _contactContainers: function(event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis, innermostContainer = null, innermostIndex = null;
            for (i = this.containers.length - 1; i >= 0; i--) {
                if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                    continue;
                }
                if (this._intersectsWith(this.containers[i].containerCache)) {
                    if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                        continue;
                    }
                    innermostContainer = this.containers[i];
                    innermostIndex = i;
                } else {
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", event, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }
            }
            if (!innermostContainer) {
                return;
            }
            if (this.containers.length === 1) {
                if (!this.containers[innermostIndex].containerCache.over) {
                    this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                    this.containers[innermostIndex].containerCache.over = 1;
                }
            } else {
                dist = 1e4;
                itemWithLeastDistance = null;
                floating = innermostContainer.floating || this._isFloating(this.currentItem);
                posProperty = floating ? "left" : "top";
                sizeProperty = floating ? "width" : "height";
                axis = floating ? "clientX" : "clientY";
                for (j = this.items.length - 1; j >= 0; j--) {
                    if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                        continue;
                    }
                    if (this.items[j].item[0] === this.currentItem[0]) {
                        continue;
                    }
                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
                        nearBottom = true;
                    }
                    if (Math.abs(event[axis] - cur) < dist) {
                        dist = Math.abs(event[axis] - cur);
                        itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                    return;
                }
                if (this.currentContainer === this.containers[innermostIndex]) {
                    if (!this.currentContainer.containerCache.over) {
                        this.containers[innermostIndex]._trigger("over", event, this._uiHash());
                        this.currentContainer.containerCache.over = 1;
                    }
                    return;
                }
                itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
                this.currentContainer = this.containers[innermostIndex];
                this.options.placeholder.update(this.currentContainer, this.placeholder);
                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            }
        },
        _createHelper: function(event) {
            var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event, this.currentItem ])) : o.helper === "clone" ? this.currentItem.clone() : this.currentItem;
            if (!helper.parents("body").length) {
                $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
            }
            if (helper[0] === this.currentItem[0]) {
                this._storedCSS = {
                    width: this.currentItem[0].style.width,
                    height: this.currentItem[0].style.height,
                    position: this.currentItem.css("position"),
                    top: this.currentItem.css("top"),
                    left: this.currentItem.css("left")
                };
            }
            if (!helper[0].style.width || o.forceHelperSize) {
                helper.width(this.currentItem.width());
            }
            if (!helper[0].style.height || o.forceHelperSize) {
                helper.height(this.currentItem.height());
            }
            return helper;
        },
        _adjustOffsetFromHelper: function(obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },
        _getParentOffset: function() {
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }
            if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie) {
                po = {
                    top: 0,
                    left: 0
                };
            }
            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            } else {
                return {
                    top: 0,
                    left: 0
                };
            }
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                top: parseInt(this.currentItem.css("marginTop"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var ce, co, over, o = this.options;
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [ 0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ];
            }
            if (!/^(document|window|parent)$/.test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = $(ce).css("overflow") !== "hidden";
                this.containment = [ co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top ];
            }
        },
        _convertPositionTo: function(d, pos) {
            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return {
                top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
            };
        },
        _generatePosition: function(event) {
            var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            if (this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
                this.offset.relative = this._getRelativeOffset();
            }
            if (this.originalPosition) {
                if (this.containment) {
                    if (event.pageX - this.offset.click.left < this.containment[0]) {
                        pageX = this.containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < this.containment[1]) {
                        pageY = this.containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > this.containment[2]) {
                        pageX = this.containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > this.containment[3]) {
                        pageY = this.containment[3] + this.offset.click.top;
                    }
                }
                if (o.grid) {
                    top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                    pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
                    left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                    pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
                }
            }
            return {
                top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
            };
        },
        _rearrange: function(event, i, a, hardRefresh) {
            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === "down" ? i.item[0] : i.item[0].nextSibling);
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;
            this._delay(function() {
                if (counter === this.counter) {
                    this.refreshPositions(!hardRefresh);
                }
            });
        },
        _clear: function(event, noPropagation) {
            this.reverting = false;
            var i, delayedTriggers = [];
            if (!this._noFinalSort && this.currentItem.parent().length) {
                this.placeholder.before(this.currentItem);
            }
            this._noFinalSort = null;
            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) {
                    if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                        this._storedCSS[i] = "";
                    }
                }
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else {
                this.currentItem.show();
            }
            if (this.fromOutside && !noPropagation) {
                delayedTriggers.push(function(event) {
                    this._trigger("receive", event, this._uiHash(this.fromOutside));
                });
            }
            if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                delayedTriggers.push(function(event) {
                    this._trigger("update", event, this._uiHash());
                });
            }
            if (this !== this.currentContainer) {
                if (!noPropagation) {
                    delayedTriggers.push(function(event) {
                        this._trigger("remove", event, this._uiHash());
                    });
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("receive", event, this._uiHash(this));
                        };
                    }.call(this, this.currentContainer));
                    delayedTriggers.push(function(c) {
                        return function(event) {
                            c._trigger("update", event, this._uiHash(this));
                        };
                    }.call(this, this.currentContainer));
                }
            }
            function delayEvent(type, instance, container) {
                return function(event) {
                    container._trigger(type, event, instance._uiHash(instance));
                };
            }
            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) {
                    delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
                }
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push(delayEvent("out", this, this.containers[i]));
                    this.containers[i].containerCache.over = 0;
                }
            }
            if (this.storedCursor) {
                this.document.find("body").css("cursor", this.storedCursor);
                this.storedStylesheet.remove();
            }
            if (this._storedOpacity) {
                this.helper.css("opacity", this._storedOpacity);
            }
            if (this._storedZIndex) {
                this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
            }
            this.dragging = false;
            if (!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
            }
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
            if (!this.cancelHelperRemoval) {
                if (this.helper[0] !== this.currentItem[0]) {
                    this.helper.remove();
                }
                this.helper = null;
            }
            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) {
                    delayedTriggers[i].call(this, event);
                }
                this._trigger("stop", event, this._uiHash());
            }
            this.fromOutside = false;
            return !this.cancelHelperRemoval;
        },
        _trigger: function() {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                this.cancel();
            }
        },
        _uiHash: function(_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }
    });
    function spinner_modifier(fn) {
        return function() {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) {
                this._trigger("change");
            }
        };
    }
    var spinner = $.widget("ui.spinner", {
        version: "1.11.4",
        defaultElement: "<input>",
        widgetEventPrefix: "spin",
        options: {
            culture: null,
            icons: {
                down: "ui-icon-triangle-1-s",
                up: "ui-icon-triangle-1-n"
            },
            incremental: true,
            max: null,
            min: null,
            numberFormat: null,
            page: 10,
            step: 1,
            change: null,
            spin: null,
            start: null,
            stop: null
        },
        _create: function() {
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);
            if (this.value() !== "") {
                this._value(this.element.val(), true);
            }
            this._draw();
            this._on(this._events);
            this._refresh();
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },
        _getCreateOptions: function() {
            var options = {}, element = this.element;
            $.each([ "min", "max", "step" ], function(i, option) {
                var value = element.attr(option);
                if (value !== undefined && value.length) {
                    options[option] = value;
                }
            });
            return options;
        },
        _events: {
            keydown: function(event) {
                if (this._start(event) && this._keydown(event)) {
                    event.preventDefault();
                }
            },
            keyup: "_stop",
            focus: function() {
                this.previous = this.element.val();
            },
            blur: function(event) {
                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return;
                }
                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) {
                    this._trigger("change", event);
                }
            },
            mousewheel: function(event, delta) {
                if (!delta) {
                    return;
                }
                if (!this.spinning && !this._start(event)) {
                    return false;
                }
                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function() {
                    if (this.spinning) {
                        this._stop(event);
                    }
                }, 100);
                event.preventDefault();
            },
            "mousedown .ui-spinner-button": function(event) {
                var previous;
                previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
                function checkFocus() {
                    var isActive = this.element[0] === this.document[0].activeElement;
                    if (!isActive) {
                        this.element.focus();
                        this.previous = previous;
                        this._delay(function() {
                            this.previous = previous;
                        });
                    }
                }
                event.preventDefault();
                checkFocus.call(this);
                this.cancelBlur = true;
                this._delay(function() {
                    delete this.cancelBlur;
                    checkFocus.call(this);
                });
                if (this._start(event) === false) {
                    return;
                }
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseup .ui-spinner-button": "_stop",
            "mouseenter .ui-spinner-button": function(event) {
                if (!$(event.currentTarget).hasClass("ui-state-active")) {
                    return;
                }
                if (this._start(event) === false) {
                    return false;
                }
                this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
            },
            "mouseleave .ui-spinner-button": "_stop"
        },
        _draw: function() {
            var uiSpinner = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
            this.element.attr("role", "spinbutton");
            this.buttons = uiSpinner.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all");
            if (this.buttons.height() > Math.ceil(uiSpinner.height() * .5) && uiSpinner.height() > 0) {
                uiSpinner.height(uiSpinner.height());
            }
            if (this.options.disabled) {
                this.disable();
            }
        },
        _keydown: function(event) {
            var options = this.options, keyCode = $.ui.keyCode;
            switch (event.keyCode) {
              case keyCode.UP:
                this._repeat(null, 1, event);
                return true;

              case keyCode.DOWN:
                this._repeat(null, -1, event);
                return true;

              case keyCode.PAGE_UP:
                this._repeat(null, options.page, event);
                return true;

              case keyCode.PAGE_DOWN:
                this._repeat(null, -options.page, event);
                return true;
            }
            return false;
        },
        _uiSpinnerHtml: function() {
            return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
        },
        _buttonHtml: function() {
            return "" + "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" + "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" + "</a>" + "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" + "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" + "</a>";
        },
        _start: function(event) {
            if (!this.spinning && this._trigger("start", event) === false) {
                return false;
            }
            if (!this.counter) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },
        _repeat: function(i, steps, event) {
            i = i || 500;
            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                this._repeat(40, steps, event);
            }, i);
            this._spin(steps * this.options.step, event);
        },
        _spin: function(step, event) {
            var value = this.value() || 0;
            if (!this.counter) {
                this.counter = 1;
            }
            value = this._adjustValue(value + step * this._increment(this.counter));
            if (!this.spinning || this._trigger("spin", event, {
                value: value
            }) !== false) {
                this._value(value);
                this.counter++;
            }
        },
        _increment: function(i) {
            var incremental = this.options.incremental;
            if (incremental) {
                return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 5e4 - i * i / 500 + 17 * i / 200 + 1);
            }
            return 1;
        },
        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },
        _precisionOf: function(num) {
            var str = num.toString(), decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },
        _adjustValue: function(value) {
            var base, aboveMin, options = this.options;
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;
            aboveMin = Math.round(aboveMin / options.step) * options.step;
            value = base + aboveMin;
            value = parseFloat(value.toFixed(this._precision()));
            if (options.max !== null && value > options.max) {
                return options.max;
            }
            if (options.min !== null && value < options.min) {
                return options.min;
            }
            return value;
        },
        _stop: function(event) {
            if (!this.spinning) {
                return;
            }
            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event);
        },
        _setOption: function(key, value) {
            if (key === "culture" || key === "numberFormat") {
                var prevValue = this._parse(this.element.val());
                this.options[key] = value;
                this.element.val(this._format(prevValue));
                return;
            }
            if (key === "max" || key === "min" || key === "step") {
                if (typeof value === "string") {
                    value = this._parse(value);
                }
            }
            if (key === "icons") {
                this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(value.up);
                this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(value.down);
            }
            this._super(key, value);
            if (key === "disabled") {
                this.widget().toggleClass("ui-state-disabled", !!value);
                this.element.prop("disabled", !!value);
                this.buttons.button(value ? "disable" : "enable");
            }
        },
        _setOptions: spinner_modifier(function(options) {
            this._super(options);
        }),
        _parse: function(val) {
            if (typeof val === "string" && val !== "") {
                val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
            }
            return val === "" || isNaN(val) ? null : val;
        },
        _format: function(value) {
            if (value === "") {
                return "";
            }
            return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
        },
        _refresh: function() {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                "aria-valuenow": this._parse(this.element.val())
            });
        },
        isValid: function() {
            var value = this.value();
            if (value === null) {
                return false;
            }
            return value === this._adjustValue(value);
        },
        _value: function(value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) {
                        parsed = this._adjustValue(parsed);
                    }
                    value = this._format(parsed);
                }
            }
            this.element.val(value);
            this._refresh();
        },
        _destroy: function() {
            this.element.removeClass("ui-spinner-input").prop("disabled", false).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
            this.uiSpinner.replaceWith(this.element);
        },
        stepUp: spinner_modifier(function(steps) {
            this._stepUp(steps);
        }),
        _stepUp: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop();
            }
        },
        stepDown: spinner_modifier(function(steps) {
            this._stepDown(steps);
        }),
        _stepDown: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop();
            }
        },
        pageUp: spinner_modifier(function(pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),
        pageDown: spinner_modifier(function(pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),
        value: function(newVal) {
            if (!arguments.length) {
                return this._parse(this.element.val());
            }
            spinner_modifier(this._value).call(this, newVal);
        },
        widget: function() {
            return this.uiSpinner;
        }
    });
    var tabs = $.widget("ui.tabs", {
        version: "1.11.4",
        delay: 300,
        options: {
            active: null,
            collapsible: false,
            event: "click",
            heightStyle: "content",
            hide: null,
            show: null,
            activate: null,
            beforeActivate: null,
            beforeLoad: null,
            load: null
        },
        _isLocal: function() {
            var rhash = /#.*$/;
            return function(anchor) {
                var anchorUrl, locationUrl;
                anchor = anchor.cloneNode(false);
                anchorUrl = anchor.href.replace(rhash, "");
                locationUrl = location.href.replace(rhash, "");
                try {
                    anchorUrl = decodeURIComponent(anchorUrl);
                } catch (error) {}
                try {
                    locationUrl = decodeURIComponent(locationUrl);
                } catch (error) {}
                return anchor.hash.length > 1 && anchorUrl === locationUrl;
            };
        }(),
        _create: function() {
            var that = this, options = this.options;
            this.running = false;
            this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", options.collapsible);
            this._processTabs();
            options.active = this._initialActive();
            if ($.isArray(options.disabled)) {
                options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                    return that.tabs.index(li);
                }))).sort();
            }
            if (this.options.active !== false && this.anchors.length) {
                this.active = this._findActive(options.active);
            } else {
                this.active = $();
            }
            this._refresh();
            if (this.active.length) {
                this.load(options.active);
            }
        },
        _initialActive: function() {
            var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
            if (active === null) {
                if (locationHash) {
                    this.tabs.each(function(i, tab) {
                        if ($(tab).attr("aria-controls") === locationHash) {
                            active = i;
                            return false;
                        }
                    });
                }
                if (active === null) {
                    active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                }
                if (active === null || active === -1) {
                    active = this.tabs.length ? 0 : false;
                }
            }
            if (active !== false) {
                active = this.tabs.index(this.tabs.eq(active));
                if (active === -1) {
                    active = collapsible ? false : 0;
                }
            }
            if (!collapsible && active === false && this.anchors.length) {
                active = 0;
            }
            return active;
        },
        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: !this.active.length ? $() : this._getPanelForTab(this.active)
            };
        },
        _tabKeydown: function(event) {
            var focusedTab = $(this.document[0].activeElement).closest("li"), selectedIndex = this.tabs.index(focusedTab), goingForward = true;
            if (this._handlePageNav(event)) {
                return;
            }
            switch (event.keyCode) {
              case $.ui.keyCode.RIGHT:
              case $.ui.keyCode.DOWN:
                selectedIndex++;
                break;

              case $.ui.keyCode.UP:
              case $.ui.keyCode.LEFT:
                goingForward = false;
                selectedIndex--;
                break;

              case $.ui.keyCode.END:
                selectedIndex = this.anchors.length - 1;
                break;

              case $.ui.keyCode.HOME:
                selectedIndex = 0;
                break;

              case $.ui.keyCode.SPACE:
                event.preventDefault();
                clearTimeout(this.activating);
                this._activate(selectedIndex);
                return;

              case $.ui.keyCode.ENTER:
                event.preventDefault();
                clearTimeout(this.activating);
                this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                return;

              default:
                return;
            }
            event.preventDefault();
            clearTimeout(this.activating);
            selectedIndex = this._focusNextTab(selectedIndex, goingForward);
            if (!event.ctrlKey && !event.metaKey) {
                focusedTab.attr("aria-selected", "false");
                this.tabs.eq(selectedIndex).attr("aria-selected", "true");
                this.activating = this._delay(function() {
                    this.option("active", selectedIndex);
                }, this.delay);
            }
        },
        _panelKeydown: function(event) {
            if (this._handlePageNav(event)) {
                return;
            }
            if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                event.preventDefault();
                this.active.focus();
            }
        },
        _handlePageNav: function(event) {
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                this._activate(this._focusNextTab(this.options.active - 1, false));
                return true;
            }
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                this._activate(this._focusNextTab(this.options.active + 1, true));
                return true;
            }
        },
        _findNextTab: function(index, goingForward) {
            var lastTabIndex = this.tabs.length - 1;
            function constrain() {
                if (index > lastTabIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastTabIndex;
                }
                return index;
            }
            while ($.inArray(constrain(), this.options.disabled) !== -1) {
                index = goingForward ? index + 1 : index - 1;
            }
            return index;
        },
        _focusNextTab: function(index, goingForward) {
            index = this._findNextTab(index, goingForward);
            this.tabs.eq(index).focus();
            return index;
        },
        _setOption: function(key, value) {
            if (key === "active") {
                this._activate(value);
                return;
            }
            if (key === "disabled") {
                this._setupDisabled(value);
                return;
            }
            this._super(key, value);
            if (key === "collapsible") {
                this.element.toggleClass("ui-tabs-collapsible", value);
                if (!value && this.options.active === false) {
                    this._activate(0);
                }
            }
            if (key === "event") {
                this._setupEvents(value);
            }
            if (key === "heightStyle") {
                this._setupHeightStyle(value);
            }
        },
        _sanitizeSelector: function(hash) {
            return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },
        refresh: function() {
            var options = this.options, lis = this.tablist.children(":has(a[href])");
            options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                return lis.index(tab);
            });
            this._processTabs();
            if (options.active === false || !this.anchors.length) {
                options.active = false;
                this.active = $();
            } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                if (this.tabs.length === options.disabled.length) {
                    options.active = false;
                    this.active = $();
                } else {
                    this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                }
            } else {
                options.active = this.tabs.index(this.active);
            }
            this._refresh();
        },
        _refresh: function() {
            this._setupDisabled(this.options.disabled);
            this._setupEvents(this.options.event);
            this._setupHeightStyle(this.options.heightStyle);
            this.tabs.not(this.active).attr({
                "aria-selected": "false",
                "aria-expanded": "false",
                tabIndex: -1
            });
            this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                "aria-hidden": "true"
            });
            if (!this.active.length) {
                this.tabs.eq(0).attr("tabIndex", 0);
            } else {
                this.active.addClass("ui-tabs-active ui-state-active").attr({
                    "aria-selected": "true",
                    "aria-expanded": "true",
                    tabIndex: 0
                });
                this._getPanelForTab(this.active).show().attr({
                    "aria-hidden": "false"
                });
            }
        },
        _processTabs: function() {
            var that = this, prevTabs = this.tabs, prevAnchors = this.anchors, prevPanels = this.panels;
            this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist").delegate("> li", "mousedown" + this.eventNamespace, function(event) {
                if ($(this).is(".ui-state-disabled")) {
                    event.preventDefault();
                }
            }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                if ($(this).closest("li").is(".ui-state-disabled")) {
                    this.blur();
                }
            });
            this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                role: "tab",
                tabIndex: -1
            });
            this.anchors = this.tabs.map(function() {
                return $("a", this)[0];
            }).addClass("ui-tabs-anchor").attr({
                role: "presentation",
                tabIndex: -1
            });
            this.panels = $();
            this.anchors.each(function(i, anchor) {
                var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr("id"), tab = $(anchor).closest("li"), originalAriaControls = tab.attr("aria-controls");
                if (that._isLocal(anchor)) {
                    selector = anchor.hash;
                    panelId = selector.substring(1);
                    panel = that.element.find(that._sanitizeSelector(selector));
                } else {
                    panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id;
                    selector = "#" + panelId;
                    panel = that.element.find(selector);
                    if (!panel.length) {
                        panel = that._createPanel(panelId);
                        panel.insertAfter(that.panels[i - 1] || that.tablist);
                    }
                    panel.attr("aria-live", "polite");
                }
                if (panel.length) {
                    that.panels = that.panels.add(panel);
                }
                if (originalAriaControls) {
                    tab.data("ui-tabs-aria-controls", originalAriaControls);
                }
                tab.attr({
                    "aria-controls": panelId,
                    "aria-labelledby": anchorId
                });
                panel.attr("aria-labelledby", anchorId);
            });
            this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel");
            if (prevTabs) {
                this._off(prevTabs.not(this.tabs));
                this._off(prevAnchors.not(this.anchors));
                this._off(prevPanels.not(this.panels));
            }
        },
        _getList: function() {
            return this.tablist || this.element.find("ol,ul").eq(0);
        },
        _createPanel: function(id) {
            return $("<div>").attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", true);
        },
        _setupDisabled: function(disabled) {
            if ($.isArray(disabled)) {
                if (!disabled.length) {
                    disabled = false;
                } else if (disabled.length === this.anchors.length) {
                    disabled = true;
                }
            }
            for (var i = 0, li; li = this.tabs[i]; i++) {
                if (disabled === true || $.inArray(i, disabled) !== -1) {
                    $(li).addClass("ui-state-disabled").attr("aria-disabled", "true");
                } else {
                    $(li).removeClass("ui-state-disabled").removeAttr("aria-disabled");
                }
            }
            this.options.disabled = disabled;
        },
        _setupEvents: function(event) {
            var events = {};
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }
            this._off(this.anchors.add(this.tabs).add(this.panels));
            this._on(true, this.anchors, {
                click: function(event) {
                    event.preventDefault();
                }
            });
            this._on(this.anchors, events);
            this._on(this.tabs, {
                keydown: "_tabKeydown"
            });
            this._on(this.panels, {
                keydown: "_panelKeydown"
            });
            this._focusable(this.tabs);
            this._hoverable(this.tabs);
        },
        _setupHeightStyle: function(heightStyle) {
            var maxHeight, parent = this.element.parent();
            if (heightStyle === "fill") {
                maxHeight = parent.height();
                maxHeight -= this.element.outerHeight() - this.element.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this), position = elem.css("position");
                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });
                this.element.children().not(this.panels).each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });
                this.panels.each(function() {
                    $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
                }).css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.panels.each(function() {
                    maxHeight = Math.max(maxHeight, $(this).height("").height());
                }).height(maxHeight);
            }
        },
        _eventHandler: function(event) {
            var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest("li"), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = !active.length ? $() : this._getPanelForTab(active), eventData = {
                oldTab: active,
                oldPanel: toHide,
                newTab: collapsing ? $() : tab,
                newPanel: toShow
            };
            event.preventDefault();
            if (tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === false) {
                return;
            }
            options.active = collapsing ? false : this.tabs.index(tab);
            this.active = clickedIsActive ? $() : tab;
            if (this.xhr) {
                this.xhr.abort();
            }
            if (!toHide.length && !toShow.length) {
                $.error("jQuery UI Tabs: Mismatching fragment identifier.");
            }
            if (toShow.length) {
                this.load(this.tabs.index(tab), event);
            }
            this._toggle(event, eventData);
        },
        _toggle: function(event, eventData) {
            var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
            this.running = true;
            function complete() {
                that.running = false;
                that._trigger("activate", event, eventData);
            }
            function show() {
                eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");
                if (toShow.length && that.options.show) {
                    that._show(toShow, that.options.show, complete);
                } else {
                    toShow.show();
                    complete();
                }
            }
            if (toHide.length && this.options.hide) {
                this._hide(toHide, this.options.hide, function() {
                    eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                    show();
                });
            } else {
                eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                toHide.hide();
                show();
            }
            toHide.attr("aria-hidden", "true");
            eventData.oldTab.attr({
                "aria-selected": "false",
                "aria-expanded": "false"
            });
            if (toShow.length && toHide.length) {
                eventData.oldTab.attr("tabIndex", -1);
            } else if (toShow.length) {
                this.tabs.filter(function() {
                    return $(this).attr("tabIndex") === 0;
                }).attr("tabIndex", -1);
            }
            toShow.attr("aria-hidden", "false");
            eventData.newTab.attr({
                "aria-selected": "true",
                "aria-expanded": "true",
                tabIndex: 0
            });
        },
        _activate: function(index) {
            var anchor, active = this._findActive(index);
            if (active[0] === this.active[0]) {
                return;
            }
            if (!active.length) {
                active = this.active;
            }
            anchor = active.find(".ui-tabs-anchor")[0];
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            });
        },
        _findActive: function(index) {
            return index === false ? $() : this.tabs.eq(index);
        },
        _getIndex: function(index) {
            if (typeof index === "string") {
                index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
            }
            return index;
        },
        _destroy: function() {
            if (this.xhr) {
                this.xhr.abort();
            }
            this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");
            this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role");
            this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId();
            this.tablist.unbind(this.eventNamespace);
            this.tabs.add(this.panels).each(function() {
                if ($.data(this, "ui-tabs-destroy")) {
                    $(this).remove();
                } else {
                    $(this).removeClass("ui-state-default ui-state-active ui-state-disabled " + "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
                }
            });
            this.tabs.each(function() {
                var li = $(this), prev = li.data("ui-tabs-aria-controls");
                if (prev) {
                    li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls");
                } else {
                    li.removeAttr("aria-controls");
                }
            });
            this.panels.show();
            if (this.options.heightStyle !== "content") {
                this.panels.css("height", "");
            }
        },
        enable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === false) {
                return;
            }
            if (index === undefined) {
                disabled = false;
            } else {
                index = this._getIndex(index);
                if ($.isArray(disabled)) {
                    disabled = $.map(disabled, function(num) {
                        return num !== index ? num : null;
                    });
                } else {
                    disabled = $.map(this.tabs, function(li, num) {
                        return num !== index ? num : null;
                    });
                }
            }
            this._setupDisabled(disabled);
        },
        disable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === true) {
                return;
            }
            if (index === undefined) {
                disabled = true;
            } else {
                index = this._getIndex(index);
                if ($.inArray(index, disabled) !== -1) {
                    return;
                }
                if ($.isArray(disabled)) {
                    disabled = $.merge([ index ], disabled).sort();
                } else {
                    disabled = [ index ];
                }
            }
            this._setupDisabled(disabled);
        },
        load: function(index, event) {
            index = this._getIndex(index);
            var that = this, tab = this.tabs.eq(index), anchor = tab.find(".ui-tabs-anchor"), panel = this._getPanelForTab(tab), eventData = {
                tab: tab,
                panel: panel
            }, complete = function(jqXHR, status) {
                if (status === "abort") {
                    that.panels.stop(false, true);
                }
                tab.removeClass("ui-tabs-loading");
                panel.removeAttr("aria-busy");
                if (jqXHR === that.xhr) {
                    delete that.xhr;
                }
            };
            if (this._isLocal(anchor[0])) {
                return;
            }
            this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
            if (this.xhr && this.xhr.statusText !== "canceled") {
                tab.addClass("ui-tabs-loading");
                panel.attr("aria-busy", "true");
                this.xhr.done(function(response, status, jqXHR) {
                    setTimeout(function() {
                        panel.html(response);
                        that._trigger("load", event, eventData);
                        complete(jqXHR, status);
                    }, 1);
                }).fail(function(jqXHR, status) {
                    setTimeout(function() {
                        complete(jqXHR, status);
                    }, 1);
                });
            }
        },
        _ajaxSettings: function(anchor, event, eventData) {
            var that = this;
            return {
                url: anchor.attr("href"),
                beforeSend: function(jqXHR, settings) {
                    return that._trigger("beforeLoad", event, $.extend({
                        jqXHR: jqXHR,
                        ajaxSettings: settings
                    }, eventData));
                }
            };
        },
        _getPanelForTab: function(tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        }
    });
    var tooltip = $.widget("ui.tooltip", {
        version: "1.11.4",
        options: {
            content: function() {
                var title = $(this).attr("title") || "";
                return $("<a>").text(title).html();
            },
            hide: true,
            items: "[title]:not([disabled])",
            position: {
                my: "left top+15",
                at: "left bottom",
                collision: "flipfit flip"
            },
            show: true,
            tooltipClass: null,
            track: false,
            close: null,
            open: null
        },
        _addDescribedBy: function(elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
            describedby.push(id);
            elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
        },
        _removeDescribedBy: function(elem) {
            var id = elem.data("ui-tooltip-id"), describedby = (elem.attr("aria-describedby") || "").split(/\s+/), index = $.inArray(id, describedby);
            if (index !== -1) {
                describedby.splice(index, 1);
            }
            elem.removeData("ui-tooltip-id");
            describedby = $.trim(describedby.join(" "));
            if (describedby) {
                elem.attr("aria-describedby", describedby);
            } else {
                elem.removeAttr("aria-describedby");
            }
        },
        _create: function() {
            this._on({
                mouseover: "open",
                focusin: "open"
            });
            this.tooltips = {};
            this.parents = {};
            if (this.options.disabled) {
                this._disable();
            }
            this.liveRegion = $("<div>").attr({
                role: "log",
                "aria-live": "assertive",
                "aria-relevant": "additions"
            }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body);
        },
        _setOption: function(key, value) {
            var that = this;
            if (key === "disabled") {
                this[value ? "_disable" : "_enable"]();
                this.options[key] = value;
                return;
            }
            this._super(key, value);
            if (key === "content") {
                $.each(this.tooltips, function(id, tooltipData) {
                    that._updateContent(tooltipData.element);
                });
            }
        },
        _disable: function() {
            var that = this;
            $.each(this.tooltips, function(id, tooltipData) {
                var event = $.Event("blur");
                event.target = event.currentTarget = tooltipData.element[0];
                that.close(event, true);
            });
            this.element.find(this.options.items).addBack().each(function() {
                var element = $(this);
                if (element.is("[title]")) {
                    element.data("ui-tooltip-title", element.attr("title")).removeAttr("title");
                }
            });
        },
        _enable: function() {
            this.element.find(this.options.items).addBack().each(function() {
                var element = $(this);
                if (element.data("ui-tooltip-title")) {
                    element.attr("title", element.data("ui-tooltip-title"));
                }
            });
        },
        open: function(event) {
            var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
            if (!target.length || target.data("ui-tooltip-id")) {
                return;
            }
            if (target.attr("title")) {
                target.data("ui-tooltip-title", target.attr("title"));
            }
            target.data("ui-tooltip-open", true);
            if (event && event.type === "mouseover") {
                target.parents().each(function() {
                    var parent = $(this), blurEvent;
                    if (parent.data("ui-tooltip-open")) {
                        blurEvent = $.Event("blur");
                        blurEvent.target = blurEvent.currentTarget = this;
                        that.close(blurEvent, true);
                    }
                    if (parent.attr("title")) {
                        parent.uniqueId();
                        that.parents[this.id] = {
                            element: this,
                            title: parent.attr("title")
                        };
                        parent.attr("title", "");
                    }
                });
            }
            this._registerCloseHandlers(event, target);
            this._updateContent(target, event);
        },
        _updateContent: function(target, event) {
            var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
            if (typeof contentOption === "string") {
                return this._open(event, target, contentOption);
            }
            content = contentOption.call(target[0], function(response) {
                that._delay(function() {
                    if (!target.data("ui-tooltip-open")) {
                        return;
                    }
                    if (event) {
                        event.type = eventType;
                    }
                    this._open(event, target, response);
                });
            });
            if (content) {
                this._open(event, target, content);
            }
        },
        _open: function(event, target, content) {
            var tooltipData, tooltip, delayedShow, a11yContent, positionOption = $.extend({}, this.options.position);
            if (!content) {
                return;
            }
            tooltipData = this._find(target);
            if (tooltipData) {
                tooltipData.tooltip.find(".ui-tooltip-content").html(content);
                return;
            }
            if (target.is("[title]")) {
                if (event && event.type === "mouseover") {
                    target.attr("title", "");
                } else {
                    target.removeAttr("title");
                }
            }
            tooltipData = this._tooltip(target);
            tooltip = tooltipData.tooltip;
            this._addDescribedBy(target, tooltip.attr("id"));
            tooltip.find(".ui-tooltip-content").html(content);
            this.liveRegion.children().hide();
            if (content.clone) {
                a11yContent = content.clone();
                a11yContent.removeAttr("id").find("[id]").removeAttr("id");
            } else {
                a11yContent = content;
            }
            $("<div>").html(a11yContent).appendTo(this.liveRegion);
            function position(event) {
                positionOption.of = event;
                if (tooltip.is(":hidden")) {
                    return;
                }
                tooltip.position(positionOption);
            }
            if (this.options.track && event && /^mouse/.test(event.type)) {
                this._on(this.document, {
                    mousemove: position
                });
                position(event);
            } else {
                tooltip.position($.extend({
                    of: target
                }, this.options.position));
            }
            tooltip.hide();
            this._show(tooltip, this.options.show);
            if (this.options.show && this.options.show.delay) {
                delayedShow = this.delayedShow = setInterval(function() {
                    if (tooltip.is(":visible")) {
                        position(positionOption.of);
                        clearInterval(delayedShow);
                    }
                }, $.fx.interval);
            }
            this._trigger("open", event, {
                tooltip: tooltip
            });
        },
        _registerCloseHandlers: function(event, target) {
            var events = {
                keyup: function(event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE) {
                        var fakeEvent = $.Event(event);
                        fakeEvent.currentTarget = target[0];
                        this.close(fakeEvent, true);
                    }
                }
            };
            if (target[0] !== this.element[0]) {
                events.remove = function() {
                    this._removeTooltip(this._find(target).tooltip);
                };
            }
            if (!event || event.type === "mouseover") {
                events.mouseleave = "close";
            }
            if (!event || event.type === "focusin") {
                events.focusout = "close";
            }
            this._on(true, target, events);
        },
        close: function(event) {
            var tooltip, that = this, target = $(event ? event.currentTarget : this.element), tooltipData = this._find(target);
            if (!tooltipData) {
                target.removeData("ui-tooltip-open");
                return;
            }
            tooltip = tooltipData.tooltip;
            if (tooltipData.closing) {
                return;
            }
            clearInterval(this.delayedShow);
            if (target.data("ui-tooltip-title") && !target.attr("title")) {
                target.attr("title", target.data("ui-tooltip-title"));
            }
            this._removeDescribedBy(target);
            tooltipData.hiding = true;
            tooltip.stop(true);
            this._hide(tooltip, this.options.hide, function() {
                that._removeTooltip($(this));
            });
            target.removeData("ui-tooltip-open");
            this._off(target, "mouseleave focusout keyup");
            if (target[0] !== this.element[0]) {
                this._off(target, "remove");
            }
            this._off(this.document, "mousemove");
            if (event && event.type === "mouseleave") {
                $.each(this.parents, function(id, parent) {
                    $(parent.element).attr("title", parent.title);
                    delete that.parents[id];
                });
            }
            tooltipData.closing = true;
            this._trigger("close", event, {
                tooltip: tooltip
            });
            if (!tooltipData.hiding) {
                tooltipData.closing = false;
            }
        },
        _tooltip: function(element) {
            var tooltip = $("<div>").attr("role", "tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || "")), id = tooltip.uniqueId().attr("id");
            $("<div>").addClass("ui-tooltip-content").appendTo(tooltip);
            tooltip.appendTo(this.document[0].body);
            return this.tooltips[id] = {
                element: element,
                tooltip: tooltip
            };
        },
        _find: function(target) {
            var id = target.data("ui-tooltip-id");
            return id ? this.tooltips[id] : null;
        },
        _removeTooltip: function(tooltip) {
            tooltip.remove();
            delete this.tooltips[tooltip.attr("id")];
        },
        _destroy: function() {
            var that = this;
            $.each(this.tooltips, function(id, tooltipData) {
                var event = $.Event("blur"), element = tooltipData.element;
                event.target = event.currentTarget = element[0];
                that.close(event, true);
                $("#" + id).remove();
                if (element.data("ui-tooltip-title")) {
                    if (!element.attr("title")) {
                        element.attr("title", element.data("ui-tooltip-title"));
                    }
                    element.removeData("ui-tooltip-title");
                }
            });
            this.liveRegion.remove();
        }
    });
});

(function($) {
    $.fn.colorPicker = function() {
        if (this.length > 0) buildSelector();
        return this.each(function(i) {
            buildPicker(this);
        });
    };
    var selectorOwner;
    var selectorShowing = false;
    buildPicker = function(element) {
        control = $("<div class='color_picker'>&nbsp;</div>");
        control.css("background-color", $(element).val());
        control.bind("click", toggleSelector);
        $(element).after(control);
        $(element).bind("change", function() {
            selectedValue = toHex($(element).val());
            $(element).next(".color_picker").css("background-color", selectedValue);
        });
        $(element).hide();
    };
    buildSelector = function() {
        selector = $("<div id='color_selector'></div>");
        $.each($.fn.colorPicker.defaultColors, function(i) {
            swatch = $("<div class='color_swatch'>&nbsp;</div>");
            swatch.css("background-color", "#" + this);
            swatch.bind("click", function(e) {
                changeColor($(this).css("background-color"));
            });
            swatch.bind("mouseover", function(e) {
                $(this).css("border-color", "#598FEF");
                $("input#color_value").val(toHex($(this).css("background-color")));
            });
            swatch.bind("mouseout", function(e) {
                $(this).css("border-color", "#000");
                $("input#color_value").val(toHex($(selectorOwner).css("background-color")));
            });
            swatch.appendTo(selector);
        });
        hex_field = $("<label for='color_value'>Hex</label><input type='text' size='8' id='color_value'/>");
        hex_field.bind("keydown", function(event) {
            if (event.keyCode == 13) {
                changeColor($(this).val());
            }
            if (event.keyCode == 27) {
                toggleSelector();
            }
        });
        $("<div id='color_custom'></div>").append(hex_field).appendTo(selector);
        $("body").append(selector);
        selector.hide();
    };
    checkMouse = function(event) {
        var selector = "div#color_selector";
        var selectorParent = $(event.target).parents(selector).length;
        if (event.target == $(selector)[0] || event.target == selectorOwner || selectorParent > 0) return;
        hideSelector();
    };
    hideSelector = function() {
        var selector = $("div#color_selector");
        $(document).unbind("mousedown", checkMouse);
        selector.hide();
        selectorShowing = false;
    };
    showSelector = function() {
        var selector = $("div#color_selector");
        selector.css({
            top: $(selectorOwner).offset().top + $(selectorOwner).outerHeight(),
            left: $(selectorOwner).offset().left
        });
        hexColor = $(selectorOwner).prev("input").val();
        $("input#color_value").val(hexColor);
        selector.show();
        $(document).bind("mousedown", checkMouse);
        selectorShowing = true;
    };
    toggleSelector = function(event) {
        selectorOwner = this;
        selectorShowing ? hideSelector() : showSelector();
    };
    changeColor = function(value) {
        if (selectedValue = toHex(value)) {
            $(selectorOwner).css("background-color", selectedValue);
            $(selectorOwner).prev("input").val(selectedValue).change();
            hideSelector();
        }
    };
    toHex = function(color) {
        if (color.match(/[0-9a-fA-F]{3}$/) || color.match(/[0-9a-fA-F]{6}$/)) {
            color = color.charAt(0) == "#" ? color : "#" + color;
        } else if (color.match(/^rgb\(([0-9]|[1-9][0-9]|[1][0-9]{2}|[2][0-4][0-9]|[2][5][0-5]),[ ]{0,1}([0-9]|[1-9][0-9]|[1][0-9]{2}|[2][0-4][0-9]|[2][5][0-5]),[ ]{0,1}([0-9]|[1-9][0-9]|[1][0-9]{2}|[2][0-4][0-9]|[2][5][0-5])\)$/)) {
            var c = [ parseInt(RegExp.$1), parseInt(RegExp.$2), parseInt(RegExp.$3) ];
            var pad = function(str) {
                if (str.length < 2) {
                    for (var i = 0, len = 2 - str.length; i < len; i++) {
                        str = "0" + str;
                    }
                }
                return str;
            };
            if (c.length == 3) {
                var r = pad(c[0].toString(16)), g = pad(c[1].toString(16)), b = pad(c[2].toString(16));
                color = "#" + r + g + b;
            }
        } else color = false;
        return color;
    };
    $.fn.colorPicker.addColors = function(colorArray) {
        $.fn.colorPicker.defaultColors = $.fn.colorPicker.defaultColors.concat(colorArray);
    };
    $.fn.colorPicker.defaultColors = [ "000000", "993300", "333300", "000080", "333399", "333333", "800000", "FF6600", "808000", "008000", "008080", "0000FF", "666699", "808080", "FF0000", "FF9900", "99CC00", "339966", "33CCCC", "3366FF", "800080", "999999", "FF00FF", "FFCC00", "FFFF00", "00FF00", "00FFFF", "00CCFF", "993366", "C0C0C0", "FF99CC", "FFCC99", "FFFF99", "CCFFFF", "99CCFF", "FFFFFF" ];
})(jQuery);

(function($) {
    "use strict";
    var Freeow;
    Freeow = function(title, message, options) {
        var startStyle, i, u;
        this.options = $.extend({}, $.fn.freeow.defaults, options);
        this.element = $(this.options.template(title, message));
        if (this.options.startStyle) {
            startStyle = this.options.startStyle;
        } else {
            startStyle = this.options.hideStyle;
        }
        this.element.css(startStyle);
        this.element.data("freeow", this);
        for (i = 0, u = this.options.classes.length; i < u; i += 1) {
            this.element.addClass(this.options.classes[i]);
        }
        this.element.click(this.options.onClick);
        this.element.hover(this.options.onHover);
        this.autoHide = false;
    };
    Freeow.prototype = {
        attach: function(container) {
            $(container).prepend(this.element);
            this.show();
        },
        show: function() {
            var opts, self, fn, delay;
            opts = {
                duration: this.showDuration
            };
            if (this.options.autoHide && this.options.autoHideDelay > 0) {
                this.autoHide = true;
                self = this;
                delay = this.options.autoHideDelay;
                fn = function() {
                    if (self.autoHide) {
                        self.hide();
                    }
                };
                opts.complete = function() {
                    setTimeout(fn, delay);
                };
            }
            this.element.animate(this.options.showStyle, opts);
        },
        hide: function() {
            var self = this;
            this.element.animate(this.options.hideStyle, {
                duration: this.options.hideDuration,
                complete: function() {
                    self.destroy();
                }
            });
        },
        destroy: function() {
            this.element.data("freeow", undefined);
            this.element.remove();
        }
    };
    if (typeof $.fn.freeow === "undefined") {
        $.fn.extend({
            freeow: function(title, message, options) {
                return this.each(function() {
                    var f;
                    f = new Freeow(title, message, options);
                    f.attach(this);
                });
            }
        });
        $.fn.freeow.defaults = {
            autoHide: true,
            autoHideDelay: 3e3,
            classes: [],
            startStyle: null,
            showStyle: {
                opacity: 1
            },
            showDuration: 250,
            hideStyle: {
                opacity: 0
            },
            hideDuration: 500,
            onClick: function(event) {
                $(this).data("freeow").hide();
            },
            onHover: function(event) {
                $(this).data("freeow").autoHide = false;
            },
            template: function(title, message) {
                var e;
                e = [ "<div>", '<div class="background">', '<div class="content">', "<h2>" + title + "</h2>", "<p>" + message + "</p>", "</div>", "</div>", '<span class="icon"></span>', '<span class="close"></span>', "</div>" ].join("");
                return e;
            }
        };
    }
})(jQuery);

(function(window, document, undefined) {
    (function(factory) {
        "use strict";
        if (typeof define === "function" && define.amd) {
            define([ "jquery" ], factory);
        } else if (jQuery && !jQuery.fn.qtip) {
            factory(jQuery);
        }
    })(function($) {
        "use strict";
        var TRUE = true, FALSE = false, NULL = null, X = "x", Y = "y", WIDTH = "width", HEIGHT = "height", TOP = "top", LEFT = "left", BOTTOM = "bottom", RIGHT = "right", CENTER = "center", FLIP = "flip", FLIPINVERT = "flipinvert", SHIFT = "shift", QTIP, PROTOTYPE, CORNER, CHECKS, PLUGINS = {}, NAMESPACE = "qtip", ATTR_HAS = "data-hasqtip", ATTR_ID = "data-qtip-id", WIDGET = [ "ui-widget", "ui-tooltip" ], SELECTOR = "." + NAMESPACE, INACTIVE_EVENTS = "click dblclick mousedown mouseup mousemove mouseleave mouseenter".split(" "), CLASS_FIXED = NAMESPACE + "-fixed", CLASS_DEFAULT = NAMESPACE + "-default", CLASS_FOCUS = NAMESPACE + "-focus", CLASS_HOVER = NAMESPACE + "-hover", CLASS_DISABLED = NAMESPACE + "-disabled", replaceSuffix = "_replacedByqTip", oldtitle = "oldtitle", trackingBound, BROWSER = {
            ie: function() {
                for (var v = 4, i = document.createElement("div"); (i.innerHTML = "<!--[if gt IE " + v + "]><i></i><![endif]-->") && i.getElementsByTagName("i")[0]; v += 1) {}
                return v > 4 ? v : NaN;
            }(),
            iOS: parseFloat(("" + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [ 0, "" ])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) || FALSE
        };
        function QTip(target, options, id, attr) {
            this.id = id;
            this.target = target;
            this.tooltip = NULL;
            this.elements = {
                target: target
            };
            this._id = NAMESPACE + "-" + id;
            this.timers = {
                img: {}
            };
            this.options = options;
            this.plugins = {};
            this.cache = {
                event: {},
                target: $(),
                disabled: FALSE,
                attr: attr,
                onTooltip: FALSE,
                lastClass: ""
            };
            this.rendered = this.destroyed = this.disabled = this.waiting = this.hiddenDuringWait = this.positioning = this.triggering = FALSE;
        }
        PROTOTYPE = QTip.prototype;
        PROTOTYPE._when = function(deferreds) {
            return $.when.apply($, deferreds);
        };
        PROTOTYPE.render = function(show) {
            if (this.rendered || this.destroyed) {
                return this;
            }
            var self = this, options = this.options, cache = this.cache, elements = this.elements, text = options.content.text, title = options.content.title, button = options.content.button, posOptions = options.position, namespace = "." + this._id + " ", deferreds = [], tooltip;
            $.attr(this.target[0], "aria-describedby", this._id);
            cache.posClass = this._createPosClass((this.position = {
                my: posOptions.my,
                at: posOptions.at
            }).my);
            this.tooltip = elements.tooltip = tooltip = $("<div/>", {
                id: this._id,
                class: [ NAMESPACE, CLASS_DEFAULT, options.style.classes, cache.posClass ].join(" "),
                width: options.style.width || "",
                height: options.style.height || "",
                tracking: posOptions.target === "mouse" && posOptions.adjust.mouse,
                role: "alert",
                "aria-live": "polite",
                "aria-atomic": FALSE,
                "aria-describedby": this._id + "-content",
                "aria-hidden": TRUE
            }).toggleClass(CLASS_DISABLED, this.disabled).attr(ATTR_ID, this.id).data(NAMESPACE, this).appendTo(posOptions.container).append(elements.content = $("<div />", {
                class: NAMESPACE + "-content",
                id: this._id + "-content",
                "aria-atomic": TRUE
            }));
            this.rendered = -1;
            this.positioning = TRUE;
            if (title) {
                this._createTitle();
                if (!$.isFunction(title)) {
                    deferreds.push(this._updateTitle(title, FALSE));
                }
            }
            if (button) {
                this._createButton();
            }
            if (!$.isFunction(text)) {
                deferreds.push(this._updateContent(text, FALSE));
            }
            this.rendered = TRUE;
            this._setWidget();
            $.each(PLUGINS, function(name) {
                var instance;
                if (this.initialize === "render" && (instance = this(self))) {
                    self.plugins[name] = instance;
                }
            });
            this._unassignEvents();
            this._assignEvents();
            this._when(deferreds).then(function() {
                self._trigger("render");
                self.positioning = FALSE;
                if (!self.hiddenDuringWait && (options.show.ready || show)) {
                    self.toggle(TRUE, cache.event, FALSE);
                }
                self.hiddenDuringWait = FALSE;
            });
            QTIP.api[this.id] = this;
            return this;
        };
        PROTOTYPE.destroy = function(immediate) {
            if (this.destroyed) {
                return this.target;
            }
            function process() {
                if (this.destroyed) {
                    return;
                }
                this.destroyed = TRUE;
                var target = this.target, title = target.attr(oldtitle), timer;
                if (this.rendered) {
                    this.tooltip.stop(1, 0).find("*").remove().end().remove();
                }
                $.each(this.plugins, function(name) {
                    this.destroy && this.destroy();
                });
                for (timer in this.timers) {
                    clearTimeout(this.timers[timer]);
                }
                target.removeData(NAMESPACE).removeAttr(ATTR_ID).removeAttr(ATTR_HAS).removeAttr("aria-describedby");
                if (this.options.suppress && title) {
                    target.attr("title", title).removeAttr(oldtitle);
                }
                this._unassignEvents();
                this.options = this.elements = this.cache = this.timers = this.plugins = this.mouse = NULL;
                delete QTIP.api[this.id];
            }
            if ((immediate !== TRUE || this.triggering === "hide") && this.rendered) {
                this.tooltip.one("tooltiphidden", $.proxy(process, this));
                !this.triggering && this.hide();
            } else {
                process.call(this);
            }
            return this.target;
        };
        function invalidOpt(a) {
            return a === NULL || $.type(a) !== "object";
        }
        function invalidContent(c) {
            return !($.isFunction(c) || c && c.attr || c.length || $.type(c) === "object" && (c.jquery || c.then));
        }
        function sanitizeOptions(opts) {
            var content, text, ajax, once;
            if (invalidOpt(opts)) {
                return FALSE;
            }
            if (invalidOpt(opts.metadata)) {
                opts.metadata = {
                    type: opts.metadata
                };
            }
            if ("content" in opts) {
                content = opts.content;
                if (invalidOpt(content) || content.jquery || content.done) {
                    content = opts.content = {
                        text: text = invalidContent(content) ? FALSE : content
                    };
                } else {
                    text = content.text;
                }
                if ("ajax" in content) {
                    ajax = content.ajax;
                    once = ajax && ajax.once !== FALSE;
                    delete content.ajax;
                    content.text = function(event, api) {
                        var loading = text || $(this).attr(api.options.content.attr) || "Loading...", deferred = $.ajax($.extend({}, ajax, {
                            context: api
                        })).then(ajax.success, NULL, ajax.error).then(function(content) {
                            if (content && once) {
                                api.set("content.text", content);
                            }
                            return content;
                        }, function(xhr, status, error) {
                            if (api.destroyed || xhr.status === 0) {
                                return;
                            }
                            api.set("content.text", status + ": " + error);
                        });
                        return !once ? (api.set("content.text", loading), deferred) : loading;
                    };
                }
                if ("title" in content) {
                    if ($.isPlainObject(content.title)) {
                        content.button = content.title.button;
                        content.title = content.title.text;
                    }
                    if (invalidContent(content.title || FALSE)) {
                        content.title = FALSE;
                    }
                }
            }
            if ("position" in opts && invalidOpt(opts.position)) {
                opts.position = {
                    my: opts.position,
                    at: opts.position
                };
            }
            if ("show" in opts && invalidOpt(opts.show)) {
                opts.show = opts.show.jquery ? {
                    target: opts.show
                } : opts.show === TRUE ? {
                    ready: TRUE
                } : {
                    event: opts.show
                };
            }
            if ("hide" in opts && invalidOpt(opts.hide)) {
                opts.hide = opts.hide.jquery ? {
                    target: opts.hide
                } : {
                    event: opts.hide
                };
            }
            if ("style" in opts && invalidOpt(opts.style)) {
                opts.style = {
                    classes: opts.style
                };
            }
            $.each(PLUGINS, function() {
                this.sanitize && this.sanitize(opts);
            });
            return opts;
        }
        CHECKS = PROTOTYPE.checks = {
            builtin: {
                "^id$": function(obj, o, v, prev) {
                    var id = v === TRUE ? QTIP.nextid : v, new_id = NAMESPACE + "-" + id;
                    if (id !== FALSE && id.length > 0 && !$("#" + new_id).length) {
                        this._id = new_id;
                        if (this.rendered) {
                            this.tooltip[0].id = this._id;
                            this.elements.content[0].id = this._id + "-content";
                            this.elements.title[0].id = this._id + "-title";
                        }
                    } else {
                        obj[o] = prev;
                    }
                },
                "^prerender": function(obj, o, v) {
                    v && !this.rendered && this.render(this.options.show.ready);
                },
                "^content.text$": function(obj, o, v) {
                    this._updateContent(v);
                },
                "^content.attr$": function(obj, o, v, prev) {
                    if (this.options.content.text === this.target.attr(prev)) {
                        this._updateContent(this.target.attr(v));
                    }
                },
                "^content.title$": function(obj, o, v) {
                    if (!v) {
                        return this._removeTitle();
                    }
                    v && !this.elements.title && this._createTitle();
                    this._updateTitle(v);
                },
                "^content.button$": function(obj, o, v) {
                    this._updateButton(v);
                },
                "^content.title.(text|button)$": function(obj, o, v) {
                    this.set("content." + o, v);
                },
                "^position.(my|at)$": function(obj, o, v) {
                    "string" === typeof v && (this.position[o] = obj[o] = new CORNER(v, o === "at"));
                },
                "^position.container$": function(obj, o, v) {
                    this.rendered && this.tooltip.appendTo(v);
                },
                "^show.ready$": function(obj, o, v) {
                    v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));
                },
                "^style.classes$": function(obj, o, v, p) {
                    this.rendered && this.tooltip.removeClass(p).addClass(v);
                },
                "^style.(width|height)": function(obj, o, v) {
                    this.rendered && this.tooltip.css(o, v);
                },
                "^style.widget|content.title": function() {
                    this.rendered && this._setWidget();
                },
                "^style.def": function(obj, o, v) {
                    this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);
                },
                "^events.(render|show|move|hide|focus|blur)$": function(obj, o, v) {
                    this.rendered && this.tooltip[($.isFunction(v) ? "" : "un") + "bind"]("tooltip" + o, v);
                },
                "^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)": function() {
                    if (!this.rendered) {
                        return;
                    }
                    var posOptions = this.options.position;
                    this.tooltip.attr("tracking", posOptions.target === "mouse" && posOptions.adjust.mouse);
                    this._unassignEvents();
                    this._assignEvents();
                }
            }
        };
        function convertNotation(options, notation) {
            var i = 0, obj, option = options, levels = notation.split(".");
            while (option = option[levels[i++]]) {
                if (i < levels.length) {
                    obj = option;
                }
            }
            return [ obj || options, levels.pop() ];
        }
        PROTOTYPE.get = function(notation) {
            if (this.destroyed) {
                return this;
            }
            var o = convertNotation(this.options, notation.toLowerCase()), result = o[0][o[1]];
            return result.precedance ? result.string() : result;
        };
        function setCallback(notation, args) {
            var category, rule, match;
            for (category in this.checks) {
                for (rule in this.checks[category]) {
                    if (match = new RegExp(rule, "i").exec(notation)) {
                        args.push(match);
                        if (category === "builtin" || this.plugins[category]) {
                            this.checks[category][rule].apply(this.plugins[category] || this, args);
                        }
                    }
                }
            }
        }
        var rmove = /^position\.(my|at|adjust|target|container|viewport)|style|content|show\.ready/i, rrender = /^prerender|show\.ready/i;
        PROTOTYPE.set = function(option, value) {
            if (this.destroyed) {
                return this;
            }
            var rendered = this.rendered, reposition = FALSE, options = this.options, checks = this.checks, name;
            if ("string" === typeof option) {
                name = option;
                option = {};
                option[name] = value;
            } else {
                option = $.extend({}, option);
            }
            $.each(option, function(notation, value) {
                if (rendered && rrender.test(notation)) {
                    delete option[notation];
                    return;
                }
                var obj = convertNotation(options, notation.toLowerCase()), previous;
                previous = obj[0][obj[1]];
                obj[0][obj[1]] = value && value.nodeType ? $(value) : value;
                reposition = rmove.test(notation) || reposition;
                option[notation] = [ obj[0], obj[1], value, previous ];
            });
            sanitizeOptions(options);
            this.positioning = TRUE;
            $.each(option, $.proxy(setCallback, this));
            this.positioning = FALSE;
            if (this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {
                this.reposition(options.position.target === "mouse" ? NULL : this.cache.event);
            }
            return this;
        };
        PROTOTYPE._update = function(content, element, reposition) {
            var self = this, cache = this.cache;
            if (!this.rendered || !content) {
                return FALSE;
            }
            if ($.isFunction(content)) {
                content = content.call(this.elements.target, cache.event, this) || "";
            }
            if ($.isFunction(content.then)) {
                cache.waiting = TRUE;
                return content.then(function(c) {
                    cache.waiting = FALSE;
                    return self._update(c, element);
                }, NULL, function(e) {
                    return self._update(e, element);
                });
            }
            if (content === FALSE || !content && content !== "") {
                return FALSE;
            }
            if (content.jquery && content.length > 0) {
                element.empty().append(content.css({
                    display: "block",
                    visibility: "visible"
                }));
            } else {
                element.html(content);
            }
            return this._waitForContent(element).then(function(images) {
                if (self.rendered && self.tooltip[0].offsetWidth > 0) {
                    self.reposition(cache.event, !images.length);
                }
            });
        };
        PROTOTYPE._waitForContent = function(element) {
            var cache = this.cache;
            cache.waiting = TRUE;
            return ($.fn.imagesLoaded ? element.imagesLoaded() : $.Deferred().resolve([])).done(function() {
                cache.waiting = FALSE;
            }).promise();
        };
        PROTOTYPE._updateContent = function(content, reposition) {
            this._update(content, this.elements.content, reposition);
        };
        PROTOTYPE._updateTitle = function(content, reposition) {
            if (this._update(content, this.elements.title, reposition) === FALSE) {
                this._removeTitle(FALSE);
            }
        };
        PROTOTYPE._createTitle = function() {
            var elements = this.elements, id = this._id + "-title";
            if (elements.titlebar) {
                this._removeTitle();
            }
            elements.titlebar = $("<div />", {
                class: NAMESPACE + "-titlebar " + (this.options.style.widget ? createWidgetClass("header") : "")
            }).append(elements.title = $("<div />", {
                id: id,
                class: NAMESPACE + "-title",
                "aria-atomic": TRUE
            })).insertBefore(elements.content).delegate(".qtip-close", "mousedown keydown mouseup keyup mouseout", function(event) {
                $(this).toggleClass("ui-state-active ui-state-focus", event.type.substr(-4) === "down");
            }).delegate(".qtip-close", "mouseover mouseout", function(event) {
                $(this).toggleClass("ui-state-hover", event.type === "mouseover");
            });
            if (this.options.content.button) {
                this._createButton();
            }
        };
        PROTOTYPE._removeTitle = function(reposition) {
            var elements = this.elements;
            if (elements.title) {
                elements.titlebar.remove();
                elements.titlebar = elements.title = elements.button = NULL;
                if (reposition !== FALSE) {
                    this.reposition();
                }
            }
        };
        PROTOTYPE._createPosClass = function(my) {
            return NAMESPACE + "-pos-" + (my || this.options.position.my).abbrev();
        };
        PROTOTYPE.reposition = function(event, effect) {
            if (!this.rendered || this.positioning || this.destroyed) {
                return this;
            }
            this.positioning = TRUE;
            var cache = this.cache, tooltip = this.tooltip, posOptions = this.options.position, target = posOptions.target, my = posOptions.my, at = posOptions.at, viewport = posOptions.viewport, container = posOptions.container, adjust = posOptions.adjust, method = adjust.method.split(" "), tooltipWidth = tooltip.outerWidth(FALSE), tooltipHeight = tooltip.outerHeight(FALSE), targetWidth = 0, targetHeight = 0, type = tooltip.css("position"), position = {
                left: 0,
                top: 0
            }, visible = tooltip[0].offsetWidth > 0, isScroll = event && event.type === "scroll", win = $(window), doc = container[0].ownerDocument, mouse = this.mouse, pluginCalculations, offset, adjusted, newClass;
            if ($.isArray(target) && target.length === 2) {
                at = {
                    x: LEFT,
                    y: TOP
                };
                position = {
                    left: target[0],
                    top: target[1]
                };
            } else if (target === "mouse") {
                at = {
                    x: LEFT,
                    y: TOP
                };
                if ((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {
                    event = cache.origin;
                } else if (!event || event && (event.type === "resize" || event.type === "scroll")) {
                    event = cache.event;
                } else if (mouse && mouse.pageX) {
                    event = mouse;
                }
                if (type !== "static") {
                    position = container.offset();
                }
                if (doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {
                    offset = $(document.body).offset();
                }
                position = {
                    left: event.pageX - position.left + (offset && offset.left || 0),
                    top: event.pageY - position.top + (offset && offset.top || 0)
                };
                if (adjust.mouse && isScroll && mouse) {
                    position.left -= (mouse.scrollX || 0) - win.scrollLeft();
                    position.top -= (mouse.scrollY || 0) - win.scrollTop();
                }
            } else {
                if (target === "event") {
                    if (event && event.target && event.type !== "scroll" && event.type !== "resize") {
                        cache.target = $(event.target);
                    } else if (!event.target) {
                        cache.target = this.elements.target;
                    }
                } else if (target !== "event") {
                    cache.target = $(target.jquery ? target : this.elements.target);
                }
                target = cache.target;
                target = $(target).eq(0);
                if (target.length === 0) {
                    return this;
                } else if (target[0] === document || target[0] === window) {
                    targetWidth = BROWSER.iOS ? window.innerWidth : target.width();
                    targetHeight = BROWSER.iOS ? window.innerHeight : target.height();
                    if (target[0] === window) {
                        position = {
                            top: (viewport || target).scrollTop(),
                            left: (viewport || target).scrollLeft()
                        };
                    }
                } else if (PLUGINS.imagemap && target.is("area")) {
                    pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);
                } else if (PLUGINS.svg && target && target[0].ownerSVGElement) {
                    pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);
                } else {
                    targetWidth = target.outerWidth(FALSE);
                    targetHeight = target.outerHeight(FALSE);
                    position = target.offset();
                }
                if (pluginCalculations) {
                    targetWidth = pluginCalculations.width;
                    targetHeight = pluginCalculations.height;
                    offset = pluginCalculations.offset;
                    position = pluginCalculations.position;
                }
                position = this.reposition.offset(target, position, container);
                if (BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 || BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 || !BROWSER.iOS && type === "fixed") {
                    position.left -= win.scrollLeft();
                    position.top -= win.scrollTop();
                }
                if (!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {
                    position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;
                    position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;
                }
            }
            position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);
            position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);
            if (PLUGINS.viewport) {
                adjusted = position.adjusted = PLUGINS.viewport(this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight);
                if (offset && adjusted.left) {
                    position.left += offset.left;
                }
                if (offset && adjusted.top) {
                    position.top += offset.top;
                }
                if (adjusted.my) {
                    this.position.my = adjusted.my;
                }
            } else {
                position.adjusted = {
                    left: 0,
                    top: 0
                };
            }
            if (cache.posClass !== (newClass = this._createPosClass(this.position.my))) {
                tooltip.removeClass(cache.posClass).addClass(cache.posClass = newClass);
            }
            if (!this._trigger("move", [ position, viewport.elem || viewport ], event)) {
                return this;
            }
            delete position.adjusted;
            if (effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === "mouse" || !$.isFunction(posOptions.effect)) {
                tooltip.css(position);
            } else if ($.isFunction(posOptions.effect)) {
                posOptions.effect.call(tooltip, this, $.extend({}, position));
                tooltip.queue(function(next) {
                    $(this).css({
                        opacity: "",
                        height: ""
                    });
                    if (BROWSER.ie) {
                        this.style.removeAttribute("filter");
                    }
                    next();
                });
            }
            this.positioning = FALSE;
            return this;
        };
        PROTOTYPE.reposition.offset = function(elem, pos, container) {
            if (!container[0]) {
                return pos;
            }
            var ownerDocument = $(elem[0].ownerDocument), quirks = !!BROWSER.ie && document.compatMode !== "CSS1Compat", parent = container[0], scrolled, position, parentOffset, overflow;
            function scroll(e, i) {
                pos.left += i * e.scrollLeft();
                pos.top += i * e.scrollTop();
            }
            do {
                if ((position = $.css(parent, "position")) !== "static") {
                    if (position === "fixed") {
                        parentOffset = parent.getBoundingClientRect();
                        scroll(ownerDocument, -1);
                    } else {
                        parentOffset = $(parent).position();
                        parentOffset.left += parseFloat($.css(parent, "borderLeftWidth")) || 0;
                        parentOffset.top += parseFloat($.css(parent, "borderTopWidth")) || 0;
                    }
                    pos.left -= parentOffset.left + (parseFloat($.css(parent, "marginLeft")) || 0);
                    pos.top -= parentOffset.top + (parseFloat($.css(parent, "marginTop")) || 0);
                    if (!scrolled && (overflow = $.css(parent, "overflow")) !== "hidden" && overflow !== "visible") {
                        scrolled = $(parent);
                    }
                }
            } while (parent = parent.offsetParent);
            if (scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {
                scroll(scrolled, 1);
            }
            return pos;
        };
        var C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {
            corner = ("" + corner).replace(/([A-Z])/, " $1").replace(/middle/gi, CENTER).toLowerCase();
            this.x = (corner.match(/left|right/i) || corner.match(/center/) || [ "inherit" ])[0].toLowerCase();
            this.y = (corner.match(/top|bottom|center/i) || [ "inherit" ])[0].toLowerCase();
            this.forceY = !!forceY;
            var f = corner.charAt(0);
            this.precedance = f === "t" || f === "b" ? Y : X;
        }).prototype;
        C.invert = function(z, center) {
            this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];
        };
        C.string = function(join) {
            var x = this.x, y = this.y;
            var result = x !== y ? x === "center" || y !== "center" && (this.precedance === Y || this.forceY) ? [ y, x ] : [ x, y ] : [ x ];
            return join !== false ? result.join(" ") : result;
        };
        C.abbrev = function() {
            var result = this.string(false);
            return result[0].charAt(0) + (result[1] && result[1].charAt(0) || "");
        };
        C.clone = function() {
            return new CORNER(this.string(), this.forceY);
        };
        PROTOTYPE.toggle = function(state, event) {
            var cache = this.cache, options = this.options, tooltip = this.tooltip;
            if (event) {
                if (/over|enter/.test(event.type) && cache.event && /out|leave/.test(cache.event.type) && options.show.target.add(event.target).length === options.show.target.length && tooltip.has(event.relatedTarget).length) {
                    return this;
                }
                cache.event = $.event.fix(event);
            }
            this.waiting && !state && (this.hiddenDuringWait = TRUE);
            if (!this.rendered) {
                return state ? this.render(1) : this;
            } else if (this.destroyed || this.disabled) {
                return this;
            }
            var type = state ? "show" : "hide", opts = this.options[type], otherOpts = this.options[!state ? "show" : "hide"], posOptions = this.options.position, contentOptions = this.options.content, width = this.tooltip.css("width"), visible = this.tooltip.is(":visible"), animate = state || opts.target.length === 1, sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target, identicalState, allow, showEvent, delay, after;
            if ((typeof state).search("boolean|number")) {
                state = !visible;
            }
            identicalState = !tooltip.is(":animated") && visible === state && sameTarget;
            allow = !identicalState ? !!this._trigger(type, [ 90 ]) : NULL;
            if (this.destroyed) {
                return this;
            }
            if (allow !== FALSE && state) {
                this.focus(event);
            }
            if (!allow || identicalState) {
                return this;
            }
            $.attr(tooltip[0], "aria-hidden", !!!state);
            if (state) {
                this.mouse && (cache.origin = $.event.fix(this.mouse));
                if ($.isFunction(contentOptions.text)) {
                    this._updateContent(contentOptions.text, FALSE);
                }
                if ($.isFunction(contentOptions.title)) {
                    this._updateTitle(contentOptions.title, FALSE);
                }
                if (!trackingBound && posOptions.target === "mouse" && posOptions.adjust.mouse) {
                    $(document).bind("mousemove." + NAMESPACE, this._storeMouse);
                    trackingBound = TRUE;
                }
                if (!width) {
                    tooltip.css("width", tooltip.outerWidth(FALSE));
                }
                this.reposition(event, arguments[2]);
                if (!width) {
                    tooltip.css("width", "");
                }
                if (!!opts.solo) {
                    (typeof opts.solo === "string" ? $(opts.solo) : $(SELECTOR, opts.solo)).not(tooltip).not(opts.target).qtip("hide", $.Event("tooltipsolo"));
                }
            } else {
                clearTimeout(this.timers.show);
                delete cache.origin;
                if (trackingBound && !$(SELECTOR + '[tracking="true"]:visible', opts.solo).not(tooltip).length) {
                    $(document).unbind("mousemove." + NAMESPACE);
                    trackingBound = FALSE;
                }
                this.blur(event);
            }
            after = $.proxy(function() {
                if (state) {
                    if (BROWSER.ie) {
                        tooltip[0].style.removeAttribute("filter");
                    }
                    tooltip.css("overflow", "");
                    if ("string" === typeof opts.autofocus) {
                        $(this.options.show.autofocus, tooltip).focus();
                    }
                    this.options.show.target.trigger("qtip-" + this.id + "-inactive");
                } else {
                    tooltip.css({
                        display: "",
                        visibility: "",
                        opacity: "",
                        left: "",
                        top: ""
                    });
                }
                this._trigger(state ? "visible" : "hidden");
            }, this);
            if (opts.effect === FALSE || animate === FALSE) {
                tooltip[type]();
                after();
            } else if ($.isFunction(opts.effect)) {
                tooltip.stop(1, 1);
                opts.effect.call(tooltip, this);
                tooltip.queue("fx", function(n) {
                    after();
                    n();
                });
            } else {
                tooltip.fadeTo(90, state ? 1 : 0, after);
            }
            if (state) {
                opts.target.trigger("qtip-" + this.id + "-inactive");
            }
            return this;
        };
        PROTOTYPE.show = function(event) {
            return this.toggle(TRUE, event);
        };
        PROTOTYPE.hide = function(event) {
            return this.toggle(FALSE, event);
        };
        PROTOTYPE.focus = function(event) {
            if (!this.rendered || this.destroyed) {
                return this;
            }
            var qtips = $(SELECTOR), tooltip = this.tooltip, curIndex = parseInt(tooltip[0].style.zIndex, 10), newIndex = QTIP.zindex + qtips.length, focusedElem;
            if (!tooltip.hasClass(CLASS_FOCUS)) {
                if (this._trigger("focus", [ newIndex ], event)) {
                    if (curIndex !== newIndex) {
                        qtips.each(function() {
                            if (this.style.zIndex > curIndex) {
                                this.style.zIndex = this.style.zIndex - 1;
                            }
                        });
                        qtips.filter("." + CLASS_FOCUS).qtip("blur", event);
                    }
                    tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;
                }
            }
            return this;
        };
        PROTOTYPE.blur = function(event) {
            if (!this.rendered || this.destroyed) {
                return this;
            }
            this.tooltip.removeClass(CLASS_FOCUS);
            this._trigger("blur", [ this.tooltip.css("zIndex") ], event);
            return this;
        };
        PROTOTYPE.disable = function(state) {
            if (this.destroyed) {
                return this;
            }
            if (state === "toggle") {
                state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);
            } else if ("boolean" !== typeof state) {
                state = TRUE;
            }
            if (this.rendered) {
                this.tooltip.toggleClass(CLASS_DISABLED, state).attr("aria-disabled", state);
            }
            this.disabled = !!state;
            return this;
        };
        PROTOTYPE.enable = function() {
            return this.disable(FALSE);
        };
        PROTOTYPE._createButton = function() {
            var self = this, elements = this.elements, tooltip = elements.tooltip, button = this.options.content.button, isString = typeof button === "string", close = isString ? button : "Close tooltip";
            if (elements.button) {
                elements.button.remove();
            }
            if (button.jquery) {
                elements.button = button;
            } else {
                elements.button = $("<a />", {
                    class: "qtip-close " + (this.options.style.widget ? "" : NAMESPACE + "-icon"),
                    title: close,
                    "aria-label": close
                }).prepend($("<span />", {
                    class: "ui-icon ui-icon-close",
                    html: "&times;"
                }));
            }
            elements.button.appendTo(elements.titlebar || tooltip).attr("role", "button").click(function(event) {
                if (!tooltip.hasClass(CLASS_DISABLED)) {
                    self.hide(event);
                }
                return FALSE;
            });
        };
        PROTOTYPE._updateButton = function(button) {
            if (!this.rendered) {
                return FALSE;
            }
            var elem = this.elements.button;
            if (button) {
                this._createButton();
            } else {
                elem.remove();
            }
        };
        function createWidgetClass(cls) {
            return WIDGET.concat("").join(cls ? "-" + cls + " " : " ");
        }
        PROTOTYPE._setWidget = function() {
            var on = this.options.style.widget, elements = this.elements, tooltip = elements.tooltip, disabled = tooltip.hasClass(CLASS_DISABLED);
            tooltip.removeClass(CLASS_DISABLED);
            CLASS_DISABLED = on ? "ui-state-disabled" : "qtip-disabled";
            tooltip.toggleClass(CLASS_DISABLED, disabled);
            tooltip.toggleClass("ui-helper-reset " + createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);
            if (elements.content) {
                elements.content.toggleClass(createWidgetClass("content"), on);
            }
            if (elements.titlebar) {
                elements.titlebar.toggleClass(createWidgetClass("header"), on);
            }
            if (elements.button) {
                elements.button.toggleClass(NAMESPACE + "-icon", !on);
            }
        };
        function delay(callback, duration) {
            if (duration > 0) {
                return setTimeout($.proxy(callback, this), duration);
            } else {
                callback.call(this);
            }
        }
        function showMethod(event) {
            if (this.tooltip.hasClass(CLASS_DISABLED)) {
                return;
            }
            clearTimeout(this.timers.show);
            clearTimeout(this.timers.hide);
            this.timers.show = delay.call(this, function() {
                this.toggle(TRUE, event);
            }, this.options.show.delay);
        }
        function hideMethod(event) {
            if (this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) {
                return;
            }
            var relatedTarget = $(event.relatedTarget), ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0], ontoTarget = relatedTarget[0] === this.options.show.target[0];
            clearTimeout(this.timers.show);
            clearTimeout(this.timers.hide);
            if (this !== relatedTarget[0] && (this.options.position.target === "mouse" && ontoTooltip) || this.options.hide.fixed && (/mouse(out|leave|move)/.test(event.type) && (ontoTooltip || ontoTarget))) {
                try {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                } catch (e) {}
                return;
            }
            this.timers.hide = delay.call(this, function() {
                this.toggle(FALSE, event);
            }, this.options.hide.delay, this);
        }
        function inactiveMethod(event) {
            if (this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) {
                return;
            }
            clearTimeout(this.timers.inactive);
            this.timers.inactive = delay.call(this, function() {
                this.hide(event);
            }, this.options.hide.inactive);
        }
        function repositionMethod(event) {
            if (this.rendered && this.tooltip[0].offsetWidth > 0) {
                this.reposition(event);
            }
        }
        PROTOTYPE._storeMouse = function(event) {
            (this.mouse = $.event.fix(event)).type = "mousemove";
            return this;
        };
        PROTOTYPE._bind = function(targets, events, method, suffix, context) {
            if (!targets || !method || !events.length) {
                return;
            }
            var ns = "." + this._id + (suffix ? "-" + suffix : "");
            $(targets).bind((events.split ? events : events.join(ns + " ")) + ns, $.proxy(method, context || this));
            return this;
        };
        PROTOTYPE._unbind = function(targets, suffix) {
            targets && $(targets).unbind("." + this._id + (suffix ? "-" + suffix : ""));
            return this;
        };
        function delegate(selector, events, method) {
            $(document.body).delegate(selector, (events.split ? events : events.join("." + NAMESPACE + " ")) + "." + NAMESPACE, function() {
                var api = QTIP.api[$.attr(this, ATTR_ID)];
                api && !api.disabled && method.apply(api, arguments);
            });
        }
        PROTOTYPE._trigger = function(type, args, event) {
            var callback = $.Event("tooltip" + type);
            callback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;
            this.triggering = type;
            this.tooltip.trigger(callback, [ this ].concat(args || []));
            this.triggering = FALSE;
            return !callback.isDefaultPrevented();
        };
        PROTOTYPE._bindEvents = function(showEvents, hideEvents, showTargets, hideTargets, showMethod, hideMethod) {
            var similarTargets = showTargets.filter(hideTargets).add(hideTargets.filter(showTargets)), toggleEvents = [];
            if (similarTargets.length) {
                $.each(hideEvents, function(i, type) {
                    var showIndex = $.inArray(type, showEvents);
                    showIndex > -1 && toggleEvents.push(showEvents.splice(showIndex, 1)[0]);
                });
                if (toggleEvents.length) {
                    this._bind(similarTargets, toggleEvents, function(event) {
                        var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;
                        (state ? hideMethod : showMethod).call(this, event);
                    });
                    showTargets = showTargets.not(similarTargets);
                    hideTargets = hideTargets.not(similarTargets);
                }
            }
            this._bind(showTargets, showEvents, showMethod);
            this._bind(hideTargets, hideEvents, hideMethod);
        };
        PROTOTYPE._assignInitialEvents = function(event) {
            var options = this.options, showTarget = options.show.target, hideTarget = options.hide.target, showEvents = options.show.event ? $.trim("" + options.show.event).split(" ") : [], hideEvents = options.hide.event ? $.trim("" + options.hide.event).split(" ") : [];
            this._bind(this.elements.target, [ "remove", "removeqtip" ], function(event) {
                this.destroy(true);
            }, "destroy");
            if (/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {
                hideEvents.push("mouseleave");
            }
            this._bind(showTarget, "mousemove", function(event) {
                this._storeMouse(event);
                this.cache.onTarget = TRUE;
            });
            function hoverIntent(event) {
                if (this.disabled || this.destroyed) {
                    return FALSE;
                }
                this.cache.event = event && $.event.fix(event);
                this.cache.target = event && $(event.target);
                clearTimeout(this.timers.show);
                this.timers.show = delay.call(this, function() {
                    this.render(typeof event === "object" || options.show.ready);
                }, options.prerender ? 0 : options.show.delay);
            }
            this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {
                if (!this.timers) {
                    return FALSE;
                }
                clearTimeout(this.timers.show);
            });
            if (options.show.ready || options.prerender) {
                hoverIntent.call(this, event);
            }
        };
        PROTOTYPE._assignEvents = function() {
            var self = this, options = this.options, posOptions = options.position, tooltip = this.tooltip, showTarget = options.show.target, hideTarget = options.hide.target, containerTarget = posOptions.container, viewportTarget = posOptions.viewport, documentTarget = $(document), bodyTarget = $(document.body), windowTarget = $(window), showEvents = options.show.event ? $.trim("" + options.show.event).split(" ") : [], hideEvents = options.hide.event ? $.trim("" + options.hide.event).split(" ") : [];
            $.each(options.events, function(name, callback) {
                self._bind(tooltip, name === "toggle" ? [ "tooltipshow", "tooltiphide" ] : [ "tooltip" + name ], callback, null, tooltip);
            });
            if (/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === "window") {
                this._bind(documentTarget, [ "mouseout", "blur" ], function(event) {
                    if (!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {
                        this.hide(event);
                    }
                });
            }
            if (options.hide.fixed) {
                hideTarget = hideTarget.add(tooltip.addClass(CLASS_FIXED));
            } else if (/mouse(over|enter)/i.test(options.show.event)) {
                this._bind(hideTarget, "mouseleave", function() {
                    clearTimeout(this.timers.show);
                });
            }
            if (("" + options.hide.event).indexOf("unfocus") > -1) {
                this._bind(containerTarget.closest("html"), [ "mousedown", "touchstart" ], function(event) {
                    var elem = $(event.target), enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0, isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;
                    if (elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor && !this.target.has(elem[0]).length && enabled) {
                        this.hide(event);
                    }
                });
            }
            if ("number" === typeof options.hide.inactive) {
                this._bind(showTarget, "qtip-" + this.id + "-inactive", inactiveMethod, "inactive");
                this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);
            }
            this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);
            this._bind(showTarget.add(tooltip), "mousemove", function(event) {
                if ("number" === typeof options.hide.distance) {
                    var origin = this.cache.origin || {}, limit = this.options.hide.distance, abs = Math.abs;
                    if (abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {
                        this.hide(event);
                    }
                }
                this._storeMouse(event);
            });
            if (posOptions.target === "mouse") {
                if (posOptions.adjust.mouse) {
                    if (options.hide.event) {
                        this._bind(showTarget, [ "mouseenter", "mouseleave" ], function(event) {
                            if (!this.cache) {
                                return FALSE;
                            }
                            this.cache.onTarget = event.type === "mouseenter";
                        });
                    }
                    this._bind(documentTarget, "mousemove", function(event) {
                        if (this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {
                            this.reposition(event);
                        }
                    });
                }
            }
            if (posOptions.adjust.resize || viewportTarget.length) {
                this._bind($.event.special.resize ? viewportTarget : windowTarget, "resize", repositionMethod);
            }
            if (posOptions.adjust.scroll) {
                this._bind(windowTarget.add(posOptions.container), "scroll", repositionMethod);
            }
        };
        PROTOTYPE._unassignEvents = function() {
            var options = this.options, showTargets = options.show.target, hideTargets = options.hide.target, targets = $.grep([ this.elements.target[0], this.rendered && this.tooltip[0], options.position.container[0], options.position.viewport[0], options.position.container.closest("html")[0], window, document ], function(i) {
                return typeof i === "object";
            });
            if (showTargets && showTargets.toArray) {
                targets = targets.concat(showTargets.toArray());
            }
            if (hideTargets && hideTargets.toArray) {
                targets = targets.concat(hideTargets.toArray());
            }
            this._unbind(targets)._unbind(targets, "destroy")._unbind(targets, "inactive");
        };
        $(function() {
            delegate(SELECTOR, [ "mouseenter", "mouseleave" ], function(event) {
                var state = event.type === "mouseenter", tooltip = $(event.currentTarget), target = $(event.relatedTarget || event.target), options = this.options;
                if (state) {
                    this.focus(event);
                    tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);
                } else {
                    if (options.position.target === "mouse" && options.position.adjust.mouse && options.hide.event && options.show.target && !target.closest(options.show.target[0]).length) {
                        this.hide(event);
                    }
                }
                tooltip.toggleClass(CLASS_HOVER, state);
            });
            delegate("[" + ATTR_ID + "]", INACTIVE_EVENTS, inactiveMethod);
        });
        function init(elem, id, opts) {
            var obj, posOptions, attr, config, title, docBody = $(document.body), newTarget = elem[0] === document ? docBody : elem, metadata = elem.metadata ? elem.metadata(opts.metadata) : NULL, metadata5 = opts.metadata.type === "html5" && metadata ? metadata[opts.metadata.name] : NULL, html5 = elem.data(opts.metadata.name || "qtipopts");
            try {
                html5 = typeof html5 === "string" ? $.parseJSON(html5) : html5;
            } catch (e) {}
            config = $.extend(TRUE, {}, QTIP.defaults, opts, typeof html5 === "object" ? sanitizeOptions(html5) : NULL, sanitizeOptions(metadata5 || metadata));
            posOptions = config.position;
            config.id = id;
            if ("boolean" === typeof config.content.text) {
                attr = elem.attr(config.content.attr);
                if (config.content.attr !== FALSE && attr) {
                    config.content.text = attr;
                } else {
                    return FALSE;
                }
            }
            if (!posOptions.container.length) {
                posOptions.container = docBody;
            }
            if (posOptions.target === FALSE) {
                posOptions.target = newTarget;
            }
            if (config.show.target === FALSE) {
                config.show.target = newTarget;
            }
            if (config.show.solo === TRUE) {
                config.show.solo = posOptions.container.closest("body");
            }
            if (config.hide.target === FALSE) {
                config.hide.target = newTarget;
            }
            if (config.position.viewport === TRUE) {
                config.position.viewport = posOptions.container;
            }
            posOptions.container = posOptions.container.eq(0);
            posOptions.at = new CORNER(posOptions.at, TRUE);
            posOptions.my = new CORNER(posOptions.my);
            if (elem.data(NAMESPACE)) {
                if (config.overwrite) {
                    elem.qtip("destroy", true);
                } else if (config.overwrite === FALSE) {
                    return FALSE;
                }
            }
            elem.attr(ATTR_HAS, id);
            if (config.suppress && (title = elem.attr("title"))) {
                elem.removeAttr("title").attr(oldtitle, title).attr("title", "");
            }
            obj = new QTip(elem, config, id, !!attr);
            elem.data(NAMESPACE, obj);
            return obj;
        }
        QTIP = $.fn.qtip = function(options, notation, newValue) {
            var command = ("" + options).toLowerCase(), returned = NULL, args = $.makeArray(arguments).slice(1), event = args[args.length - 1], opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;
            if (!arguments.length && opts || command === "api") {
                return opts;
            } else if ("string" === typeof options) {
                this.each(function() {
                    var api = $.data(this, NAMESPACE);
                    if (!api) {
                        return TRUE;
                    }
                    if (event && event.timeStamp) {
                        api.cache.event = event;
                    }
                    if (notation && (command === "option" || command === "options")) {
                        if (newValue !== undefined || $.isPlainObject(notation)) {
                            api.set(notation, newValue);
                        } else {
                            returned = api.get(notation);
                            return FALSE;
                        }
                    } else if (api[command]) {
                        api[command].apply(api, args);
                    }
                });
                return returned !== NULL ? returned : this;
            } else if ("object" === typeof options || !arguments.length) {
                opts = sanitizeOptions($.extend(TRUE, {}, options));
                return this.each(function(i) {
                    var api, id;
                    id = $.isArray(opts.id) ? opts.id[i] : opts.id;
                    id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;
                    api = init($(this), id, opts);
                    if (api === FALSE) {
                        return TRUE;
                    } else {
                        QTIP.api[id] = api;
                    }
                    $.each(PLUGINS, function() {
                        if (this.initialize === "initialize") {
                            this(api);
                        }
                    });
                    api._assignInitialEvents(event);
                });
            }
        };
        $.qtip = QTip;
        QTIP.api = {};
        $.each({
            attr: function(attr, val) {
                if (this.length) {
                    var self = this[0], title = "title", api = $.data(self, "qtip");
                    if (attr === title && api && "object" === typeof api && api.options.suppress) {
                        if (arguments.length < 2) {
                            return $.attr(self, oldtitle);
                        }
                        if (api && api.options.content.attr === title && api.cache.attr) {
                            api.set("content.text", val);
                        }
                        return this.attr(oldtitle, val);
                    }
                }
                return $.fn["attr" + replaceSuffix].apply(this, arguments);
            },
            clone: function(keepData) {
                var titles = $([]), title = "title", elems = $.fn["clone" + replaceSuffix].apply(this, arguments);
                if (!keepData) {
                    elems.filter("[" + oldtitle + "]").attr("title", function() {
                        return $.attr(this, oldtitle);
                    }).removeAttr(oldtitle);
                }
                return elems;
            }
        }, function(name, func) {
            if (!func || $.fn[name + replaceSuffix]) {
                return TRUE;
            }
            var old = $.fn[name + replaceSuffix] = $.fn[name];
            $.fn[name] = function() {
                return func.apply(this, arguments) || old.apply(this, arguments);
            };
        });
        if (!$.ui) {
            $["cleanData" + replaceSuffix] = $.cleanData;
            $.cleanData = function(elems) {
                for (var i = 0, elem; (elem = $(elems[i])).length; i++) {
                    if (elem.attr(ATTR_HAS)) {
                        try {
                            elem.triggerHandler("removeqtip");
                        } catch (e) {}
                    }
                }
                $["cleanData" + replaceSuffix].apply(this, arguments);
            };
        }
        QTIP.version = "2.2.1";
        QTIP.nextid = 0;
        QTIP.inactiveEvents = INACTIVE_EVENTS;
        QTIP.zindex = 15e3;
        QTIP.defaults = {
            prerender: FALSE,
            id: FALSE,
            overwrite: TRUE,
            suppress: TRUE,
            content: {
                text: TRUE,
                attr: "title",
                title: FALSE,
                button: FALSE
            },
            position: {
                my: "top left",
                at: "bottom right",
                target: FALSE,
                container: FALSE,
                viewport: FALSE,
                adjust: {
                    x: 0,
                    y: 0,
                    mouse: TRUE,
                    scroll: TRUE,
                    resize: TRUE,
                    method: "flipinvert flipinvert"
                },
                effect: function(api, pos, viewport) {
                    $(this).animate(pos, {
                        duration: 200,
                        queue: FALSE
                    });
                }
            },
            show: {
                target: FALSE,
                event: "mouseenter",
                effect: TRUE,
                delay: 90,
                solo: FALSE,
                ready: FALSE,
                autofocus: FALSE
            },
            hide: {
                target: FALSE,
                event: "mouseleave",
                effect: TRUE,
                delay: 0,
                fixed: FALSE,
                inactive: FALSE,
                leave: "window",
                distance: FALSE
            },
            style: {
                classes: "",
                widget: FALSE,
                width: FALSE,
                height: FALSE,
                def: TRUE
            },
            events: {
                render: NULL,
                move: NULL,
                show: NULL,
                hide: NULL,
                toggle: NULL,
                visible: NULL,
                hidden: NULL,
                focus: NULL,
                blur: NULL
            }
        };
        var TIP, TIPNS = ".qtip-tip", MARGIN = "margin", BORDER = "border", COLOR = "color", BG_COLOR = "background-color", TRANSPARENT = "transparent", IMPORTANT = " !important", HASCANVAS = !!document.createElement("canvas").getContext, INVALID = /rgba?\(0, 0, 0(, 0)?\)|transparent|#123456/i;
        function camel(s) {
            return s.charAt(0).toUpperCase() + s.slice(1);
        }
        var cssProps = {}, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
        function vendorCss(elem, prop) {
            var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1), props = (prop + " " + cssPrefixes.join(ucProp + " ") + ucProp).split(" "), cur, val, i = 0;
            if (cssProps[prop]) {
                return elem.css(cssProps[prop]);
            }
            while (cur = props[i++]) {
                if ((val = elem.css(cur)) !== undefined) {
                    return cssProps[prop] = cur, val;
                }
            }
        }
        function intCss(elem, prop) {
            return Math.ceil(parseFloat(vendorCss(elem, prop)));
        }
        if (!HASCANVAS) {
            var createVML = function(tag, props, style) {
                return "<qtipvml:" + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="qtip-vml" ' + (props || "") + ' style="behavior: url(#default#VML); ' + (style || "") + '" />';
            };
        } else {
            var PIXEL_RATIO = window.devicePixelRatio || 1, BACKING_STORE_RATIO = function() {
                var context = document.createElement("canvas").getContext("2d");
                return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;
            }(), SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;
        }
        function Tip(qtip, options) {
            this._ns = "tip";
            this.options = options;
            this.offset = options.offset;
            this.size = [ options.width, options.height ];
            this.init(this.qtip = qtip);
        }
        $.extend(Tip.prototype, {
            init: function(qtip) {
                var context, tip;
                tip = this.element = qtip.elements.tip = $("<div />", {
                    class: NAMESPACE + "-tip"
                }).prependTo(qtip.tooltip);
                if (HASCANVAS) {
                    context = $("<canvas />").appendTo(this.element)[0].getContext("2d");
                    context.lineJoin = "miter";
                    context.miterLimit = 1e5;
                    context.save();
                } else {
                    context = createVML("shape", 'coordorigin="0,0"', "position:absolute;");
                    this.element.html(context + context);
                    qtip._bind($("*", tip).add(tip), [ "click", "mousedown" ], function(event) {
                        event.stopPropagation();
                    }, this._ns);
                }
                qtip._bind(qtip.tooltip, "tooltipmove", this.reposition, this._ns, this);
                this.create();
            },
            _swapDimensions: function() {
                this.size[0] = this.options.height;
                this.size[1] = this.options.width;
            },
            _resetDimensions: function() {
                this.size[0] = this.options.width;
                this.size[1] = this.options.height;
            },
            _useTitle: function(corner) {
                var titlebar = this.qtip.elements.titlebar;
                return titlebar && (corner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE));
            },
            _parseCorner: function(corner) {
                var my = this.qtip.options.position.my;
                if (corner === FALSE || my === FALSE) {
                    corner = FALSE;
                } else if (corner === TRUE) {
                    corner = new CORNER(my.string());
                } else if (!corner.string) {
                    corner = new CORNER(corner);
                    corner.fixed = TRUE;
                }
                return corner;
            },
            _parseWidth: function(corner, side, use) {
                var elements = this.qtip.elements, prop = BORDER + camel(side) + "Width";
                return (use ? intCss(use, prop) : intCss(elements.content, prop) || intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop)) || 0;
            },
            _parseRadius: function(corner) {
                var elements = this.qtip.elements, prop = BORDER + camel(corner.y) + camel(corner.x) + "Radius";
                return BROWSER.ie < 9 ? 0 : intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop) || 0;
            },
            _invalidColour: function(elem, prop, compare) {
                var val = elem.css(prop);
                return !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;
            },
            _parseColours: function(corner) {
                var elements = this.qtip.elements, tip = this.element.css("cssText", ""), borderSide = BORDER + camel(corner[corner.precedance]) + camel(COLOR), colorElem = this._useTitle(corner) && elements.titlebar || elements.content, css = this._invalidColour, color = [];
                color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) || css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);
                color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) || css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);
                $("*", tip).add(tip).css("cssText", BG_COLOR + ":" + TRANSPARENT + IMPORTANT + ";" + BORDER + ":0" + IMPORTANT + ";");
                return color;
            },
            _calculateSize: function(corner) {
                var y = corner.precedance === Y, width = this.options["width"], height = this.options["height"], isCenter = corner.abbrev() === "c", base = (y ? width : height) * (isCenter ? .5 : 1), pow = Math.pow, round = Math.round, bigHyp, ratio, result, smallHyp = Math.sqrt(pow(base, 2) + pow(height, 2)), hyp = [ this.border / base * smallHyp, this.border / height * smallHyp ];
                hyp[2] = Math.sqrt(pow(hyp[0], 2) - pow(this.border, 2));
                hyp[3] = Math.sqrt(pow(hyp[1], 2) - pow(this.border, 2));
                bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);
                ratio = bigHyp / smallHyp;
                result = [ round(ratio * width), round(ratio * height) ];
                return y ? result : result.reverse();
            },
            _calculateTip: function(corner, size, scale) {
                scale = scale || 1;
                size = size || this.size;
                var width = size[0] * scale, height = size[1] * scale, width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2), tips = {
                    br: [ 0, 0, width, height, width, 0 ],
                    bl: [ 0, 0, width, 0, 0, height ],
                    tr: [ 0, height, width, 0, width, height ],
                    tl: [ 0, 0, 0, height, width, height ],
                    tc: [ 0, height, width2, 0, width, height ],
                    bc: [ 0, 0, width, 0, width2, height ],
                    rc: [ 0, 0, width, height2, 0, height ],
                    lc: [ width, 0, width, height, 0, height2 ]
                };
                tips.lt = tips.br;
                tips.rt = tips.bl;
                tips.lb = tips.tr;
                tips.rb = tips.tl;
                return tips[corner.abbrev()];
            },
            _drawCoords: function(context, coords) {
                context.beginPath();
                context.moveTo(coords[0], coords[1]);
                context.lineTo(coords[2], coords[3]);
                context.lineTo(coords[4], coords[5]);
                context.closePath();
            },
            create: function() {
                var c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);
                if (this.enabled = !!this.corner && this.corner.abbrev() !== "c") {
                    this.qtip.cache.corner = c.clone();
                    this.update();
                }
                this.element.toggle(this.enabled);
                return this.corner;
            },
            update: function(corner, position) {
                if (!this.enabled) {
                    return this;
                }
                var elements = this.qtip.elements, tip = this.element, inner = tip.children(), options = this.options, curSize = this.size, mimic = options.mimic, round = Math.round, color, precedance, context, coords, bigCoords, translate, newSize, border, BACKING_STORE_RATIO;
                if (!corner) {
                    corner = this.qtip.cache.corner || this.corner;
                }
                if (mimic === FALSE) {
                    mimic = corner;
                } else {
                    mimic = new CORNER(mimic);
                    mimic.precedance = corner.precedance;
                    if (mimic.x === "inherit") {
                        mimic.x = corner.x;
                    } else if (mimic.y === "inherit") {
                        mimic.y = corner.y;
                    } else if (mimic.x === mimic.y) {
                        mimic[corner.precedance] = corner[corner.precedance];
                    }
                }
                precedance = mimic.precedance;
                if (corner.precedance === X) {
                    this._swapDimensions();
                } else {
                    this._resetDimensions();
                }
                color = this.color = this._parseColours(corner);
                if (color[1] !== TRANSPARENT) {
                    border = this.border = this._parseWidth(corner, corner[corner.precedance]);
                    if (options.border && border < 1 && !INVALID.test(color[1])) {
                        color[0] = color[1];
                    }
                    this.border = border = options.border !== TRUE ? options.border : border;
                } else {
                    this.border = border = 0;
                }
                newSize = this.size = this._calculateSize(corner);
                tip.css({
                    width: newSize[0],
                    height: newSize[1],
                    lineHeight: newSize[1] + "px"
                });
                if (corner.precedance === Y) {
                    translate = [ round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2), round(mimic.y === TOP ? newSize[1] - curSize[1] : 0) ];
                } else {
                    translate = [ round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0), round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2) ];
                }
                if (HASCANVAS) {
                    context = inner[0].getContext("2d");
                    context.restore();
                    context.save();
                    context.clearRect(0, 0, 6e3, 6e3);
                    coords = this._calculateTip(mimic, curSize, SCALE);
                    bigCoords = this._calculateTip(mimic, this.size, SCALE);
                    inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);
                    inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);
                    this._drawCoords(context, bigCoords);
                    context.fillStyle = color[1];
                    context.fill();
                    context.translate(translate[0] * SCALE, translate[1] * SCALE);
                    this._drawCoords(context, coords);
                    context.fillStyle = color[0];
                    context.fill();
                } else {
                    coords = this._calculateTip(mimic);
                    coords = "m" + coords[0] + "," + coords[1] + " l" + coords[2] + "," + coords[3] + " " + coords[4] + "," + coords[5] + " xe";
                    translate[2] = border && /^(r|b)/i.test(corner.string()) ? BROWSER.ie === 8 ? 2 : 1 : 0;
                    inner.css({
                        coordsize: newSize[0] + border + " " + (newSize[1] + border),
                        antialias: "" + (mimic.string().indexOf(CENTER) > -1),
                        left: translate[0] - translate[2] * Number(precedance === X),
                        top: translate[1] - translate[2] * Number(precedance === Y),
                        width: newSize[0] + border,
                        height: newSize[1] + border
                    }).each(function(i) {
                        var $this = $(this);
                        $this[$this.prop ? "prop" : "attr"]({
                            coordsize: newSize[0] + border + " " + (newSize[1] + border),
                            path: coords,
                            fillcolor: color[0],
                            filled: !!i,
                            stroked: !i
                        }).toggle(!!(border || i));
                        !i && $this.html(createVML("stroke", 'weight="' + border * 2 + 'px" color="' + color[1] + '" miterlimit="1000" joinstyle="miter"'));
                    });
                }
                window.opera && setTimeout(function() {
                    elements.tip.css({
                        display: "inline-block",
                        visibility: "visible"
                    });
                }, 1);
                if (position !== FALSE) {
                    this.calculate(corner, newSize);
                }
            },
            calculate: function(corner, size) {
                if (!this.enabled) {
                    return FALSE;
                }
                var self = this, elements = this.qtip.elements, tip = this.element, userOffset = this.options.offset, isWidget = elements.tooltip.hasClass("ui-widget"), position = {}, precedance, corners;
                corner = corner || this.corner;
                precedance = corner.precedance;
                size = size || this._calculateSize(corner);
                corners = [ corner.x, corner.y ];
                if (precedance === X) {
                    corners.reverse();
                }
                $.each(corners, function(i, side) {
                    var b, bc, br;
                    if (side === CENTER) {
                        b = precedance === Y ? LEFT : TOP;
                        position[b] = "50%";
                        position[MARGIN + "-" + b] = -Math.round(size[precedance === Y ? 0 : 1] / 2) + userOffset;
                    } else {
                        b = self._parseWidth(corner, side, elements.tooltip);
                        bc = self._parseWidth(corner, side, elements.content);
                        br = self._parseRadius(corner);
                        position[side] = Math.max(-self.border, i ? bc : userOffset + (br > b ? br : -b));
                    }
                });
                position[corner[precedance]] -= size[precedance === X ? 0 : 1];
                tip.css({
                    margin: "",
                    top: "",
                    bottom: "",
                    left: "",
                    right: ""
                }).css(position);
                return position;
            },
            reposition: function(event, api, pos, viewport) {
                if (!this.enabled) {
                    return;
                }
                var cache = api.cache, newCorner = this.corner.clone(), adjust = pos.adjusted, method = api.options.position.adjust.method.split(" "), horizontal = method[0], vertical = method[1] || method[0], shift = {
                    left: FALSE,
                    top: FALSE,
                    x: 0,
                    y: 0
                }, offset, css = {}, props;
                function shiftflip(direction, precedance, popposite, side, opposite) {
                    if (direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {
                        newCorner.precedance = newCorner.precedance === X ? Y : X;
                    } else if (direction !== SHIFT && adjust[side]) {
                        newCorner[precedance] = newCorner[precedance] === CENTER ? adjust[side] > 0 ? side : opposite : newCorner[precedance] === side ? opposite : side;
                    }
                }
                function shiftonly(xy, side, opposite) {
                    if (newCorner[xy] === CENTER) {
                        css[MARGIN + "-" + side] = shift[xy] = offset[MARGIN + "-" + side] - adjust[side];
                    } else {
                        props = offset[opposite] !== undefined ? [ adjust[side], -offset[side] ] : [ -adjust[side], offset[side] ];
                        if ((shift[xy] = Math.max(props[0], props[1])) > props[0]) {
                            pos[side] -= adjust[side];
                            shift[side] = FALSE;
                        }
                        css[offset[opposite] !== undefined ? opposite : side] = shift[xy];
                    }
                }
                if (this.corner.fixed !== TRUE) {
                    shiftflip(horizontal, X, Y, LEFT, RIGHT);
                    shiftflip(vertical, Y, X, TOP, BOTTOM);
                    if (newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {
                        this.update(newCorner, FALSE);
                    }
                }
                offset = this.calculate(newCorner);
                if (offset.right !== undefined) {
                    offset.left = -offset.right;
                }
                if (offset.bottom !== undefined) {
                    offset.top = -offset.bottom;
                }
                offset.user = this.offset;
                if (shift.left = horizontal === SHIFT && !!adjust.left) {
                    shiftonly(X, LEFT, RIGHT);
                }
                if (shift.top = vertical === SHIFT && !!adjust.top) {
                    shiftonly(Y, TOP, BOTTOM);
                }
                this.element.css(css).toggle(!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x));
                pos.left -= offset.left.charAt ? offset.user : horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;
                pos.top -= offset.top.charAt ? offset.user : vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;
                cache.cornerLeft = adjust.left;
                cache.cornerTop = adjust.top;
                cache.corner = newCorner.clone();
            },
            destroy: function() {
                this.qtip._unbind(this.qtip.tooltip, this._ns);
                if (this.qtip.elements.tip) {
                    this.qtip.elements.tip.find("*").remove().end().remove();
                }
            }
        });
        TIP = PLUGINS.tip = function(api) {
            return new Tip(api, api.options.style.tip);
        };
        TIP.initialize = "render";
        TIP.sanitize = function(options) {
            if (options.style && "tip" in options.style) {
                var opts = options.style.tip;
                if (typeof opts !== "object") {
                    opts = options.style.tip = {
                        corner: opts
                    };
                }
                if (!/string|boolean/i.test(typeof opts.corner)) {
                    opts.corner = TRUE;
                }
            }
        };
        CHECKS.tip = {
            "^position.my|style.tip.(corner|mimic|border)$": function() {
                this.create();
                this.qtip.reposition();
            },
            "^style.tip.(height|width)$": function(obj) {
                this.size = [ obj.width, obj.height ];
                this.update();
                this.qtip.reposition();
            },
            "^content.title|style.(classes|widget)$": function() {
                this.update();
            }
        };
        $.extend(TRUE, QTIP.defaults, {
            style: {
                tip: {
                    corner: TRUE,
                    mimic: FALSE,
                    width: 6,
                    height: 6,
                    border: TRUE,
                    offset: 0
                }
            }
        });
        PLUGINS.viewport = function(api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight) {
            var target = posOptions.target, tooltip = api.elements.tooltip, my = posOptions.my, at = posOptions.at, adjust = posOptions.adjust, method = adjust.method.split(" "), methodX = method[0], methodY = method[1] || method[0], viewport = posOptions.viewport, container = posOptions.container, cache = api.cache, adjusted = {
                left: 0,
                top: 0
            }, fixed, newMy, containerOffset, containerStatic, viewportWidth, viewportHeight, viewportScroll, viewportOffset;
            if (!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === "none") {
                return adjusted;
            }
            containerOffset = container.offset() || adjusted;
            containerStatic = container.css("position") === "static";
            fixed = tooltip.css("position") === "fixed";
            viewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);
            viewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);
            viewportScroll = {
                left: fixed ? 0 : viewport.scrollLeft(),
                top: fixed ? 0 : viewport.scrollTop()
            };
            viewportOffset = viewport.offset() || adjusted;
            function calculate(side, otherSide, type, adjust, side1, side2, lengthName, targetLength, elemLength) {
                var initialPos = position[side1], mySide = my[side], atSide = at[side], isShift = type === SHIFT, myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2, atLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2, sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]), overflow1 = sideOffset - initialPos, overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset, offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0);
                if (isShift) {
                    offset = (mySide === side1 ? 1 : -1) * myLength;
                    position[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;
                    position[side1] = Math.max(-containerOffset[side1] + viewportOffset[side1], initialPos - offset, Math.min(Math.max(-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight), initialPos + offset), position[side1], mySide === "center" ? initialPos - myLength : 1e9));
                } else {
                    adjust *= type === FLIPINVERT ? 2 : 0;
                    if (overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {
                        position[side1] -= offset + adjust;
                        newMy.invert(side, side1);
                    } else if (overflow2 > 0 && (mySide !== side2 || overflow1 > 0)) {
                        position[side1] -= (mySide === CENTER ? -offset : offset) + adjust;
                        newMy.invert(side, side2);
                    }
                    if (position[side1] < viewportScroll && -position[side1] > overflow2) {
                        position[side1] = initialPos;
                        newMy = my.clone();
                    }
                }
                return position[side1] - initialPos;
            }
            if (methodX !== "shift" || methodY !== "shift") {
                newMy = my.clone();
            }
            adjusted = {
                left: methodX !== "none" ? calculate(X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth) : 0,
                top: methodY !== "none" ? calculate(Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight) : 0,
                my: newMy
            };
            return adjusted;
        };
    });
})(window, document);

$.fn.serializeObject = function() {
    var o = {};
    var a = this.find(":input").serializeArray();
    $.each(a, function() {
        if (this.value == "true") {
            this.value = true;
        } else if (this.value == "false") {
            this.value = false;
        } else if (this.value === undefined) {
            this.value = "";
        }
        if (o[this.name] !== undefined) {
            if (!o[this.name].push) {
                o[this.name] = [ o[this.name] ];
            }
            o[this.name].push(this.value);
        } else {
            o[this.name] = this.value;
        }
    });
    return o;
};

(function(factory) {
    if (typeof exports === "object" && exports && typeof module === "object" && module && module.exports === exports) {
        factory(require("jquery"));
    } else if (typeof define === "function" && define.amd) {
        define([ "jquery" ], factory);
    } else {
        factory(jQuery);
    }
})(function($) {
    var _baseDate = _generateBaseDate();
    var _ONE_DAY = 86400;
    var _lang = {
        am: "am",
        pm: "pm",
        AM: "AM",
        PM: "PM",
        decimal: ".",
        mins: "mins",
        hr: "hr",
        hrs: "hrs"
    };
    var methods = {
        init: function(options) {
            return this.each(function() {
                var self = $(this);
                var attributeOptions = [];
                for (var key in $.fn.timepicker.defaults) {
                    if (self.data(key)) {
                        attributeOptions[key] = self.data(key);
                    }
                }
                var settings = $.extend({}, $.fn.timepicker.defaults, attributeOptions, options);
                if (settings.lang) {
                    _lang = $.extend(_lang, settings.lang);
                }
                settings = _parseSettings(settings);
                self.data("timepicker-settings", settings);
                self.addClass("ui-timepicker-input");
                if (settings.useSelect) {
                    _render(self);
                } else {
                    self.prop("autocomplete", "off");
                    self.on("click.timepicker focus.timepicker", methods.show);
                    self.on("change.timepicker", _formatValue);
                    self.on("keydown.timepicker", _keydownhandler);
                    self.on("keyup.timepicker", _keyuphandler);
                    _formatValue.call(self.get(0));
                }
            });
        },
        show: function(e) {
            var self = $(this);
            var settings = self.data("timepicker-settings");
            if (e) {
                if (!settings.showOnFocus) {
                    return true;
                }
                e.preventDefault();
            }
            if (settings.useSelect) {
                self.data("timepicker-list").focus();
                return;
            }
            if (_hideKeyboard(self)) {
                self.blur();
            }
            var list = self.data("timepicker-list");
            if (self.prop("readonly")) {
                return;
            }
            if (!list || list.length === 0 || typeof settings.durationTime === "function") {
                _render(self);
                list = self.data("timepicker-list");
            }
            if (_isVisible(list)) {
                return;
            }
            methods.hide();
            list.show();
            var listOffset = {};
            if (settings.orientation == "rtl") {
                listOffset.left = self.offset().left + self.outerWidth() - list.outerWidth() + parseInt(list.css("marginLeft").replace("px", ""), 10);
            } else {
                listOffset.left = self.offset().left + parseInt(list.css("marginLeft").replace("px", ""), 10);
            }
            if (self.offset().top + self.outerHeight(true) + list.outerHeight() > $(window).height() + $(window).scrollTop()) {
                list.addClass("ui-timepicker-positioned-top");
                listOffset.top = self.offset().top - list.outerHeight() + parseInt(list.css("marginTop").replace("px", ""), 10);
            } else {
                list.removeClass("ui-timepicker-positioned-top");
                listOffset.top = self.offset().top + self.outerHeight() + parseInt(list.css("marginTop").replace("px", ""), 10);
            }
            list.offset(listOffset);
            var selected = list.find(".ui-timepicker-selected");
            if (!selected.length) {
                if (_getTimeValue(self)) {
                    selected = _findRow(self, list, _time2int(_getTimeValue(self)));
                } else if (settings.scrollDefault) {
                    selected = _findRow(self, list, settings.scrollDefault);
                }
            }
            if (selected && selected.length) {
                var topOffset = list.scrollTop() + selected.position().top - selected.outerHeight();
                list.scrollTop(topOffset);
            } else {
                list.scrollTop(0);
            }
            $(document).on("touchstart.ui-timepicker mousedown.ui-timepicker", _closeHandler);
            if (settings.closeOnWindowScroll) {
                $(document).on("scroll.ui-timepicker", _closeHandler);
            }
            self.trigger("showTimepicker");
            return this;
        },
        hide: function(e) {
            var self = $(this);
            var settings = self.data("timepicker-settings");
            if (settings && settings.useSelect) {
                self.blur();
            }
            $(".ui-timepicker-wrapper").each(function() {
                var list = $(this);
                if (!_isVisible(list)) {
                    return;
                }
                var self = list.data("timepicker-input");
                var settings = self.data("timepicker-settings");
                if (settings && settings.selectOnBlur) {
                    _selectValue(self);
                }
                list.hide();
                self.trigger("hideTimepicker");
            });
            return this;
        },
        option: function(key, value) {
            return this.each(function() {
                var self = $(this);
                var settings = self.data("timepicker-settings");
                var list = self.data("timepicker-list");
                if (typeof key == "object") {
                    settings = $.extend(settings, key);
                } else if (typeof key == "string" && typeof value != "undefined") {
                    settings[key] = value;
                } else if (typeof key == "string") {
                    return settings[key];
                }
                settings = _parseSettings(settings);
                self.data("timepicker-settings", settings);
                if (list) {
                    list.remove();
                    self.data("timepicker-list", false);
                }
                if (settings.useSelect) {
                    _render(self);
                }
            });
        },
        getSecondsFromMidnight: function() {
            return _time2int(_getTimeValue(this));
        },
        getTime: function(relative_date) {
            var self = this;
            var time_string = _getTimeValue(self);
            if (!time_string) {
                return null;
            }
            if (!relative_date) {
                relative_date = new Date();
            }
            var offset = _time2int(time_string);
            var time = new Date(relative_date);
            time.setHours(offset / 3600);
            time.setMinutes(offset % 3600 / 60);
            time.setSeconds(offset % 60);
            time.setMilliseconds(0);
            return time;
        },
        setTime: function(value) {
            var self = this;
            var settings = self.data("timepicker-settings");
            if (settings.forceRoundTime) {
                var prettyTime = _roundAndFormatTime(value, settings);
            } else {
                var prettyTime = _int2time(_time2int(value), settings.timeFormat);
            }
            _setTimeValue(self, prettyTime);
            if (self.data("timepicker-list")) {
                _setSelected(self, self.data("timepicker-list"));
            }
            return this;
        },
        remove: function() {
            var self = this;
            if (!self.hasClass("ui-timepicker-input")) {
                return;
            }
            var settings = self.data("timepicker-settings");
            self.removeAttr("autocomplete", "off");
            self.removeClass("ui-timepicker-input");
            self.removeData("timepicker-settings");
            self.off(".timepicker");
            if (self.data("timepicker-list")) {
                self.data("timepicker-list").remove();
            }
            if (settings.useSelect) {
                self.show();
            }
            self.removeData("timepicker-list");
            return this;
        }
    };
    function _isVisible(elem) {
        var el = elem[0];
        return el.offsetWidth > 0 && el.offsetHeight > 0;
    }
    function _parseSettings(settings) {
        if (settings.minTime) {
            settings.minTime = _time2int(settings.minTime);
        }
        if (settings.maxTime) {
            settings.maxTime = _time2int(settings.maxTime);
        }
        if (settings.durationTime && typeof settings.durationTime !== "function") {
            settings.durationTime = _time2int(settings.durationTime);
        }
        if (settings.scrollDefault == "now") {
            settings.scrollDefault = _time2int(new Date());
        } else if (settings.scrollDefault) {
            settings.scrollDefault = _time2int(settings.scrollDefault);
        } else if (settings.minTime) {
            settings.scrollDefault = settings.minTime;
        }
        if (settings.scrollDefault) {
            settings.scrollDefault = _roundTime(settings.scrollDefault, settings);
        }
        if ($.type(settings.timeFormat) === "string" && settings.timeFormat.match(/[gh]/)) {
            settings._twelveHourTime = true;
        }
        if (settings.disableTimeRanges.length > 0) {
            for (var i in settings.disableTimeRanges) {
                settings.disableTimeRanges[i] = [ _time2int(settings.disableTimeRanges[i][0]), _time2int(settings.disableTimeRanges[i][1]) ];
            }
            settings.disableTimeRanges = settings.disableTimeRanges.sort(function(a, b) {
                return a[0] - b[0];
            });
            for (var i = settings.disableTimeRanges.length - 1; i > 0; i--) {
                if (settings.disableTimeRanges[i][0] <= settings.disableTimeRanges[i - 1][1]) {
                    settings.disableTimeRanges[i - 1] = [ Math.min(settings.disableTimeRanges[i][0], settings.disableTimeRanges[i - 1][0]), Math.max(settings.disableTimeRanges[i][1], settings.disableTimeRanges[i - 1][1]) ];
                    settings.disableTimeRanges.splice(i, 1);
                }
            }
        }
        return settings;
    }
    function _render(self) {
        var settings = self.data("timepicker-settings");
        var list = self.data("timepicker-list");
        if (list && list.length) {
            list.remove();
            self.data("timepicker-list", false);
        }
        if (settings.useSelect) {
            list = $("<select />", {
                class: "ui-timepicker-select"
            });
            var wrapped_list = list;
        } else {
            list = $("<ul />", {
                class: "ui-timepicker-list"
            });
            var wrapped_list = $("<div />", {
                class: "ui-timepicker-wrapper",
                tabindex: -1
            });
            wrapped_list.css({
                display: "none",
                position: "absolute"
            }).append(list);
        }
        if (settings.noneOption) {
            if (settings.noneOption === true) {
                settings.noneOption = settings.useSelect ? "Time..." : "None";
            }
            if ($.isArray(settings.noneOption)) {
                for (var i in settings.noneOption) {
                    if (parseInt(i, 10) == i) {
                        var noneElement = _generateNoneElement(settings.noneOption[i], settings.useSelect);
                        list.append(noneElement);
                    }
                }
            } else {
                var noneElement = _generateNoneElement(settings.noneOption, settings.useSelect);
                list.append(noneElement);
            }
        }
        if (settings.className) {
            wrapped_list.addClass(settings.className);
        }
        if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {
            wrapped_list.addClass("ui-timepicker-with-duration");
            wrapped_list.addClass("ui-timepicker-step-" + settings.step);
        }
        var durStart = settings.minTime;
        if (typeof settings.durationTime === "function") {
            durStart = _time2int(settings.durationTime());
        } else if (settings.durationTime !== null) {
            durStart = settings.durationTime;
        }
        var start = settings.minTime !== null ? settings.minTime : 0;
        var end = settings.maxTime !== null ? settings.maxTime : start + _ONE_DAY - 1;
        if (end <= start) {
            end += _ONE_DAY;
        }
        if (end === _ONE_DAY - 1 && $.type(settings.timeFormat) === "string" && settings.timeFormat.indexOf("H") !== -1) {
            end = _ONE_DAY;
        }
        var dr = settings.disableTimeRanges;
        var drCur = 0;
        var drLen = dr.length;
        for (var i = start; i <= end; i += settings.step * 60) {
            var timeInt = i;
            var timeString = _int2time(timeInt, settings.timeFormat);
            if (settings.useSelect) {
                var row = $("<option />", {
                    value: timeString
                });
                row.text(timeString);
            } else {
                var row = $("<li />");
                row.data("time", timeInt <= 86400 ? timeInt : timeInt % 86400);
                row.text(timeString);
            }
            if ((settings.minTime !== null || settings.durationTime !== null) && settings.showDuration) {
                var durationString = _int2duration(i - durStart, settings.step);
                if (settings.useSelect) {
                    row.text(row.text() + " (" + durationString + ")");
                } else {
                    var duration = $("<span />", {
                        class: "ui-timepicker-duration"
                    });
                    duration.text(" (" + durationString + ")");
                    row.append(duration);
                }
            }
            if (drCur < drLen) {
                if (timeInt >= dr[drCur][1]) {
                    drCur += 1;
                }
                if (dr[drCur] && timeInt >= dr[drCur][0] && timeInt < dr[drCur][1]) {
                    if (settings.useSelect) {
                        row.prop("disabled", true);
                    } else {
                        row.addClass("ui-timepicker-disabled");
                    }
                }
            }
            list.append(row);
        }
        wrapped_list.data("timepicker-input", self);
        self.data("timepicker-list", wrapped_list);
        if (settings.useSelect) {
            if (self.val()) {
                list.val(_roundAndFormatTime(self.val(), settings));
            }
            list.on("focus", function() {
                $(this).data("timepicker-input").trigger("showTimepicker");
            });
            list.on("blur", function() {
                $(this).data("timepicker-input").trigger("hideTimepicker");
            });
            list.on("change", function() {
                _setTimeValue(self, $(this).val(), "select");
            });
            _setTimeValue(self, list.val());
            self.hide().after(list);
        } else {
            var appendTo = settings.appendTo;
            if (typeof appendTo === "string") {
                appendTo = $(appendTo);
            } else if (typeof appendTo === "function") {
                appendTo = appendTo(self);
            }
            appendTo.append(wrapped_list);
            _setSelected(self, list);
            list.on("mousedown", "li", function(e) {
                self.off("focus.timepicker");
                self.on("focus.timepicker-ie-hack", function() {
                    self.off("focus.timepicker-ie-hack");
                    self.on("focus.timepicker", methods.show);
                });
                if (!_hideKeyboard(self)) {
                    self[0].focus();
                }
                list.find("li").removeClass("ui-timepicker-selected");
                $(this).addClass("ui-timepicker-selected");
                if (_selectValue(self)) {
                    self.trigger("hideTimepicker");
                    wrapped_list.hide();
                }
            });
        }
    }
    function _generateNoneElement(optionValue, useSelect) {
        var label, className, value;
        if (typeof optionValue == "object") {
            label = optionValue.label;
            className = optionValue.className;
            value = optionValue.value;
        } else if (typeof optionValue == "string") {
            label = optionValue;
        } else {
            $.error("Invalid noneOption value");
        }
        if (useSelect) {
            return $("<option />", {
                value: value,
                class: className,
                text: label
            });
        } else {
            return $("<li />", {
                class: className,
                text: label
            }).data("time", value);
        }
    }
    function _roundTime(seconds, settings) {
        if (!$.isNumeric(seconds)) {
            seconds = _time2int(seconds);
        }
        if (seconds === null) {
            return null;
        } else {
            var offset = seconds % (settings.step * 60);
            if (offset >= settings.step * 30) {
                seconds += settings.step * 60 - offset;
            } else {
                seconds -= offset;
            }
            return seconds;
        }
    }
    function _roundAndFormatTime(seconds, settings) {
        seconds = _roundTime(seconds, settings);
        if (seconds !== null) {
            return _int2time(seconds, settings.timeFormat);
        }
    }
    function _generateBaseDate() {
        return new Date(1970, 1, 1, 0, 0, 0);
    }
    function _closeHandler(e) {
        var target = $(e.target);
        var input = target.closest(".ui-timepicker-input");
        if (input.length === 0 && target.closest(".ui-timepicker-wrapper").length === 0) {
            methods.hide();
            $(document).unbind(".ui-timepicker");
        }
    }
    function _hideKeyboard(self) {
        var settings = self.data("timepicker-settings");
        return (window.navigator.msMaxTouchPoints || "ontouchstart" in document) && settings.disableTouchKeyboard;
    }
    function _findRow(self, list, value) {
        if (!value && value !== 0) {
            return false;
        }
        var settings = self.data("timepicker-settings");
        var out = false;
        var halfStep = settings.step * 30;
        list.find("li").each(function(i, obj) {
            var jObj = $(obj);
            if (typeof jObj.data("time") != "number") {
                return;
            }
            var offset = jObj.data("time") - value;
            if (Math.abs(offset) < halfStep || offset == halfStep) {
                out = jObj;
                return false;
            }
        });
        return out;
    }
    function _setSelected(self, list) {
        list.find("li").removeClass("ui-timepicker-selected");
        var timeValue = _time2int(_getTimeValue(self), self.data("timepicker-settings"));
        if (timeValue === null) {
            return;
        }
        var selected = _findRow(self, list, timeValue);
        if (selected) {
            var topDelta = selected.offset().top - list.offset().top;
            if (topDelta + selected.outerHeight() > list.outerHeight() || topDelta < 0) {
                list.scrollTop(list.scrollTop() + selected.position().top - selected.outerHeight());
            }
            selected.addClass("ui-timepicker-selected");
        }
    }
    function _formatValue(e, origin) {
        if (this.value === "" || origin == "timepicker") {
            return;
        }
        var self = $(this);
        var list = self.data("timepicker-list");
        if (self.is(":focus") && (!e || e.type != "change")) {
            return;
        }
        var seconds = _time2int(this.value);
        if (seconds === null) {
            self.trigger("timeFormatError");
            return;
        }
        var settings = self.data("timepicker-settings");
        var rangeError = false;
        if (settings.minTime !== null && seconds < settings.minTime) {
            rangeError = true;
        } else if (settings.maxTime !== null && seconds > settings.maxTime) {
            rangeError = true;
        }
        $.each(settings.disableTimeRanges, function() {
            if (seconds >= this[0] && seconds < this[1]) {
                rangeError = true;
                return false;
            }
        });
        if (settings.forceRoundTime) {
            var offset = seconds % (settings.step * 60);
            if (offset >= settings.step * 30) {
                seconds += settings.step * 60 - offset;
            } else {
                seconds -= offset;
            }
        }
        var prettyTime = _int2time(seconds, settings.timeFormat);
        if (rangeError) {
            if (_setTimeValue(self, prettyTime, "error")) {
                self.trigger("timeRangeError");
            }
        } else {
            _setTimeValue(self, prettyTime);
        }
    }
    function _getTimeValue(self) {
        if (self.is("input")) {
            return self.val();
        } else {
            return self.data("ui-timepicker-value");
        }
    }
    function _setTimeValue(self, value, source) {
        if (self.is("input")) {
            self.val(value);
            var settings = self.data("timepicker-settings");
            if (settings.useSelect && source != "select") {
                self.data("timepicker-list").val(_roundAndFormatTime(value, settings));
            }
        }
        if (self.data("ui-timepicker-value") != value) {
            self.data("ui-timepicker-value", value);
            if (source == "select") {
                self.trigger("selectTime").trigger("changeTime").trigger("change", "timepicker");
            } else if (source != "error") {
                self.trigger("changeTime");
            }
            return true;
        } else {
            self.trigger("selectTime");
            return false;
        }
    }
    function _keydownhandler(e) {
        var self = $(this);
        var list = self.data("timepicker-list");
        if (!list || !_isVisible(list)) {
            if (e.keyCode == 40) {
                methods.show.call(self.get(0));
                list = self.data("timepicker-list");
                if (!_hideKeyboard(self)) {
                    self.focus();
                }
            } else {
                return true;
            }
        }
        switch (e.keyCode) {
          case 13:
            if (_selectValue(self)) {
                methods.hide.apply(this);
            }
            e.preventDefault();
            return false;

          case 38:
            var selected = list.find(".ui-timepicker-selected");
            if (!selected.length) {
                list.find("li").each(function(i, obj) {
                    if ($(obj).position().top > 0) {
                        selected = $(obj);
                        return false;
                    }
                });
                selected.addClass("ui-timepicker-selected");
            } else if (!selected.is(":first-child")) {
                selected.removeClass("ui-timepicker-selected");
                selected.prev().addClass("ui-timepicker-selected");
                if (selected.prev().position().top < selected.outerHeight()) {
                    list.scrollTop(list.scrollTop() - selected.outerHeight());
                }
            }
            return false;

          case 40:
            selected = list.find(".ui-timepicker-selected");
            if (selected.length === 0) {
                list.find("li").each(function(i, obj) {
                    if ($(obj).position().top > 0) {
                        selected = $(obj);
                        return false;
                    }
                });
                selected.addClass("ui-timepicker-selected");
            } else if (!selected.is(":last-child")) {
                selected.removeClass("ui-timepicker-selected");
                selected.next().addClass("ui-timepicker-selected");
                if (selected.next().position().top + 2 * selected.outerHeight() > list.outerHeight()) {
                    list.scrollTop(list.scrollTop() + selected.outerHeight());
                }
            }
            return false;

          case 27:
            list.find("li").removeClass("ui-timepicker-selected");
            methods.hide();
            break;

          case 9:
            methods.hide();
            break;

          default:
            return true;
        }
    }
    function _keyuphandler(e) {
        var self = $(this);
        var list = self.data("timepicker-list");
        if (!list || !_isVisible(list)) {
            return true;
        }
        if (!self.data("timepicker-settings").typeaheadHighlight) {
            list.find("li").removeClass("ui-timepicker-selected");
            return true;
        }
        switch (e.keyCode) {
          case 96:
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 65:
          case 77:
          case 80:
          case 186:
          case 8:
          case 46:
            _setSelected(self, list);
            break;

          default:
            return;
        }
    }
    function _selectValue(self) {
        var settings = self.data("timepicker-settings");
        var list = self.data("timepicker-list");
        var timeValue = null;
        var cursor = list.find(".ui-timepicker-selected");
        if (cursor.hasClass("ui-timepicker-disabled")) {
            return false;
        }
        if (cursor.length) {
            timeValue = cursor.data("time");
        }
        if (timeValue !== null) {
            if (typeof timeValue == "string") {
                self.val(timeValue);
                self.trigger("selectTime").trigger("changeTime").trigger("change", "timepicker");
            } else {
                var timeString = _int2time(timeValue, settings.timeFormat);
                _setTimeValue(self, timeString, "select");
            }
        }
        return true;
    }
    function _int2duration(seconds, step) {
        seconds = Math.abs(seconds);
        var minutes = Math.round(seconds / 60), duration = [], hours, mins;
        if (minutes < 60) {
            duration = [ minutes, _lang.mins ];
        } else {
            hours = Math.floor(minutes / 60);
            mins = minutes % 60;
            if (step == 30 && mins == 30) {
                hours += _lang.decimal + 5;
            }
            duration.push(hours);
            duration.push(hours == 1 ? _lang.hr : _lang.hrs);
            if (step != 30 && mins) {
                duration.push(mins);
                duration.push(_lang.mins);
            }
        }
        return duration.join(" ");
    }
    function _int2time(seconds, format) {
        if (seconds === null) {
            return;
        }
        var time = new Date(_baseDate.valueOf() + seconds * 1e3);
        if (isNaN(time.getTime())) {
            return;
        }
        if ($.type(format) === "function") {
            return format(time);
        }
        var output = "";
        var hour, code;
        for (var i = 0; i < format.length; i++) {
            code = format.charAt(i);
            switch (code) {
              case "a":
                output += time.getHours() > 11 ? _lang.pm : _lang.am;
                break;

              case "A":
                output += time.getHours() > 11 ? _lang.pm.toUpperCase() : _lang.am.toUpperCase();
                break;

              case "g":
                hour = time.getHours() % 12;
                output += hour === 0 ? "12" : hour;
                break;

              case "G":
                output += time.getHours();
                break;

              case "h":
                hour = time.getHours() % 12;
                if (hour !== 0 && hour < 10) {
                    hour = "0" + hour;
                }
                output += hour === 0 ? "12" : hour;
                break;

              case "H":
                hour = time.getHours();
                if (seconds === _ONE_DAY) hour = 24;
                output += hour > 9 ? hour : "0" + hour;
                break;

              case "i":
                var minutes = time.getMinutes();
                output += minutes > 9 ? minutes : "0" + minutes;
                break;

              case "s":
                seconds = time.getSeconds();
                output += seconds > 9 ? seconds : "0" + seconds;
                break;

              case "\\":
                i++;
                output += format.charAt(i);
                break;

              default:
                output += code;
            }
        }
        return output;
    }
    function _time2int(timeString, settings) {
        if (timeString === "") return null;
        if (!timeString || timeString + 0 == timeString) return timeString;
        if (typeof timeString == "object") {
            return timeString.getHours() * 3600 + timeString.getMinutes() * 60 + timeString.getSeconds();
        }
        timeString = timeString.toLowerCase();
        if (timeString.slice(-1) == "a" || timeString.slice(-1) == "p") {
            timeString += "m";
        }
        var pattern = new RegExp("^([0-2]?[0-9])\\W?([0-5][0-9])?\\W?([0-5][0-9])?\\s*(" + _lang.am + "|" + _lang.pm + ")?$");
        var time = timeString.match(pattern);
        if (!time) {
            return null;
        }
        var hour = parseInt(time[1] * 1, 10);
        var ampm = time[4];
        var hours = hour;
        if (hour <= 12 && ampm) {
            if (hour == 12) {
                hours = time[4] == _lang.pm ? 12 : 0;
            } else {
                hours = hour + (time[4] == _lang.pm ? 12 : 0);
            }
        }
        var minutes = time[2] * 1 || 0;
        var seconds = time[3] * 1 || 0;
        var timeInt = hours * 3600 + minutes * 60 + seconds;
        if (!ampm && settings && settings._twelveHourTime && settings.scrollDefault) {
            var delta = timeInt - settings.scrollDefault;
            if (delta < 0 && delta >= _ONE_DAY / -2) {
                timeInt = (timeInt + _ONE_DAY / 2) % _ONE_DAY;
            }
        }
        return timeInt;
    }
    function _pad2(n) {
        return ("0" + n).slice(-2);
    }
    $.fn.timepicker = function(method) {
        if (!this.length) return this;
        if (methods[method]) {
            if (!this.hasClass("ui-timepicker-input")) {
                return this;
            }
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === "object" || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error("Method " + method + " does not exist on jQuery.timepicker");
        }
    };
    $.fn.timepicker.defaults = {
        className: null,
        minTime: null,
        maxTime: null,
        durationTime: null,
        step: 30,
        showDuration: false,
        showOnFocus: true,
        timeFormat: "g:ia",
        scrollDefault: null,
        selectOnBlur: false,
        disableTouchKeyboard: false,
        forceRoundTime: false,
        appendTo: "body",
        orientation: "ltr",
        disableTimeRanges: [],
        closeOnWindowScroll: false,
        typeaheadHighlight: true,
        noneOption: false
    };
});

(function(root) {
    var serverSide = typeof module !== "undefined" && module.exports;
    var getnlp = function() {
        if (!getnlp._nlp) {
            if (serverSide) {
                getnlp._nlp = require("./nlp");
            } else if (!(getnlp._nlp = root._RRuleNLP)) {
                throw new Error("You need to include rrule/nlp.js for fromText/toText to work.");
            }
        }
        return getnlp._nlp;
    };
    var dateutil = {
        MONTH_DAYS: [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ],
        ONE_DAY: 1e3 * 60 * 60 * 24,
        MAXYEAR: 9999,
        ORDINAL_BASE: new Date(1970, 0, 1),
        PY_WEEKDAYS: [ 6, 0, 1, 2, 3, 4, 5 ],
        getYearDay: function(date) {
            var dateNoTime = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            return Math.ceil((dateNoTime - new Date(date.getFullYear(), 0, 1)) / dateutil.ONE_DAY) + 1;
        },
        isLeapYear: function(year) {
            if (year instanceof Date) {
                year = year.getFullYear();
            }
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },
        tzOffset: function(date) {
            return date.getTimezoneOffset() * 60 * 1e3;
        },
        daysBetween: function(date1, date2) {
            var date1_ms = date1.getTime() - dateutil.tzOffset(date1);
            var date2_ms = date2.getTime() - dateutil.tzOffset(date2);
            var difference_ms = Math.abs(date1_ms - date2_ms);
            return Math.round(difference_ms / dateutil.ONE_DAY);
        },
        toOrdinal: function(date) {
            return dateutil.daysBetween(date, dateutil.ORDINAL_BASE);
        },
        fromOrdinal: function(ordinal) {
            var millisecsFromBase = ordinal * dateutil.ONE_DAY;
            return new Date(dateutil.ORDINAL_BASE.getTime() - dateutil.tzOffset(dateutil.ORDINAL_BASE) + millisecsFromBase + dateutil.tzOffset(new Date(millisecsFromBase)));
        },
        monthRange: function(year, month) {
            var date = new Date(year, month, 1);
            return [ dateutil.getWeekday(date), dateutil.getMonthDays(date) ];
        },
        getMonthDays: function(date) {
            var month = date.getMonth();
            return month == 1 && dateutil.isLeapYear(date) ? 29 : dateutil.MONTH_DAYS[month];
        },
        getWeekday: function(date) {
            return dateutil.PY_WEEKDAYS[date.getDay()];
        },
        combine: function(date, time) {
            time = time || date;
            return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds());
        },
        clone: function(date) {
            var dolly = new Date(date.getTime());
            dolly.setMilliseconds(0);
            return dolly;
        },
        cloneDates: function(dates) {
            var clones = [];
            for (var i = 0; i < dates.length; i++) {
                clones.push(dateutil.clone(dates[i]));
            }
            return clones;
        },
        sort: function(dates) {
            dates.sort(function(a, b) {
                return a.getTime() - b.getTime();
            });
        },
        timeToUntilString: function(time, onlyDate) {
            var date = new Date(time);
            var compsUsed, comp, comps = [ date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), "T", date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), "Z" ];
            compsUsed = comps.length;
            if (onlyDate) {
                compsUsed = 3;
            }
            comps = comps.slice(0, compsUsed);
            for (var i = 0; i < compsUsed; i++) {
                comp = comps[i];
                if (!/[TZ]/.test(comp) && comp < 10) {
                    comps[i] = "0" + String(comp);
                }
            }
            return comps.join("");
        },
        untilStringToDate: function(until) {
            var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z)?$/;
            var bits = re.exec(until);
            if (!bits) {
                throw new Error("Invalid UNTIL value: " + until);
            }
            return new Date(Date.UTC(bits[1], bits[2] - 1, bits[3], bits[5] || 0, bits[6] || 0, bits[7] || 0));
        },
        hasOnlyDate: function(until) {
            return !/T/.test(until);
        }
    };
    dateutil.Time = function(hour, minute, second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    };
    dateutil.Time.prototype = {
        getHours: function() {
            return this.hour;
        },
        getMinutes: function() {
            return this.minute;
        },
        getSeconds: function() {
            return this.second;
        },
        getTime: function() {
            return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3;
        }
    };
    var range = function(start, end) {
        if (arguments.length === 1) {
            end = start;
            start = 0;
        }
        var rang = [];
        for (var i = start; i < end; i++) {
            rang.push(i);
        }
        return rang;
    };
    var repeat = function(value, times) {
        var i = 0, array = [];
        if (value instanceof Array) {
            for (;i < times; i++) {
                array[i] = [].concat(value);
            }
        } else {
            for (;i < times; i++) {
                array[i] = value;
            }
        }
        return array;
    };
    var pymod = function(a, b) {
        var r = a % b;
        return r * b < 0 ? r + b : r;
    };
    var divmod = function(a, b) {
        return {
            div: Math.floor(a / b),
            mod: pymod(a, b)
        };
    };
    var plb = function(obj) {
        return obj instanceof Array && obj.length == 0 ? false : Boolean(obj);
    };
    var contains = function(arr, val) {
        return arr.indexOf(val) != -1;
    };
    var M365MASK = [].concat(repeat(1, 31), repeat(2, 28), repeat(3, 31), repeat(4, 30), repeat(5, 31), repeat(6, 30), repeat(7, 31), repeat(8, 31), repeat(9, 30), repeat(10, 31), repeat(11, 30), repeat(12, 31), repeat(1, 7));
    var M366MASK = [].concat(repeat(1, 31), repeat(2, 29), repeat(3, 31), repeat(4, 30), repeat(5, 31), repeat(6, 30), repeat(7, 31), repeat(8, 31), repeat(9, 30), repeat(10, 31), repeat(11, 30), repeat(12, 31), repeat(1, 7));
    var M28 = range(1, 29), M29 = range(1, 30), M30 = range(1, 31), M31 = range(1, 32);
    var MDAY366MASK = [].concat(M31, M29, M31, M30, M31, M30, M31, M31, M30, M31, M30, M31, M31.slice(0, 7));
    var MDAY365MASK = [].concat(M31, M28, M31, M30, M31, M30, M31, M31, M30, M31, M30, M31, M31.slice(0, 7));
    M28 = range(-28, 0);
    M29 = range(-29, 0);
    M30 = range(-30, 0);
    M31 = range(-31, 0);
    var NMDAY366MASK = [].concat(M31, M29, M31, M30, M31, M30, M31, M31, M30, M31, M30, M31, M31.slice(0, 7));
    var NMDAY365MASK = [].concat(M31, M28, M31, M30, M31, M30, M31, M31, M30, M31, M30, M31, M31.slice(0, 7));
    var M366RANGE = [ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 ];
    var M365RANGE = [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 ];
    var WDAYMASK = function() {
        for (var wdaymask = [], i = 0; i < 55; i++) {
            wdaymask = wdaymask.concat(range(7));
        }
        return wdaymask;
    }();
    var Weekday = function(weekday, n) {
        if (n === 0) {
            throw new Error("Can't create weekday with n == 0");
        }
        this.weekday = weekday;
        this.n = n;
    };
    Weekday.prototype = {
        nth: function(n) {
            return this.n == n ? this : new Weekday(this.weekday, n);
        },
        equals: function(other) {
            return this.weekday == other.weekday && this.n == other.n;
        },
        toString: function() {
            var s = [ "MO", "TU", "WE", "TH", "FR", "SA", "SU" ][this.weekday];
            if (this.n) {
                s = (this.n > 0 ? "+" : "") + String(this.n) + s;
            }
            return s;
        },
        getJsWeekday: function() {
            return this.weekday == 6 ? 0 : this.weekday + 1;
        }
    };
    var RRule = function(options, noCache) {
        this._string = null;
        options = options || {};
        this._cache = noCache ? null : {
            all: false,
            before: [],
            after: [],
            between: []
        };
        this.origOptions = {};
        var invalid = [], keys = Object.keys(options), defaultKeys = Object.keys(RRule.DEFAULT_OPTIONS);
        keys.forEach(function(key) {
            this.origOptions[key] = options[key];
            if (!contains(defaultKeys, key)) invalid.push(key);
        }, this);
        if (invalid.length) {
            throw new Error("Invalid options: " + invalid.join(", "));
        }
        if (!RRule.FREQUENCIES[options.freq] && options.byeaster === null) {
            throw new Error("Invalid frequency: " + String(options.freq));
        }
        defaultKeys.forEach(function(key) {
            if (!contains(keys, key)) options[key] = RRule.DEFAULT_OPTIONS[key];
        });
        var opts = this.options = options;
        if (opts.byeaster !== null) {
            opts.freq = RRule.YEARLY;
        }
        if (!opts.dtstart) {
            opts.dtstart = new Date();
            opts.dtstart.setMilliseconds(0);
        }
        if (opts.wkst === null) {
            opts.wkst = RRule.MO.weekday;
        } else if (typeof opts.wkst == "number") {} else {
            opts.wkst = opts.wkst.weekday;
        }
        if (opts.bysetpos !== null) {
            if (typeof opts.bysetpos == "number") {
                opts.bysetpos = [ opts.bysetpos ];
            }
            for (var i = 0; i < opts.bysetpos.length; i++) {
                var v = opts.bysetpos[i];
                if (v == 0 || !(-366 <= v && v <= 366)) {
                    throw new Error("bysetpos must be between 1 and 366," + " or between -366 and -1");
                }
            }
        }
        if (!(plb(opts.byweekno) || plb(opts.byyearday) || plb(opts.bymonthday) || opts.byweekday !== null || opts.byeaster !== null)) {
            switch (opts.freq) {
              case RRule.YEARLY:
                if (!opts.bymonth) {
                    opts.bymonth = opts.dtstart.getMonth() + 1;
                }
                opts.bymonthday = opts.dtstart.getDate();
                break;

              case RRule.MONTHLY:
                opts.bymonthday = opts.dtstart.getDate();
                break;

              case RRule.WEEKLY:
                opts.byweekday = dateutil.getWeekday(opts.dtstart);
                break;
            }
        }
        if (opts.bymonth !== null && !(opts.bymonth instanceof Array)) {
            opts.bymonth = [ opts.bymonth ];
        }
        if (opts.byyearday !== null && !(opts.byyearday instanceof Array)) {
            opts.byyearday = [ opts.byyearday ];
        }
        if (opts.bymonthday === null) {
            opts.bymonthday = [];
            opts.bynmonthday = [];
        } else if (opts.bymonthday instanceof Array) {
            var bymonthday = [], bynmonthday = [];
            for (i = 0; i < opts.bymonthday.length; i++) {
                var v = opts.bymonthday[i];
                if (v > 0) {
                    bymonthday.push(v);
                } else if (v < 0) {
                    bynmonthday.push(v);
                }
            }
            opts.bymonthday = bymonthday;
            opts.bynmonthday = bynmonthday;
        } else {
            if (opts.bymonthday < 0) {
                opts.bynmonthday = [ opts.bymonthday ];
                opts.bymonthday = [];
            } else {
                opts.bynmonthday = [];
                opts.bymonthday = [ opts.bymonthday ];
            }
        }
        if (opts.byweekno !== null && !(opts.byweekno instanceof Array)) {
            opts.byweekno = [ opts.byweekno ];
        }
        if (opts.byweekday === null) {
            opts.bynweekday = null;
        } else if (typeof opts.byweekday == "number") {
            opts.byweekday = [ opts.byweekday ];
            opts.bynweekday = null;
        } else if (opts.byweekday instanceof Weekday) {
            if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
                opts.byweekday = [ opts.byweekday.weekday ];
                opts.bynweekday = null;
            } else {
                opts.bynweekday = [ [ opts.byweekday.weekday, opts.byweekday.n ] ];
                opts.byweekday = null;
            }
        } else {
            var byweekday = [], bynweekday = [];
            for (i = 0; i < opts.byweekday.length; i++) {
                var wday = opts.byweekday[i];
                if (typeof wday == "number") {
                    byweekday.push(wday);
                } else if (!wday.n || opts.freq > RRule.MONTHLY) {
                    byweekday.push(wday.weekday);
                } else {
                    bynweekday.push([ wday.weekday, wday.n ]);
                }
            }
            opts.byweekday = plb(byweekday) ? byweekday : null;
            opts.bynweekday = plb(bynweekday) ? bynweekday : null;
        }
        if (opts.byhour === null) {
            opts.byhour = opts.freq < RRule.HOURLY ? [ opts.dtstart.getHours() ] : null;
        } else if (typeof opts.byhour == "number") {
            opts.byhour = [ opts.byhour ];
        }
        if (opts.byminute === null) {
            opts.byminute = opts.freq < RRule.MINUTELY ? [ opts.dtstart.getMinutes() ] : null;
        } else if (typeof opts.byminute == "number") {
            opts.byminute = [ opts.byminute ];
        }
        if (opts.bysecond === null) {
            opts.bysecond = opts.freq < RRule.SECONDLY ? [ opts.dtstart.getSeconds() ] : null;
        } else if (typeof opts.bysecond == "number") {
            opts.bysecond = [ opts.bysecond ];
        }
        if (opts.freq >= RRule.HOURLY) {
            this.timeset = null;
        } else {
            this.timeset = [];
            for (i = 0; i < opts.byhour.length; i++) {
                var hour = opts.byhour[i];
                for (var j = 0; j < opts.byminute.length; j++) {
                    var minute = opts.byminute[j];
                    for (var k = 0; k < opts.bysecond.length; k++) {
                        var second = opts.bysecond[k];
                        this.timeset.push(new dateutil.Time(hour, minute, second));
                    }
                }
            }
            dateutil.sort(this.timeset);
        }
    };
    RRule.FREQUENCIES = [ "YEARLY", "MONTHLY", "WEEKLY", "DAILY", "HOURLY", "MINUTELY", "SECONDLY" ];
    RRule.YEARLY = 0;
    RRule.MONTHLY = 1;
    RRule.WEEKLY = 2;
    RRule.DAILY = 3;
    RRule.HOURLY = 4;
    RRule.MINUTELY = 5;
    RRule.SECONDLY = 6;
    RRule.MO = new Weekday(0);
    RRule.TU = new Weekday(1);
    RRule.WE = new Weekday(2);
    RRule.TH = new Weekday(3);
    RRule.FR = new Weekday(4);
    RRule.SA = new Weekday(5);
    RRule.SU = new Weekday(6);
    RRule.DEFAULT_OPTIONS = {
        freq: null,
        dtstart: null,
        interval: 1,
        wkst: RRule.MO,
        count: null,
        until: null,
        onlydate: false,
        bysetpos: null,
        bymonth: null,
        bymonthday: null,
        byyearday: null,
        byweekno: null,
        byweekday: null,
        byhour: null,
        byminute: null,
        bysecond: null,
        byeaster: null
    };
    RRule.parseText = function(text, language) {
        return getnlp().parseText(text, language);
    };
    RRule.fromText = function(text, language) {
        return getnlp().fromText(text, language);
    };
    RRule.optionsToString = function(options) {
        var key, keys, defaultKeys, value, strValues, onlyDate, pairs = [];
        keys = Object.keys(options);
        defaultKeys = Object.keys(RRule.DEFAULT_OPTIONS);
        onlyDate = options.onlydate;
        for (var i = 0; i < keys.length; i++) {
            if (!contains(defaultKeys, keys[i])) continue;
            key = keys[i].toUpperCase();
            value = options[keys[i]];
            strValues = [];
            if (value === null || value instanceof Array && !value.length) {
                continue;
            }
            switch (key) {
              case "FREQ":
                value = RRule.FREQUENCIES[options.freq];
                break;

              case "WKST":
                value = value.toString();
                break;

              case "BYWEEKDAY":
                key = "BYDAY";
                if (!(value instanceof Array)) {
                    value = [ value ];
                }
                for (var wday, j = 0; j < value.length; j++) {
                    wday = value[j];
                    if (wday instanceof Weekday) {} else if (wday instanceof Array) {
                        wday = new Weekday(wday[0], wday[1]);
                    } else {
                        wday = new Weekday(wday);
                    }
                    strValues[j] = wday.toString();
                }
                value = strValues;
                break;

              case "DTSTART":
              case "UNTIL":
                value = dateutil.timeToUntilString(value, onlyDate);
                break;

              case "ONLYDATE":
                continue;
                break;

              default:
                if (value instanceof Array) {
                    for (var j = 0; j < value.length; j++) {
                        strValues[j] = String(value[j]);
                    }
                    value = strValues;
                } else {
                    value = String(value);
                }
            }
            pairs.push([ key, value ]);
        }
        var strings = [];
        for (var i = 0; i < pairs.length; i++) {
            var attr = pairs[i];
            strings.push(attr[0] + "=" + attr[1].toString());
        }
        return strings.join(";");
    };
    RRule.prototype = {
        all: function(iterator) {
            if (iterator) {
                return this._iter(new CallbackIterResult("all", {}, iterator));
            } else {
                var result = this._cacheGet("all");
                if (result === false) {
                    result = this._iter(new IterResult("all", {}));
                    this._cacheAdd("all", result);
                }
                return result;
            }
        },
        between: function(after, before, inc, iterator) {
            var args = {
                before: before,
                after: after,
                inc: inc
            };
            if (iterator) {
                return this._iter(new CallbackIterResult("between", args, iterator));
            } else {
                var result = this._cacheGet("between", args);
                if (result === false) {
                    result = this._iter(new IterResult("between", args));
                    this._cacheAdd("between", result, args);
                }
                return result;
            }
        },
        before: function(dt, inc) {
            var args = {
                dt: dt,
                inc: inc
            }, result = this._cacheGet("before", args);
            if (result === false) {
                result = this._iter(new IterResult("before", args));
                this._cacheAdd("before", result, args);
            }
            return result;
        },
        after: function(dt, inc) {
            var args = {
                dt: dt,
                inc: inc
            }, result = this._cacheGet("after", args);
            if (result === false) {
                result = this._iter(new IterResult("after", args));
                this._cacheAdd("after", result, args);
            }
            return result;
        },
        count: function() {
            return this.all().length;
        },
        toString: function() {
            return RRule.optionsToString(this.origOptions);
        },
        toText: function(gettext, language) {
            return getnlp().toText(this, gettext, language);
        },
        isFullyConvertibleToText: function() {
            return getnlp().isFullyConvertible(this);
        },
        _cacheAdd: function(what, value, args) {
            if (!this._cache) return;
            if (value) {
                value = value instanceof Date ? dateutil.clone(value) : dateutil.cloneDates(value);
            }
            if (what == "all") {
                this._cache.all = value;
            } else {
                args._value = value;
                this._cache[what].push(args);
            }
        },
        _cacheGet: function(what, args) {
            if (!this._cache) {
                return false;
            }
            var cached = false;
            if (what == "all") {
                cached = this._cache.all;
            } else {
                loopItems: for (var item, i = 0; i < this._cache[what].length; i++) {
                    item = this._cache[what][i];
                    for (var k in args) {
                        if (args.hasOwnProperty(k) && String(args[k]) != String(item[k])) {
                            continue loopItems;
                        }
                    }
                    cached = item._value;
                    break;
                }
            }
            if (!cached && this._cache.all) {
                var iterResult = new IterResult(what, args);
                for (var i = 0; i < this._cache.all.length; i++) {
                    if (!iterResult.accept(this._cache.all[i])) {
                        break;
                    }
                }
                cached = iterResult.getValue();
                this._cacheAdd(what, cached, args);
            }
            return cached instanceof Array ? dateutil.cloneDates(cached) : cached instanceof Date ? dateutil.clone(cached) : cached;
        },
        clone: function() {
            return new RRule(this.origOptions);
        },
        _iter: function(iterResult) {
            var dtstart = this.options.dtstart;
            var year = dtstart.getFullYear(), month = dtstart.getMonth() + 1, day = dtstart.getDate(), hour = dtstart.getHours(), minute = dtstart.getMinutes(), second = dtstart.getSeconds(), weekday = dateutil.getWeekday(dtstart), yearday = dateutil.getYearDay(dtstart);
            var freq = this.options.freq, interval = this.options.interval, wkst = this.options.wkst, until = this.options.until, bymonth = this.options.bymonth, byweekno = this.options.byweekno, byyearday = this.options.byyearday, byweekday = this.options.byweekday, byeaster = this.options.byeaster, bymonthday = this.options.bymonthday, bynmonthday = this.options.bynmonthday, bysetpos = this.options.bysetpos, byhour = this.options.byhour, byminute = this.options.byminute, bysecond = this.options.bysecond;
            var ii = new Iterinfo(this);
            ii.rebuild(year, month);
            var getdayset = {};
            getdayset[RRule.YEARLY] = ii.ydayset;
            getdayset[RRule.MONTHLY] = ii.mdayset;
            getdayset[RRule.WEEKLY] = ii.wdayset;
            getdayset[RRule.DAILY] = ii.ddayset;
            getdayset[RRule.HOURLY] = ii.ddayset;
            getdayset[RRule.MINUTELY] = ii.ddayset;
            getdayset[RRule.SECONDLY] = ii.ddayset;
            getdayset = getdayset[freq];
            var timeset;
            if (freq < RRule.HOURLY) {
                timeset = this.timeset;
            } else {
                var gettimeset = {};
                gettimeset[RRule.HOURLY] = ii.htimeset;
                gettimeset[RRule.MINUTELY] = ii.mtimeset;
                gettimeset[RRule.SECONDLY] = ii.stimeset;
                gettimeset = gettimeset[freq];
                if (freq >= RRule.HOURLY && plb(byhour) && !contains(byhour, hour) || freq >= RRule.MINUTELY && plb(byminute) && !contains(byminute, minute) || freq >= RRule.SECONDLY && plb(bysecond) && !contains(bysecond, minute)) {
                    timeset = [];
                } else {
                    timeset = gettimeset.call(ii, hour, minute, second);
                }
            }
            var filtered, total = 0, count = this.options.count;
            var iterNo = 0;
            var i, j, k, dm, div, mod, tmp, pos, dayset, start, end, fixday;
            while (true) {
                tmp = getdayset.call(ii, year, month, day);
                dayset = tmp[0];
                start = tmp[1];
                end = tmp[2];
                filtered = false;
                for (j = start; j < end; j++) {
                    i = dayset[j];
                    if (plb(bymonth) && !contains(bymonth, ii.mmask[i]) || plb(byweekno) && !ii.wnomask[i] || plb(byweekday) && !contains(byweekday, ii.wdaymask[i]) || plb(ii.nwdaymask) && !ii.nwdaymask[i] || byeaster !== null && !contains(ii.eastermask, i) || (plb(bymonthday) || plb(bynmonthday)) && !contains(bymonthday, ii.mdaymask[i]) && !contains(bynmonthday, ii.nmdaymask[i]) || plb(byyearday) && (i < ii.yearlen && !contains(byyearday, i + 1) && !contains(byyearday, -ii.yearlen + i) || i >= ii.yearlen && !contains(byyearday, i + 1 - ii.yearlen) && !contains(byyearday, -ii.nextyearlen + i - ii.yearlen))) {
                        dayset[i] = null;
                        filtered = true;
                    }
                }
                if (plb(bysetpos) && plb(timeset)) {
                    var daypos, timepos, poslist = [];
                    for (i, j = 0; j < bysetpos.length; j++) {
                        var pos = bysetpos[j];
                        if (pos < 0) {
                            daypos = Math.floor(pos / timeset.length);
                            timepos = pymod(pos, timeset.length);
                        } else {
                            daypos = Math.floor((pos - 1) / timeset.length);
                            timepos = pymod(pos - 1, timeset.length);
                        }
                        try {
                            tmp = [];
                            for (k = start; k < end; k++) {
                                var val = dayset[k];
                                if (val === null) {
                                    continue;
                                }
                                tmp.push(val);
                            }
                            if (daypos < 0) {
                                i = tmp.slice(daypos)[0];
                            } else {
                                i = tmp[daypos];
                            }
                            var time = timeset[timepos];
                            var date = dateutil.fromOrdinal(ii.yearordinal + i);
                            var res = dateutil.combine(date, time);
                            if (!contains(poslist, res)) {
                                poslist.push(res);
                            }
                        } catch (e) {}
                    }
                    dateutil.sort(poslist);
                    for (j = 0; j < poslist.length; j++) {
                        var res = poslist[j];
                        if (until && res > until) {
                            this._len = total;
                            return iterResult.getValue();
                        } else if (res >= dtstart) {
                            ++total;
                            if (!iterResult.accept(res)) {
                                return iterResult.getValue();
                            }
                            if (count) {
                                --count;
                                if (!count) {
                                    this._len = total;
                                    return iterResult.getValue();
                                }
                            }
                        }
                    }
                } else {
                    for (j = start; j < end; j++) {
                        i = dayset[j];
                        if (i !== null) {
                            var date = dateutil.fromOrdinal(ii.yearordinal + i);
                            for (k = 0; k < timeset.length; k++) {
                                var time = timeset[k];
                                var res = dateutil.combine(date, time);
                                if (until && res > until) {
                                    this._len = total;
                                    return iterResult.getValue();
                                } else if (res >= dtstart) {
                                    ++total;
                                    if (!iterResult.accept(res)) {
                                        return iterResult.getValue();
                                    }
                                    if (count) {
                                        --count;
                                        if (!count) {
                                            this._len = total;
                                            return iterResult.getValue();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                fixday = false;
                if (freq == RRule.YEARLY) {
                    year += interval;
                    if (year > dateutil.MAXYEAR) {
                        this._len = total;
                        return iterResult.getValue();
                    }
                    ii.rebuild(year, month);
                } else if (freq == RRule.MONTHLY) {
                    month += interval;
                    if (month > 12) {
                        div = Math.floor(month / 12);
                        mod = pymod(month, 12);
                        month = mod;
                        year += div;
                        if (month == 0) {
                            month = 12;
                            --year;
                        }
                        if (year > dateutil.MAXYEAR) {
                            this._len = total;
                            return iterResult.getValue();
                        }
                    }
                    ii.rebuild(year, month);
                } else if (freq == RRule.WEEKLY) {
                    if (wkst > weekday) {
                        day += -(weekday + 1 + (6 - wkst)) + interval * 7;
                    } else {
                        day += -(weekday - wkst) + interval * 7;
                    }
                    weekday = wkst;
                    fixday = true;
                } else if (freq == RRule.DAILY) {
                    day += interval;
                    fixday = true;
                } else if (freq == RRule.HOURLY) {
                    if (filtered) {
                        hour += Math.floor((23 - hour) / interval) * interval;
                    }
                    while (true) {
                        hour += interval;
                        dm = divmod(hour, 24);
                        div = dm.div;
                        mod = dm.mod;
                        if (div) {
                            hour = mod;
                            day += div;
                            fixday = true;
                        }
                        if (!plb(byhour) || contains(byhour, hour)) {
                            break;
                        }
                    }
                    timeset = gettimeset.call(ii, hour, minute, second);
                } else if (freq == RRule.MINUTELY) {
                    if (filtered) {
                        minute += Math.floor((1439 - (hour * 60 + minute)) / interval) * interval;
                    }
                    while (true) {
                        minute += interval;
                        dm = divmod(minute, 60);
                        div = dm.div;
                        mod = dm.mod;
                        if (div) {
                            minute = mod;
                            hour += div;
                            dm = divmod(hour, 24);
                            div = dm.div;
                            mod = dm.mod;
                            if (div) {
                                hour = mod;
                                day += div;
                                fixday = true;
                                filtered = false;
                            }
                        }
                        if ((!plb(byhour) || contains(byhour, hour)) && (!plb(byminute) || contains(byminute, minute))) {
                            break;
                        }
                    }
                    timeset = gettimeset.call(ii, hour, minute, second);
                } else if (freq == RRule.SECONDLY) {
                    if (filtered) {
                        second += Math.floor((86399 - (hour * 3600 + minute * 60 + second)) / interval) * interval;
                    }
                    while (true) {
                        second += interval;
                        dm = divmod(second, 60);
                        div = dm.div;
                        mod = dm.mod;
                        if (div) {
                            second = mod;
                            minute += div;
                            dm = divmod(minute, 60);
                            div = dm.div;
                            mod = dm.mod;
                            if (div) {
                                minute = mod;
                                hour += div;
                                dm = divmod(hour, 24);
                                div = dm.div;
                                mod = dm.mod;
                                if (div) {
                                    hour = mod;
                                    day += div;
                                    fixday = true;
                                }
                            }
                        }
                        if ((!plb(byhour) || contains(byhour, hour)) && (!plb(byminute) || contains(byminute, minute)) && (!plb(bysecond) || contains(bysecond, second))) {
                            break;
                        }
                    }
                    timeset = gettimeset.call(ii, hour, minute, second);
                }
                if (fixday && day > 28) {
                    var daysinmonth = dateutil.monthRange(year, month - 1)[1];
                    if (day > daysinmonth) {
                        while (day > daysinmonth) {
                            day -= daysinmonth;
                            ++month;
                            if (month == 13) {
                                month = 1;
                                ++year;
                                if (year > dateutil.MAXYEAR) {
                                    this._len = total;
                                    return iterResult.getValue();
                                }
                            }
                            daysinmonth = dateutil.monthRange(year, month - 1)[1];
                        }
                        ii.rebuild(year, month);
                    }
                }
            }
        }
    };
    RRule.parseString = function(rfcString) {
        rfcString = rfcString.replace(/^\s+|\s+$/, "");
        if (!rfcString.length) {
            return null;
        }
        var i, j, key, value, attr, attrs = rfcString.split(";"), options = {};
        for (i = 0; i < attrs.length; i++) {
            attr = attrs[i].split("=");
            key = attr[0];
            value = attr[1];
            switch (key) {
              case "FREQ":
                options.freq = RRule[value];
                break;

              case "WKST":
                options.wkst = RRule[value];
                break;

              case "COUNT":
              case "INTERVAL":
              case "BYSETPOS":
              case "BYMONTH":
              case "BYMONTHDAY":
              case "BYYEARDAY":
              case "BYWEEKNO":
              case "BYHOUR":
              case "BYMINUTE":
              case "BYSECOND":
                if (value.indexOf(",") != -1) {
                    value = value.split(",");
                    for (j = 0; j < value.length; j++) {
                        if (/^[+-]?\d+$/.test(value[j])) {
                            value[j] = Number(value[j]);
                        }
                    }
                } else if (/^[+-]?\d+$/.test(value)) {
                    value = Number(value);
                }
                key = key.toLowerCase();
                options[key] = value;
                break;

              case "BYDAY":
                var n, wday, day, days = value.split(",");
                options.byweekday = [];
                for (j = 0; j < days.length; j++) {
                    day = days[j];
                    if (day.length == 2) {
                        wday = RRule[day];
                        options.byweekday.push(wday);
                    } else {
                        day = day.match(/^([+-]?\d)([A-Z]{2})$/);
                        n = Number(day[1]);
                        wday = day[2];
                        wday = RRule[wday].weekday;
                        options.byweekday.push(new Weekday(wday, n));
                    }
                }
                break;

              case "DTSTART":
                options.dtstart = dateutil.untilStringToDate(value);
                options.onlydate = dateutil.hasOnlyDate(value);
                break;

              case "UNTIL":
                options.until = dateutil.untilStringToDate(value);
                options.onlydate = dateutil.hasOnlyDate(value);
                break;

              case "BYEASTER":
                options.byeaster = Number(value);
                break;

              default:
                throw new Error("Unknown RRULE property '" + key + "'");
            }
        }
        return options;
    };
    RRule.fromString = function(string) {
        return new RRule(RRule.parseString(string));
    };
    var Iterinfo = function(rrule) {
        this.rrule = rrule;
        this.lastyear = null;
        this.lastmonth = null;
        this.yearlen = null;
        this.nextyearlen = null;
        this.yearordinal = null;
        this.yearweekday = null;
        this.mmask = null;
        this.mrange = null;
        this.mdaymask = null;
        this.nmdaymask = null;
        this.wdaymask = null;
        this.wnomask = null;
        this.nwdaymask = null;
        this.eastermask = null;
    };
    Iterinfo.prototype.easter = function(y, offset) {
        offset = offset || 0;
        var a = y % 19, b = Math.floor(y / 100), c = y % 100, d = Math.floor(b / 4), e = b % 4, f = Math.floor((b + 8) / 25), g = Math.floor((b - f + 1) / 3), h = Math.floor(19 * a + b - d - g + 15) % 30, i = Math.floor(c / 4), k = c % 4, l = Math.floor(32 + 2 * e + 2 * i - h - k) % 7, m = Math.floor((a + 11 * h + 22 * l) / 451), month = Math.floor((h + l - 7 * m + 114) / 31), day = (h + l - 7 * m + 114) % 31 + 1, date = Date.UTC(y, month - 1, day + offset), yearStart = Date.UTC(y, 0, 1);
        return [ Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24)) ];
    };
    Iterinfo.prototype.rebuild = function(year, month) {
        var rr = this.rrule;
        if (year != this.lastyear) {
            this.yearlen = dateutil.isLeapYear(year) ? 366 : 365;
            this.nextyearlen = dateutil.isLeapYear(year + 1) ? 366 : 365;
            var firstyday = new Date(year, 0, 1);
            this.yearordinal = dateutil.toOrdinal(firstyday);
            this.yearweekday = dateutil.getWeekday(firstyday);
            var wday = dateutil.getWeekday(new Date(year, 0, 1));
            if (this.yearlen == 365) {
                this.mmask = [].concat(M365MASK);
                this.mdaymask = [].concat(MDAY365MASK);
                this.nmdaymask = [].concat(NMDAY365MASK);
                this.wdaymask = WDAYMASK.slice(wday);
                this.mrange = [].concat(M365RANGE);
            } else {
                this.mmask = [].concat(M366MASK);
                this.mdaymask = [].concat(MDAY366MASK);
                this.nmdaymask = [].concat(NMDAY366MASK);
                this.wdaymask = WDAYMASK.slice(wday);
                this.mrange = [].concat(M366RANGE);
            }
            if (!plb(rr.options.byweekno)) {
                this.wnomask = null;
            } else {
                this.wnomask = repeat(0, this.yearlen + 7);
                var no1wkst, firstwkst, wyearlen;
                no1wkst = firstwkst = pymod(7 - this.yearweekday + rr.options.wkst, 7);
                if (no1wkst >= 4) {
                    no1wkst = 0;
                    wyearlen = this.yearlen + pymod(this.yearweekday - rr.options.wkst, 7);
                } else {
                    wyearlen = this.yearlen - no1wkst;
                }
                var div = Math.floor(wyearlen / 7);
                var mod = pymod(wyearlen, 7);
                var numweeks = Math.floor(div + mod / 4);
                for (var n, i, j = 0; j < rr.options.byweekno.length; j++) {
                    n = rr.options.byweekno[j];
                    if (n < 0) {
                        n += numweeks + 1;
                    }
                    if (!(0 < n && n <= numweeks)) {
                        continue;
                    }
                    if (n > 1) {
                        i = no1wkst + (n - 1) * 7;
                        if (no1wkst != firstwkst) {
                            i -= 7 - firstwkst;
                        }
                    } else {
                        i = no1wkst;
                    }
                    for (var k = 0; k < 7; k++) {
                        this.wnomask[i] = 1;
                        i++;
                        if (this.wdaymask[i] == rr.options.wkst) {
                            break;
                        }
                    }
                }
                if (contains(rr.options.byweekno, 1)) {
                    var i = no1wkst + numweeks * 7;
                    if (no1wkst != firstwkst) {
                        i -= 7 - firstwkst;
                    }
                    if (i < this.yearlen) {
                        for (var j = 0; j < 7; j++) {
                            this.wnomask[i] = 1;
                            i += 1;
                            if (this.wdaymask[i] == rr.options.wkst) {
                                break;
                            }
                        }
                    }
                }
                if (no1wkst) {
                    var lnumweeks;
                    if (!contains(rr.options.byweekno, -1)) {
                        var lyearweekday = dateutil.getWeekday(new Date(year - 1, 0, 1));
                        var lno1wkst = pymod(7 - lyearweekday + rr.options.wkst, 7);
                        var lyearlen = dateutil.isLeapYear(year - 1) ? 366 : 365;
                        if (lno1wkst >= 4) {
                            lno1wkst = 0;
                            lnumweeks = Math.floor(52 + pymod(lyearlen + pymod(lyearweekday - rr.options.wkst, 7), 7) / 4);
                        } else {
                            lnumweeks = Math.floor(52 + pymod(this.yearlen - no1wkst, 7) / 4);
                        }
                    } else {
                        lnumweeks = -1;
                    }
                    if (contains(rr.options.byweekno, lnumweeks)) {
                        for (var i = 0; i < no1wkst; i++) {
                            this.wnomask[i] = 1;
                        }
                    }
                }
            }
        }
        if (plb(rr.options.bynweekday) && (month != this.lastmonth || year != this.lastyear)) {
            var ranges = [];
            if (rr.options.freq == RRule.YEARLY) {
                if (plb(rr.options.bymonth)) {
                    for (j = 0; j < rr.options.bymonth.length; j++) {
                        month = rr.options.bymonth[j];
                        ranges.push(this.mrange.slice(month - 1, month + 1));
                    }
                } else {
                    ranges = [ [ 0, this.yearlen ] ];
                }
            } else if (rr.options.freq == RRule.MONTHLY) {
                ranges = [ this.mrange.slice(month - 1, month + 1) ];
            }
            if (plb(ranges)) {
                this.nwdaymask = repeat(0, this.yearlen);
                for (var j = 0; j < ranges.length; j++) {
                    var rang = ranges[j];
                    var first = rang[0], last = rang[1];
                    last -= 1;
                    for (var k = 0; k < rr.options.bynweekday.length; k++) {
                        var wday = rr.options.bynweekday[k][0], n = rr.options.bynweekday[k][1];
                        if (n < 0) {
                            i = last + (n + 1) * 7;
                            i -= pymod(this.wdaymask[i] - wday, 7);
                        } else {
                            i = first + (n - 1) * 7;
                            i += pymod(7 - this.wdaymask[i] + wday, 7);
                        }
                        if (first <= i && i <= last) {
                            this.nwdaymask[i] = 1;
                        }
                    }
                }
            }
            this.lastyear = year;
            this.lastmonth = month;
        }
        if (rr.options.byeaster !== null) {
            this.eastermask = this.easter(year, rr.options.byeaster);
        }
    };
    Iterinfo.prototype.ydayset = function(year, month, day) {
        return [ range(this.yearlen), 0, this.yearlen ];
    };
    Iterinfo.prototype.mdayset = function(year, month, day) {
        var set = repeat(null, this.yearlen);
        var start = this.mrange[month - 1];
        var end = this.mrange[month];
        for (var i = start; i < end; i++) {
            set[i] = i;
        }
        return [ set, start, end ];
    };
    Iterinfo.prototype.wdayset = function(year, month, day) {
        var set = repeat(null, this.yearlen + 7);
        var i = dateutil.toOrdinal(new Date(year, month - 1, day)) - this.yearordinal;
        var start = i;
        for (var j = 0; j < 7; j++) {
            set[i] = i;
            ++i;
            if (this.wdaymask[i] == this.rrule.options.wkst) {
                break;
            }
        }
        return [ set, start, i ];
    };
    Iterinfo.prototype.ddayset = function(year, month, day) {
        var set = repeat(null, this.yearlen);
        var i = dateutil.toOrdinal(new Date(year, month - 1, day)) - this.yearordinal;
        set[i] = i;
        return [ set, i, i + 1 ];
    };
    Iterinfo.prototype.htimeset = function(hour, minute, second) {
        var set = [], rr = this.rrule;
        for (var i = 0; i < rr.options.byminute.length; i++) {
            minute = rr.options.byminute[i];
            for (var j = 0; j < rr.options.bysecond.length; j++) {
                second = rr.options.bysecond[j];
                set.push(new dateutil.Time(hour, minute, second));
            }
        }
        dateutil.sort(set);
        return set;
    };
    Iterinfo.prototype.mtimeset = function(hour, minute, second) {
        var set = [], rr = this.rrule;
        for (var j = 0; j < rr.options.bysecond.length; j++) {
            second = rr.options.bysecond[j];
            set.push(new dateutil.Time(hour, minute, second));
        }
        dateutil.sort(set);
        return set;
    };
    Iterinfo.prototype.stimeset = function(hour, minute, second) {
        return [ new dateutil.Time(hour, minute, second) ];
    };
    var IterResult = function(method, args) {
        this.init(method, args);
    };
    IterResult.prototype = {
        init: function(method, args) {
            this.method = method;
            this.args = args;
            this._result = [];
            this.minDate = null;
            this.maxDate = null;
            if (method == "between") {
                this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
                this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
            } else if (method == "before") {
                this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
            } else if (method == "after") {
                this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
            }
        },
        accept: function(date) {
            var tooEarly = this.minDate && date < this.minDate, tooLate = this.maxDate && date > this.maxDate;
            if (this.method == "between") {
                if (tooEarly) return true;
                if (tooLate) return false;
            } else if (this.method == "before") {
                if (tooLate) return false;
            } else if (this.method == "after") {
                if (tooEarly) return true;
                this.add(date);
                return false;
            }
            return this.add(date);
        },
        add: function(date) {
            this._result.push(date);
            return true;
        },
        getValue: function() {
            switch (this.method) {
              case "all":
              case "between":
                return this._result;

              case "before":
              case "after":
                return this._result.length ? this._result[this._result.length - 1] : null;
            }
        }
    };
    var CallbackIterResult = function(method, args, iterator) {
        var allowedMethods = [ "all", "between" ];
        if (!contains(allowedMethods, method)) {
            throw new Error('Invalid method "' + method + '". Only all and between works with iterator.');
        }
        this.add = function(date) {
            if (iterator(date, this._result.length)) {
                this._result.push(date);
                return true;
            }
            return false;
        };
        this.init(method, args);
    };
    CallbackIterResult.prototype = IterResult.prototype;
    if (serverSide) {
        module.exports = {
            RRule: RRule
        };
    }
    if (typeof ender === "undefined") {
        root["RRule"] = RRule;
    }
    if (typeof define === "function" && define.amd) {
        define("rrule", [], function() {
            return RRule;
        });
    }
})(this);

(function(root) {
    var serverSide = typeof module !== "undefined" && module.exports;
    var RRule;
    if (serverSide) {
        RRule = require("./rrule").RRule;
    } else if (root.RRule) {
        RRule = root.RRule;
    } else if (typeof require !== "undefined") {
        if (!RRule) {
            RRule = require("rrule");
        }
    } else {
        throw new Error("rrule.js is required for rrule/nlp.js to work");
    }
    var contains = function(arr, val) {
        return arr.indexOf(val) != -1;
    };
    var ToText = function(rrule, gettext, language) {
        this.gettext = gettext || function(id) {
            return id;
        };
        this.language = language || ENGLISH;
        this.text = "";
        this.rrule = rrule;
        this.freq = rrule.options.freq;
        this.options = rrule.options;
        this.origOptions = rrule.origOptions;
        if (this.origOptions.bymonthday) {
            var bymonthday = [].concat(this.options.bymonthday);
            var bynmonthday = [].concat(this.options.bynmonthday);
            bymonthday.sort();
            bynmonthday.sort();
            bynmonthday.reverse();
            this.bymonthday = bymonthday.concat(bynmonthday);
            if (!this.bymonthday.length) {
                this.bymonthday = null;
            }
        }
        if (this.origOptions.byweekday) {
            var byweekday = !(this.origOptions.byweekday instanceof Array) ? [ this.origOptions.byweekday ] : this.origOptions.byweekday;
            var days = String(byweekday);
            this.byweekday = {
                allWeeks: byweekday.filter(function(weekday) {
                    return !Boolean(weekday.n);
                }),
                someWeeks: byweekday.filter(function(weekday) {
                    return Boolean(weekday.n);
                }),
                isWeekdays: days.indexOf("MO") != -1 && days.indexOf("TU") != -1 && days.indexOf("WE") != -1 && days.indexOf("TH") != -1 && days.indexOf("FR") != -1 && days.indexOf("SA") == -1 && days.indexOf("SU") == -1
            };
            var sortWeekDays = function(a, b) {
                return a.weekday - b.weekday;
            };
            this.byweekday.allWeeks.sort(sortWeekDays);
            this.byweekday.someWeeks.sort(sortWeekDays);
            if (!this.byweekday.allWeeks.length) {
                this.byweekday.allWeeks = null;
            }
            if (!this.byweekday.someWeeks.length) {
                this.byweekday.someWeeks = null;
            }
        } else {
            this.byweekday = null;
        }
    };
    ToText.IMPLEMENTED = [];
    var common = [ "count", "until", "interval", "byweekday", "bymonthday", "bymonth" ];
    ToText.IMPLEMENTED[RRule.DAILY] = common;
    ToText.IMPLEMENTED[RRule.WEEKLY] = common;
    ToText.IMPLEMENTED[RRule.MONTHLY] = common;
    ToText.IMPLEMENTED[RRule.YEARLY] = [ "byweekno", "byyearday" ].concat(common);
    ToText.isFullyConvertible = function(rrule) {
        var canConvert = true;
        if (!(rrule.options.freq in ToText.IMPLEMENTED)) {
            return false;
        }
        if (rrule.origOptions.until && rrule.origOptions.count) {
            return false;
        }
        for (var key in rrule.origOptions) {
            if (contains([ "dtstart", "wkst", "freq" ], key)) {
                return true;
            }
            if (!contains(ToText.IMPLEMENTED[rrule.options.freq], key)) {
                canConvert = false;
                return false;
            }
        }
        return canConvert;
    };
    ToText.prototype = {
        isFullyConvertible: function() {
            return ToText.isFullyConvertible(this.rrule);
        },
        toString: function() {
            var gettext = this.gettext;
            if (!(this.options.freq in ToText.IMPLEMENTED)) {
                return gettext("RRule error: Unable to fully convert this rrule to text");
            }
            this.text = [ gettext("every") ];
            this[RRule.FREQUENCIES[this.options.freq]]();
            if (this.options.until) {
                this.add(gettext("until"));
                var until = this.options.until;
                this.add(this.language.monthNames[until.getMonth()]).add(until.getDate() + ",").add(until.getFullYear());
            } else if (this.options.count) {
                this.add(gettext("for")).add(this.options.count).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
            }
            if (!this.isFullyConvertible()) {
                this.add(gettext("(~ approximate)"));
            }
            return this.text.join("");
        },
        DAILY: function() {
            var gettext = this.gettext;
            if (this.options.interval != 1) {
                this.add(this.options.interval);
            }
            if (this.byweekday && this.byweekday.isWeekdays) {
                this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
            } else {
                this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
            }
            if (this.origOptions.bymonth) {
                this.add(gettext("in"));
                this._bymonth();
            }
            if (this.bymonthday) {
                this._bymonthday();
            } else if (this.byweekday) {
                this._byweekday();
            }
        },
        WEEKLY: function() {
            var gettext = this.gettext;
            if (this.options.interval != 1) {
                this.add(this.options.interval).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
            }
            if (this.byweekday && this.byweekday.isWeekdays) {
                if (this.options.interval == 1) {
                    this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
                } else {
                    this.add(gettext("on")).add(gettext("weekdays"));
                }
            } else {
                if (this.options.interval == 1) {
                    this.add(gettext("week"));
                }
                if (this.origOptions.bymonth) {
                    this.add(gettext("in"));
                    this._bymonth();
                }
                if (this.bymonthday) {
                    this._bymonthday();
                } else if (this.byweekday) {
                    this._byweekday();
                }
            }
        },
        MONTHLY: function() {
            var gettext = this.gettext;
            if (this.origOptions.bymonth) {
                if (this.options.interval != 1) {
                    this.add(this.options.interval).add(gettext("months"));
                    if (this.plural(this.options.interval)) {
                        this.add(gettext("in"));
                    }
                } else {}
                this._bymonth();
            } else {
                if (this.options.interval != 1) {
                    this.add(this.options.interval);
                }
                this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
            }
            if (this.bymonthday) {
                this._bymonthday();
            } else if (this.byweekday && this.byweekday.isWeekdays) {
                this.add(gettext("on")).add(gettext("weekdays"));
            } else if (this.byweekday) {
                this._byweekday();
            }
        },
        YEARLY: function() {
            var gettext = this.gettext;
            if (this.origOptions.bymonth) {
                if (this.options.interval != 1) {
                    this.add(this.options.interval);
                    this.add(gettext("years"));
                } else {}
                this._bymonth();
            } else {
                if (this.options.interval != 1) {
                    this.add(this.options.interval);
                }
                this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
            }
            if (this.bymonthday) {
                this._bymonthday();
            } else if (this.byweekday) {
                this._byweekday();
            }
            if (this.options.byyearday) {
                this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
            }
            if (this.options.byweekno) {
                this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, null, gettext("and")));
            }
        },
        _bymonthday: function() {
            var gettext = this.gettext;
            if (this.byweekday && this.byweekday.allWeeks) {
                this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
            } else {
                this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
            }
        },
        _byweekday: function() {
            var gettext = this.gettext;
            if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
                this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
            }
            if (this.byweekday.someWeeks) {
                if (this.byweekday.allWeeks) {
                    this.add(gettext("and"));
                }
                this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
            }
        },
        _bymonth: function() {
            this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
        },
        nth: function(n) {
            var nth, npos, gettext = this.gettext;
            if (n == -1) {
                return gettext("last");
            }
            npos = Math.abs(n);
            switch (npos) {
              case 1:
              case 21:
              case 31:
                nth = npos + gettext("st");
                break;

              case 2:
              case 22:
                nth = npos + gettext("nd");
                break;

              case 3:
              case 23:
                nth = npos + gettext("rd");
                break;

              default:
                nth = npos + gettext("th");
            }
            return n < 0 ? nth + " " + gettext("last") : nth;
        },
        monthtext: function(m) {
            return this.language.monthNames[m - 1];
        },
        weekdaytext: function(wday) {
            return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[wday.getJsWeekday()];
        },
        plural: function(n) {
            return n % 100 != 1;
        },
        add: function(s) {
            this.text.push(" ");
            this.text.push(s);
            return this;
        },
        list: function(arr, callback, finalDelim, delim) {
            var delimJoin = function(array, delimiter, finalDelimiter) {
                var list = "";
                for (var i = 0; i < array.length; i++) {
                    if (i != 0) {
                        if (i == array.length - 1) {
                            list += " " + finalDelimiter + " ";
                        } else {
                            list += delimiter + " ";
                        }
                    }
                    list += array[i];
                }
                return list;
            };
            delim = delim || ",";
            callback = callback || function(o) {
                return o;
            };
            var self = this;
            var realCallback = function(arg) {
                return callback.call(self, arg);
            };
            if (finalDelim) {
                return delimJoin(arr.map(realCallback), delim, finalDelim);
            } else {
                return arr.map(realCallback).join(delim + " ");
            }
        }
    };
    var fromText = function(text, language) {
        return new RRule(parseText(text, language));
    };
    var parseText = function(text, language) {
        var ttr = new Parser((language || ENGLISH).tokens);
        if (!ttr.start(text)) {
            return null;
        }
        var options = {};
        S();
        return options;
        function S() {
            ttr.expect("every");
            var n;
            if (n = ttr.accept("number")) options.interval = parseInt(n[0]);
            if (ttr.isDone()) throw new Error("Unexpected end");
            switch (ttr.symbol) {
              case "day(s)":
                options.freq = RRule.DAILY;
                if (ttr.nextSymbol()) {
                    ON();
                    F();
                }
                break;

              case "weekday(s)":
                options.freq = RRule.WEEKLY;
                options.byweekday = [ RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR ];
                ttr.nextSymbol();
                F();
                break;

              case "week(s)":
                options.freq = RRule.WEEKLY;
                if (ttr.nextSymbol()) {
                    ON();
                    F();
                }
                break;

              case "month(s)":
                options.freq = RRule.MONTHLY;
                if (ttr.nextSymbol()) {
                    ON();
                    F();
                }
                break;

              case "year(s)":
                options.freq = RRule.YEARLY;
                if (ttr.nextSymbol()) {
                    ON();
                    F();
                }
                break;

              case "monday":
              case "tuesday":
              case "wednesday":
              case "thursday":
              case "friday":
              case "saturday":
              case "sunday":
                options.freq = RRule.WEEKLY;
                options.byweekday = [ RRule[ttr.symbol.substr(0, 2).toUpperCase()] ];
                if (!ttr.nextSymbol()) return;
                while (ttr.accept("comma")) {
                    if (ttr.isDone()) throw new Error("Unexpected end");
                    var wkd;
                    if (!(wkd = decodeWKD())) {
                        throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
                    }
                    options.byweekday.push(RRule[wkd]);
                    ttr.nextSymbol();
                }
                MDAYs();
                F();
                break;

              case "january":
              case "february":
              case "march":
              case "april":
              case "may":
              case "june":
              case "july":
              case "august":
              case "september":
              case "october":
              case "november":
              case "december":
                options.freq = RRule.YEARLY;
                options.bymonth = [ decodeM() ];
                if (!ttr.nextSymbol()) return;
                while (ttr.accept("comma")) {
                    if (ttr.isDone()) throw new Error("Unexpected end");
                    var m;
                    if (!(m = decodeM())) {
                        throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
                    }
                    options.bymonth.push(m);
                    ttr.nextSymbol();
                }
                ON();
                F();
                break;

              default:
                throw new Error("Unknown symbol");
            }
        }
        function ON() {
            var on = ttr.accept("on");
            var the = ttr.accept("the");
            if (!(on || the)) {
                return;
            }
            do {
                var nth, wkd, m;
                if (nth = decodeNTH()) {
                    if (wkd = decodeWKD()) {
                        ttr.nextSymbol();
                        if (!options.byweekday) {
                            options.byweekday = [];
                        }
                        options.byweekday.push(RRule[wkd].nth(nth));
                    } else {
                        if (!options.bymonthday) {
                            options.bymonthday = [];
                        }
                        options.bymonthday.push(nth);
                        ttr.accept("day(s)");
                    }
                } else if (wkd = decodeWKD()) {
                    ttr.nextSymbol();
                    if (!options.byweekday) options.byweekday = [];
                    options.byweekday.push(RRule[wkd]);
                } else if (ttr.symbol == "weekday(s)") {
                    ttr.nextSymbol();
                    if (!options.byweekday) options.byweekday = [];
                    options.byweekday.push(RRule.MO);
                    options.byweekday.push(RRule.TU);
                    options.byweekday.push(RRule.WE);
                    options.byweekday.push(RRule.TH);
                    options.byweekday.push(RRule.FR);
                } else if (ttr.symbol == "week(s)") {
                    ttr.nextSymbol();
                    var n;
                    if (!(n = ttr.accept("number"))) {
                        throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
                    }
                    options.byweekno = [ n[0] ];
                    while (ttr.accept("comma")) {
                        if (!(n = ttr.accept("number"))) {
                            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
                        }
                        options.byweekno.push(n[0]);
                    }
                } else if (m = decodeM()) {
                    ttr.nextSymbol();
                    if (!options.bymonth) options.bymonth = [];
                    options.bymonth.push(m);
                } else {
                    return;
                }
            } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
        }
        function decodeM() {
            switch (ttr.symbol) {
              case "january":
                return 1;

              case "february":
                return 2;

              case "march":
                return 3;

              case "april":
                return 4;

              case "may":
                return 5;

              case "june":
                return 6;

              case "july":
                return 7;

              case "august":
                return 8;

              case "september":
                return 9;

              case "october":
                return 10;

              case "november":
                return 11;

              case "december":
                return 12;

              default:
                return false;
            }
        }
        function decodeWKD() {
            switch (ttr.symbol) {
              case "monday":
              case "tuesday":
              case "wednesday":
              case "thursday":
              case "friday":
              case "saturday":
              case "sunday":
                return ttr.symbol.substr(0, 2).toUpperCase();
                break;

              default:
                return false;
            }
        }
        function decodeNTH() {
            switch (ttr.symbol) {
              case "last":
                ttr.nextSymbol();
                return -1;

              case "first":
                ttr.nextSymbol();
                return 1;

              case "second":
                ttr.nextSymbol();
                return ttr.accept("last") ? -2 : 2;

              case "third":
                ttr.nextSymbol();
                return ttr.accept("last") ? -3 : 3;

              case "nth":
                var v = parseInt(ttr.value[1]);
                if (v < -366 || v > 366) throw new Error("Nth out of range: " + v);
                ttr.nextSymbol();
                return ttr.accept("last") ? -v : v;

              default:
                return false;
            }
        }
        function MDAYs() {
            ttr.accept("on");
            ttr.accept("the");
            var nth;
            if (!(nth = decodeNTH())) {
                return;
            }
            options.bymonthday = [ nth ];
            ttr.nextSymbol();
            while (ttr.accept("comma")) {
                if (!(nth = decodeNTH())) {
                    throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
                }
                options.bymonthday.push(nth);
                ttr.nextSymbol();
            }
        }
        function F() {
            if (ttr.symbol == "until") {
                var date = Date.parse(ttr.text);
                if (!date) {
                    throw new Error("Cannot parse until date:" + ttr.text);
                }
                options.until = new Date(date);
            } else if (ttr.accept("for")) {
                options.count = ttr.value[0];
                ttr.expect("number");
            }
        }
    };
    var Parser = function(rules) {
        this.rules = rules;
    };
    Parser.prototype.start = function(text) {
        this.text = text;
        this.done = false;
        return this.nextSymbol();
    };
    Parser.prototype.isDone = function() {
        return this.done && this.symbol == null;
    };
    Parser.prototype.nextSymbol = function() {
        var p = this, best, bestSymbol;
        this.symbol = null;
        this.value = null;
        do {
            if (this.done) {
                return false;
            }
            best = null;
            var match, rule;
            for (var name in this.rules) {
                rule = this.rules[name];
                if (match = rule.exec(p.text)) {
                    if (best == null || match[0].length > best[0].length) {
                        best = match;
                        bestSymbol = name;
                    }
                }
            }
            if (best != null) {
                this.text = this.text.substr(best[0].length);
                if (this.text == "") {
                    this.done = true;
                }
            }
            if (best == null) {
                this.done = true;
                this.symbol = null;
                this.value = null;
                return;
            }
        } while (bestSymbol == "SKIP");
        this.symbol = bestSymbol;
        this.value = best;
        return true;
    };
    Parser.prototype.accept = function(name) {
        if (this.symbol == name) {
            if (this.value) {
                var v = this.value;
                this.nextSymbol();
                return v;
            }
            this.nextSymbol();
            return true;
        }
        return false;
    };
    Parser.prototype.expect = function(name) {
        if (this.accept(name)) {
            return true;
        }
        throw new Error("expected " + name + " but found " + this.symbol);
    };
    var ENGLISH = {
        dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
        monthNames: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
        tokens: {
            SKIP: /^[ \r\n\t]+|^\.$/,
            number: /^[1-9][0-9]*/,
            numberAsText: /^(one|two|three)/i,
            every: /^every/i,
            "day(s)": /^days?/i,
            "weekday(s)": /^weekdays?/i,
            "week(s)": /^weeks?/i,
            "month(s)": /^months?/i,
            "year(s)": /^years?/i,
            on: /^(on|in)/i,
            the: /^the/i,
            first: /^first/i,
            second: /^second/i,
            third: /^third/i,
            nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
            last: /^last/i,
            for: /^for/i,
            "time(s)": /^times?/i,
            until: /^(un)?til/i,
            monday: /^mo(n(day)?)?/i,
            tuesday: /^tu(e(s(day)?)?)?/i,
            wednesday: /^we(d(n(esday)?)?)?/i,
            thursday: /^th(u(r(sday)?)?)?/i,
            friday: /^fr(i(day)?)?/i,
            saturday: /^sa(t(urday)?)?/i,
            sunday: /^su(n(day)?)?/i,
            january: /^jan(uary)?/i,
            february: /^feb(ruary)?/i,
            march: /^mar(ch)?/i,
            april: /^apr(il)?/i,
            may: /^may/i,
            june: /^june?/i,
            july: /^july?/i,
            august: /^aug(ust)?/i,
            september: /^sep(t(ember)?)?/i,
            october: /^oct(ober)?/i,
            november: /^nov(ember)?/i,
            december: /^dec(ember)?/i,
            comma: /^(,\s*|(and|or)\s*)+/i
        }
    };
    var nlp = {
        fromText: fromText,
        parseText: parseText,
        isFullyConvertible: ToText.isFullyConvertible,
        toText: function(rrule, gettext, language) {
            return new ToText(rrule, gettext, language).toString();
        }
    };
    if (serverSide) {
        module.exports = nlp;
    } else {
        root["_RRuleNLP"] = nlp;
    }
    if (typeof define === "function" && define.amd) {
        define("rrule", [], function() {
            return RRule;
        });
    }
})(this);

+function($) {
    "use strict";
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.7";
    Tab.TRANSITION_DURATION = 150;
    Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest("ul:not(.dropdown-menu)");
        var selector = $this.data("target");
        if (!selector) {
            selector = $this.attr("href");
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "");
        }
        if ($this.parent("li").hasClass("active")) return;
        var $previous = $ul.find(".active:last a");
        var hideEvent = $.Event("hide.bs.tab", {
            relatedTarget: $this[0]
        });
        var showEvent = $.Event("show.bs.tab", {
            relatedTarget: $previous[0]
        });
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
        var $target = $(selector);
        this.activate($this.closest("li"), $ul);
        this.activate($target, $target.parent(), function() {
            $previous.trigger({
                type: "hidden.bs.tab",
                relatedTarget: $this[0]
            });
            $this.trigger({
                type: "shown.bs.tab",
                relatedTarget: $previous[0]
            });
        });
    };
    Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find("> .active");
        var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false);
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true);
            if (transition) {
                element[0].offsetWidth;
                element.addClass("in");
            } else {
                element.removeClass("fade");
            }
            if (element.parent(".dropdown-menu").length) {
                element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true);
            }
            callback && callback();
        }
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass("in");
    };
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this);
            var data = $this.data("bs.tab");
            if (!data) $this.data("bs.tab", data = new Tab(this));
            if (typeof option == "string") data[option]();
        });
    }
    var old = $.fn.tab;
    $.fn.tab = Plugin;
    $.fn.tab.Constructor = Tab;
    $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
    };
    var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery);

var dustbase = {};

var event_details_popup;

$(document).ready(function() {
    setTranslations(translations);
    dust.helpers.i18n = function i18n(chunk, context, bodies, params) {
        var i18n_params = {};
        var i18n_name = params.name;
        var i18n_type = params.type;
        delete params.name;
        delete params.type;
        for (var key in params) {
            if (params.hasOwnProperty(key)) {
                var param_name = "%" + key;
                i18n_params[param_name] = dust.helpers.tap(params[key], chunk, context);
            }
        }
        return chunk.write(t(i18n_type, i18n_name, i18n_params));
    };
    set_default_datepicker_options();
    dustbase = dust.makeBase({
        default_calendar_color: AgenDAVConf.default_calendar_color,
        base_url: AgenDAVConf.base_url,
        base_app_url: AgenDAVConf.base_app_url,
        csrf_token_name: csrf_id,
        csrf_token_value: csrf_value,
        enable_calendar_sharing: AgenDAVConf.enable_calendar_sharing,
        numbers1to31: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 ]
    });
    set_default_colorpicker_options();
    keep_session_active();
    handle_expired_session();
    $("#calendar_view").fullCalendar({
        selectable: true,
        editable: true,
        timezone: AgenDAVUserPrefs.timezone,
        firstDay: AgenDAVUserPrefs.weekstart,
        timeFormat: AgenDAVDateAndTime.fullCalendarFormat[AgenDAVUserPrefs.time_format],
        weekMode: "liquid",
        weekNumbers: AgenDAVUserPrefs.show_week_nb,
        weekNumberCalculation: "ISO",
        weekNumbersWithinDays: true,
        height: calendar_height(),
        windowResize: function(view) {
            var new_height = calendar_height();
            $(this).fullCalendar("option", "height", new_height);
        },
        header: {
            right: "month,agendaWeek,agendaDay",
            center: "title",
            left: "today prev,next"
        },
        theme: true,
        slotLabelFormat: AgenDAVDateAndTime.fullCalendarFormat[AgenDAVUserPrefs.time_format],
        slotMinutes: 30,
        firstHour: 8,
        defaultTimedEventDuration: "01:00:00",
        defaultAllDayEventDuration: {
            days: 1
        },
        eventLimit: true,
        allDayDefault: false,
        loading: function(bool) {
            loading(bool);
        },
        eventRender: event_render_callback,
        eventClick: event_click_callback,
        select: slots_drag_callback,
        selectHelper: false,
        eventResize: event_resize_callback,
        eventDrop: event_drop_callback
    });
    event_details_popup = $("#event_details").qtip({
        id: "event_details",
        prerender: false,
        content: {
            text: ".",
            title: {
                button: true
            }
        },
        position: {
            my: "bottom center",
            at: "top center",
            target: "mouse",
            viewport: $("#calendar_view"),
            adjust: {
                mouse: false,
                scroll: false
            }
        },
        style: {
            classes: "view_event_details qtip-bootstrap qtip-shadow",
            tip: true
        },
        show: {
            target: $("#calendar_view"),
            event: false,
            solo: $("#calendar_view"),
            effect: false
        },
        hide: {
            fixed: true,
            event: "unfocus",
            effect: false
        },
        events: {
            show: function(event, api) {
                $(this).find(".remove").off("click").on("click", function(e) {
                    var event_id = $(this).data("event-id");
                    event_delete(event_id);
                    event_details_popup.hide();
                    e.preventDefault();
                }).end().find(".modify").off("click").on("click", function(e) {
                    var event_id = $(this).data("event-id");
                    modify_event_handler(event_id);
                    event_details_popup.hide();
                    e.preventDefault();
                });
                $(window).on("keydown.tooltipevents", function(e) {
                    if (e.keyCode === $.ui.keyCode.ESCAPE) {
                        api.hide(e);
                    }
                });
            },
            hide: function(event, api) {
                $(window).off("keydown.tooltipevents");
            }
        }
    }).qtip("api");
    $('<button id="button-refresh" class="btn btn-default">' + '<i class="fa fa-refresh"></i> ' + t("labels", "refresh") + "</button>").appendTo("#calendar_view div.fc-right").on("click", function() {
        update_calendar_list(true);
    }).before('<span class="fc-header-space">');
    render_template("datepicker_button", {}, function(out) {
        $("#calendar_view .fc-center").append(out);
        $("#datepicker_fullcalendar").datepicker({
            changeYear: true,
            closeText: t("labels", "cancel"),
            onSelect: function(date, text) {
                var d = $("#datepicker_fullcalendar").datepicker("getDate");
                $("#calendar_view").fullCalendar("gotoDate", d);
            }
        }).prev().on("click", function() {
            var current_date = $("#calendar_view").fullCalendar("getDate").toDate();
            $("#datepicker_fullcalendar").datepicker("setDate", current_date);
            $("#datepicker_fullcalendar").datepicker("show");
        });
    });
    $("#calendar_view").fullCalendar("renderEvent", {
        title: "Little portal",
        start: "1985-02-15T00:00:00Z",
        end: "1985-02-15T23:59:59Z",
        allDay: true,
        editable: false,
        color: "#E78AEF"
    }, true);
    $("div.calendar_list").on("click", "i.cfg", function(e) {
        e.stopPropagation();
        var calentry = $(this).parent();
        calendar_modify_dialog($(calentry[0]).data());
    }).on("click", "li.available_calendar", function(e) {
        toggle_calendar($(this));
    });
    update_calendar_list(true);
    $("#sidebar").on("click", "#toggle_all_shared_calendars", function(e) {
        var shared_cals = $("#shared_calendar_list").find("ul").children();
        if ($(this).hasClass("hide_all")) {
            $.map(shared_cals, function(e, i) {
                hide_calendar($(e));
            });
            $(this).removeClass("hide_all").addClass("show_all").find("i").removeClass("fa-eye-slash").addClass("fa-eye");
        } else {
            $.map(shared_cals, function(e, i) {
                show_calendar($(e));
            });
            $(this).removeClass("show_all").addClass("hide_all").find("i").removeClass("fa-eye").addClass("fa-eye-slash");
        }
    });
    $("#calendar_add").on("click", calendar_create_dialog);
    $("#shortcut_add_event").on("click", function() {
        var start = $("#calendar_view").fullCalendar("getDate");
        var data = {
            start: start,
            allDay: false,
            view: "month"
        };
        $("#calendar_view").fullCalendar("unselect");
        open_event_edit_dialog(data);
    });
    setup_print_tweaks();
});

var calendar_height = function calendar_height() {
    var offset = $("#calendar_view").offset();
    return $(window).height() - Math.ceil(offset.top) - 30;
};

var show_error = function show_error(title, message) {
    loading(false);
    $("#popup").freeow(title, message, {
        classes: [ "popup_error" ],
        autoHide: true,
        showStyle: {
            opacity: 1,
            left: 0
        },
        hideStyle: {
            opacity: 0,
            left: "400px"
        }
    });
};

var show_success = function show_success(title, message) {
    $("#popup").freeow(title, message, {
        classes: [ "popup_success" ],
        autoHide: true,
        autoHideDelay: 2e3,
        showStyle: {
            opacity: 1,
            left: 0
        },
        hideStyle: {
            opacity: 0,
            left: "400px"
        }
    });
};

var send_form = function send_form(params) {
    var url;
    var formObj = params.form_object;
    var data = params.data;
    var successFunc = params.success || function() {};
    var exceptionFunc = params.exception || function() {};
    var errorFunc = params.error || function(message) {
        show_error(t("messages", "error_oops"), message);
    };
    if (formObj instanceof jQuery) {
        url = $(formObj).attr("action");
        if (!check_required_fields(formObj)) {
            loading(false);
            show_error(t("messages", "error_empty_fields"), "");
            return;
        }
    } else {
        url = formObj.url;
        data = formObj.data;
    }
    loading(true);
    var sendform_ajax_req = $.ajax({
        url: url,
        cache: false,
        type: "POST",
        data: data,
        dataType: "json"
    });
    sendform_ajax_req.then(function() {
        loading(false);
    });
    sendform_ajax_req.fail(function(jqXHR, textStatus, errorThrown) {
        if (jqXHR.getResponseHeader("content-type").indexOf("json") === -1) {
            console.log(jqXHR.responseText);
            show_error(t("messages", "error_interfacefailure"), t("messages", "error_oops"));
            errorFunc("");
            return;
        }
        var data = $.parseJSON(jqXHR.responseText);
        if (data.result === "EXCEPTION") {
            exceptionFunc(data.message);
        }
        if (data.result === "ERROR") {
            errorFunc(data.message);
        }
    });
    sendform_ajax_req.done(function(data, textStatus, jqXHR) {
        if (data.result !== "SUCCESS") {
            show_error(t("messages", "internal_server_error"), "");
            errorFunc("");
            return;
        }
        successFunc(data.message);
    });
};

var show_dialog = function show_dialog(params) {
    var template = params.template;
    var data = params.data;
    var title = params.title;
    var buttons = params.buttons;
    var divname = params.divname;
    var width = params.width;
    var pre_func = params.pre_func;
    render_template(template, data, function(out) {
        $("body").append(out);
        $("#" + divname).dialog({
            autoOpen: true,
            buttons: buttons,
            title: title,
            minWidth: width,
            modal: true,
            open: function(event, ui) {
                if (pre_func !== undefined) {
                    pre_func();
                }
                $("#" + divname).dialog("option", "position", "center");
                var buttons = $(event.target).parent().find(".ui-dialog-buttonset").children();
                add_button_icons(buttons);
            },
            close: function(ev, ui) {
                $(this).remove();
            }
        });
    });
};

var destroy_dialog = function destroy_dialog(name) {
    $(name).dialog("close");
    $(name).dialog("destroy");
    $(name).remove();
};

var set_default_datepicker_options = function set_default_datepicker_options() {
    $.datepicker.setDefaults({
        constrainInput: true
    });
    $.datepicker.setDefaults({
        dateFormat: AgenDAVDateAndTime.datepickerFormat[AgenDAVUserPrefs.date_format]
    });
};

var set_mindate = function set_mindate(mindate, datepickers) {
    var desired_date = mindate;
    if (moment.isMoment(mindate)) {
        desired_date = mindate.toDate();
    }
    $.each(datepickers, function(i, element) {
        element.datepicker("option", "minDate", desired_date);
    });
};

var open_event_edit_dialog = function open_event_edit_dialog(event) {
    var is_new = false;
    var title = t("labels", "editevent");
    if (event.id === undefined) {
        is_new = true;
    }
    event = jQuery.extend(true, {}, event);
    if (event.start != undefined && !(event.start instanceof moment)) {
        event.start = moment(event.start);
    }
    if (event.end != undefined && !(event.end instanceof moment)) {
        event.end = moment(event.end);
    }
    if (is_new) {
        title = t("labels", "createevent");
        if (event.view == "month") {
            event.start = AgenDAVDateAndTime.approxNearest(event.start);
            event.end = AgenDAVDateAndTime.approxNearest(event.end).add(1, "hours");
        }
    }
    if (!is_new && event.allDay === true) {
        var adapted_end = moment(event.end);
        adapted_end.subtract(1, "days");
        event.end = adapted_end;
    }
    event.end = AgenDAVDateAndTime.endDate(event);
    if (event.allDay === true) {
        event.start = AgenDAVDateAndTime.approxNearest(event.start);
        event.end = AgenDAVDateAndTime.approxNearest(event.end).add(1, "hours");
    }
    if (event.calendar === undefined) {
        event.calendar = AgenDAVUserPrefs.default_calendar;
    }
    if (event.rrule !== undefined && event.recurrence_id !== undefined) {
        event.fixed_calendar = true;
        event.fixed_repeat_rule = true;
    }
    $.extend(event, {
        applyid: "event_edit_form",
        frm: {
            action: AgenDAVConf.base_app_url + "events/save",
            method: "post"
        },
        calendars: calendar_list(),
        start_date: AgenDAVDateAndTime.extractDate(event.start),
        start_time: AgenDAVDateAndTime.extractTime(event.start),
        end_date: AgenDAVDateAndTime.extractDate(event.end),
        end_time: AgenDAVDateAndTime.extractTime(event.end),
        yearly: RRule.YEARLY,
        monthly: RRule.MONTHLY,
        weekly: RRule.WEEKLY,
        daily: RRule.DAILY
    });
    console.log(event);
    var button_save = {
        text: t("labels", "save"),
        class: "addicon btn-icon-event-edit",
        click: function() {
            var event_fields = $("#event_edit_form").serializeObject();
            event_fields.timezone = AgenDAVUserPrefs.timezone;
            send_form({
                form_object: $("#event_edit_form"),
                data: event_fields,
                success: function(affected_calendars) {
                    var total = affected_calendars.length;
                    for (var i = 0; i < total; i++) {
                        reload_event_source(affected_calendars[i]);
                    }
                    destroy_dialog("#event_edit_dialog");
                },
                exception: function(error) {
                    show_error(t("messages", "error_invalidinput"), error);
                }
            });
        }
    };
    var button_cancel = {
        text: t("labels", "cancel"),
        class: "addicon btn-icon-cancel",
        click: function() {
            destroy_dialog("#event_edit_dialog");
        }
    };
    var buttons = [ button_save, button_cancel ];
    show_dialog({
        template: "event_edit_dialog",
        data: event,
        title: title,
        buttons: buttons,
        divname: "event_edit_dialog",
        width: 550,
        pre_func: function() {
            $("#event_edit_dialog").find("input.summary").focus();
            handle_date_and_time("#event_edit_dialog", event);
            AgenDAVRepeat.handleForm($("#tabs-recurrence"));
            if (event.rrule !== undefined && event.rrule !== "") {
                AgenDAVRepeat.setRepeatRuleOnForm(event.rrule, $("#tabs-recurrence"));
            }
            reminders_manager();
        }
    });
};

var handle_date_and_time = function handle_date_and_time(where, data) {
    var $start_time = $(where).find("input.start_time");
    var $end_time = $(where).find("input.end_time");
    var $start_date = $(where).find("input.start_date");
    var $end_date = $(where).find("input.end_date");
    var $repeat_until = $("#repeat_until");
    var $allday = $(where).find("input.allday");
    $start_time.timepicker(AgenDAVDateAndTime.timepickerSettings[AgenDAVUserPrefs.time_format]);
    $end_time.timepicker(AgenDAVDateAndTime.timepickerSettings[AgenDAVUserPrefs.time_format]);
    $start_date.datepicker({
        onSelect: function(dateText, inst) {
            set_mindate($(this).datepicker("getDate"), [ $end_date, $repeat_until ]);
            generate_iso8601_values($(where));
        }
    });
    $end_date.datepicker();
    $repeat_until.datepicker();
    set_mindate(data.start_date, [ $end_date, $repeat_until ]);
    $(where).on("change", "input.allday", function() {
        if ($(this).prop("checked")) {
            $start_time.prop("required", false);
            $end_time.prop("required", false);
            $start_time.hide();
            $end_time.hide();
        } else {
            $start_time.prop("required", true);
            $end_time.prop("required", true);
            $start_time.show();
            $end_time.show();
        }
        generate_iso8601_values($(where));
    });
    $allday.trigger("change");
    $(where).on("change", "input.start_time", function(event) {
        var start = AgenDAVDateAndTime.getMoment($("#start").val(), AgenDAVUserPrefs.timezone);
        var duration = $end_time.data("duration");
        var new_end = start.add(duration, "minutes");
        $end_date.val(AgenDAVDateAndTime.extractDate(new_end));
        $end_time.val(AgenDAVDateAndTime.extractTime(new_end));
        generate_iso8601_values($(where));
    }).on("change", "input.end_time", function(event) {
        $end_time.data("duration", calculate_event_duration());
    });
    $("input.date, input.time").on("change", function(event) {
        generate_iso8601_values($(where));
    });
    $(where).on("change", "input.start_time, input.allday", function(event) {
        AgenDAVRepeat.regenerate();
    });
    generate_iso8601_values($(where));
    $end_time.data("duration", calculate_event_duration());
};

var calculate_event_duration = function calculate_event_duration() {
    var start = AgenDAVDateAndTime.getMoment($("#start").val(), AgenDAVUserPrefs.timezone);
    var end = AgenDAVDateAndTime.getMoment($("#end").val(), AgenDAVUserPrefs.timezone);
    var result = end.diff(start, "minutes");
    if (result < 0) {
        result *= -1;
    }
    return result;
};

var calendar_create_dialog = function calendar_create_dialog() {
    var form_url = AgenDAVConf.base_app_url + "calendars";
    var title = t("labels", "newcalendar");
    var data = {
        applyid: "calendar_create_form",
        frm: {
            action: form_url,
            method: "post"
        }
    };
    var buttons = [ {
        text: t("labels", "create"),
        class: "addicon btn-icon-calendar-add",
        click: function() {
            var calendar_data = $("#calendar_create_form").serialize();
            send_form({
                form_object: $("#calendar_create_form"),
                data: calendar_data,
                success: function(data) {
                    update_calendar_list(false);
                    destroy_dialog("#calendar_create_dialog");
                },
                exception: function(data) {
                    show_error(t("messages", "error_invalidinput"), data);
                }
            });
        }
    }, {
        text: t("labels", "cancel"),
        class: "addicon btn-icon-cancel",
        click: function() {
            destroy_dialog("#calendar_create_dialog");
        }
    } ];
    show_dialog({
        template: "calendar_create_dialog",
        data: data,
        title: title,
        buttons: buttons,
        divname: "calendar_create_dialog",
        width: 400,
        pre_func: function() {
            $("input.pick_color").colorPicker();
        }
    });
};

var calendar_modify_dialog = function calendar_modify_dialog(calendar_obj) {
    var form_url = AgenDAVConf.base_app_url + "calendars/save";
    var title = t("labels", "modifycalendar");
    var data = calendar_obj;
    $.extend(data, {
        applyid: "calendar_modify_form",
        frm: {
            action: form_url,
            method: "post"
        }
    });
    if (AgenDAVConf.show_public_caldav_url === true) {
        data.public_url = AgenDAVConf.caldav_public_base_url + data.url;
    }
    var buttons_and_actions = [ {
        text: t("labels", "deletecalendar"),
        class: "addicon btn-icon-calendar-delete",
        click: function() {
            calendar_delete_dialog(calendar_obj);
        }
    }, {
        text: t("labels", "save"),
        class: "addicon btn-icon-calendar-edit",
        click: function() {
            var calendar_data = $("#calendar_modify_form").serialize();
            send_form({
                form_object: $("#calendar_modify_form"),
                data: calendar_data,
                success: function(data) {
                    destroy_dialog("#calendar_modify_dialog");
                    update_calendar_list(false);
                },
                exception: function(data) {
                    show_error(t("messages", "error_invalidinput"), data);
                }
            });
        }
    }, {
        text: t("labels", "cancel"),
        class: "addicon btn-icon-cancel",
        click: function() {
            destroy_dialog("#calendar_modify_dialog");
        }
    } ];
    if (data.is_shared === true) {
        buttons_and_actions.splice(0, 1);
    }
    show_dialog({
        template: "calendar_modify_dialog",
        data: data,
        title: title,
        buttons: buttons_and_actions,
        divname: "calendar_modify_dialog",
        width: 500,
        pre_func: function() {
            $("input.pick_color").colorPicker();
            if (AgenDAVConf.enable_calendar_sharing === true && data.is_shared !== true) {
                shares_manager();
            }
        }
    });
};

var calendar_delete_dialog = function calendar_delete_dialog(calendar_obj) {
    destroy_dialog("#calendar_modify_dialog");
    var form_url = AgenDAVConf.base_app_url + "calendars/delete";
    var title = t("labels", "deletecalendar");
    var data = calendar_obj;
    $.extend(data, {
        applyid: "calendar_delete_form",
        frm: {
            action: form_url,
            method: "post"
        }
    });
    var buttons = [ {
        text: t("labels", "yes"),
        class: "addicon btn-icon-calendar-delete",
        click: function() {
            var fake_form = {
                url: AgenDAVConf.base_app_url + "calendars/delete",
                data: $("#calendar_delete_form").serializeObject()
            };
            destroy_dialog("#calendar_delete_dialog");
            send_form({
                form_object: fake_form,
                success: function(removed_calendar) {
                    $(".calendar_list li.available_calendar").each(function(index) {
                        var thiscal = $(this).data();
                        if (thiscal.calendar == removed_calendar) {
                            $("#calendar_view").fullCalendar("removeEventSource", thiscal.eventsource);
                            $(this).remove();
                            return false;
                        }
                    });
                },
                exception: function(data) {
                    show_error(t("messages", "error_caldelete"), data);
                }
            });
        }
    }, {
        text: t("labels", "cancel"),
        class: "addicon btn-icon-cancel",
        click: function() {
            destroy_dialog("#calendar_delete_dialog");
        }
    } ];
    show_dialog({
        template: "calendar_delete_dialog",
        data: data,
        title: title,
        buttons: buttons,
        divname: "calendar_delete_dialog",
        width: 500
    });
};

var update_calendar_list = function update_calendar_list(maskbody) {
    if (maskbody) {
        loading(true);
    }
    var updcalendar_ajax_req = $.ajax({
        url: AgenDAVConf.base_app_url + "calendars",
        cache: false,
        dataType: "json"
    });
    updcalendar_ajax_req.then(function() {
        if (maskbody) {
            loading(false);
        }
    });
    updcalendar_ajax_req.fail(function(jqXHR, textStatus, errorThrown) {
        var message = errorThrown;
        if (jqXHR.status === undefined || jqXHR.status != 401) {
            message = jqXHR.responseJSON.message;
            show_error(t("messages", "error_loading_calendar_list"), message);
        }
    });
    updcalendar_ajax_req.done(function(data, textStatus, jqXHR) {
        var was_hidden = {};
        $(".calendar_list li.available_calendar").each(function(index) {
            var data = $(this).data();
            $("#calendar_view").fullCalendar("removeEventSource", data.eventsource);
            if ($(this).hasClass("hidden_calendar")) {
                was_hidden[data.calendar] = true;
            }
            $(this).remove();
        });
        var count = 0, count_shared = 0, own_calendars = document.createDocumentFragment(), shared_calendars = document.createDocumentFragment(), collected_event_sources = [];
        var calendars = data.calendars;
        $.each(calendars, function(key, calendar) {
            if (AgenDAVUserPrefs.hidden_calendars[calendar.calendar] !== undefined) {
                return true;
            }
            count++;
            if (calendar.color === undefined || calendar.color === null) {
                calendar.color = AgenDAVConf.default_calendar_color;
            } else {
                calendar.color = calendar.color.substr(0, 7);
            }
            calendar.fg = fg_for_bg(calendar.color);
            var li = generate_calendar_entry(calendar);
            if (calendar.calendar === AgenDAVUserPrefs.default_calendar) {
                li.addClass("default_calendar");
            }
            if (was_hidden[calendar.calendar]) {
                li.addClass("hidden_calendar");
            } else {
                collected_event_sources.push($(li).data().eventsource);
            }
            if (calendar.is_shared === true) {
                count_shared++;
                shared_calendars.appendChild(li[0]);
            } else {
                own_calendars.appendChild(li[0]);
            }
        });
        if (count === 0) {
            var last_calendar_count = $("#calendar_view").data("calendar-count");
            if (last_calendar_count === undefined) {
                $("#calendar_view").data("calendar-count", 0);
                setTimeout(function() {
                    update_calendar_list(false);
                }, 1);
                return;
            }
            show_error(t("messages", "notice_no_calendars"), "");
            $("#shortcut_add_event").attr("disabled", "disabled");
            return;
        }
        $("#calendar_view").data("calendar-count", count);
        $("#own_calendar_list ul")[0].appendChild(own_calendars);
        if (count_shared === 0) {
            $("#shared_calendar_list").hide();
        } else {
            $("#shared_calendar_list ul")[0].appendChild(shared_calendars);
            $("#shared_calendar_list").show();
        }
        while (count--) {
            $("#calendar_view").fullCalendar("addEventSource", collected_event_sources[count]);
        }
        $("#shortcut_add_event").removeAttr("disabled");
    });
};

var generate_event_source = function generate_event_source(calendar) {
    var ajax_options = {
        url: AgenDAVConf.base_app_url + "events#" + calendar,
        cache: false,
        data: {
            calendar: calendar
        },
        error: function(jqXHR, textStatus, errorThrown) {
            show_error(t("messages", "error_interfacefailure"), t("messages", "error_loadevents", {
                "%cal": calendar
            }));
        }
    };
    return ajax_options;
};

var keep_session_active = function keep_session_active() {
    var sessrefresh_ajax_req = $.ajax({
        url: AgenDAVConf.base_app_url + "keepalive",
        cache: false,
        method: "GET"
    });
    sessrefresh_ajax_req.done(function(data, textStatus, jqXHR) {
        setTimeout(function() {
            keep_session_active();
        }, 6e4);
    });
};

var add_button_icons = function add_button_icons(buttons) {
    buttons.filter("button.addicon").removeClass("addicon").removeClass("ui-button-text-only").addClass("ui-button-text-icon-primary").each(function(k, v) {
        var classes = $(v).attr("class").split(" ");
        $.each(classes, function(i, j) {
            if (j.match(/^btn-icon-/)) {
                $(v).prepend('<span class="ui-button-icon-primary ui-icon ' + j + '"></span>');
                $(v).removeClass(j);
                return false;
            }
        });
    });
};

var generate_calendar_entry = function generate_calendar_entry(data) {
    var eventsource = generate_event_source(data.calendar);
    eventsource.color = data.color;
    eventsource.textColor = data.fg;
    if (data.is_shared === true && data.writable == false) {
        eventsource.editable = false;
    }
    data.eventsource = eventsource;
    var $out;
    render_template("calendar_list_entry", data, function(out) {
        $out = $(out);
        $out.data(data);
        $out.disableSelection();
    });
    return $out;
};

var get_calendar_data = function get_calendar_data(calendar_url) {
    var matches = $(".calendar_list").find('[data-calendar-url="' + calendar_url + '"]');
    if (matches.length == 1) {
        return $(matches[0]).data();
    }
};

var get_calendar_displayname = function get_calendar_displayname(calendar_url) {
    var data = get_calendar_data(calendar_url);
    if (data === undefined || data.displayname === undefined) {
        return "(?)";
    } else {
        return data.displayname;
    }
};

var get_event_data = function get_event_data(id) {
    var data = $("#calendar_view").fullCalendar("clientEvents", id);
    if (data.length === 0) {
        return undefined;
    }
    return data[0];
};

var load_base_event_for = function load_base_event_for(instance, success, fail) {
    var parts = instance.id.split("@");
    var base_id = parts[0] + "@";
    var search = $.getJSON(AgenDAVConf.base_app_url + "eventbase", {
        calendar: instance.calendar,
        timezone: AgenDAVUserPrefs.timezone,
        uid: instance.uid
    });
    search.done(function(event_data) {
        success(event_data);
    });
    search.fail(fail);
};

var reload_event_source = function reload_event_source(cal) {
    var eventsource;
    $(".calendar_list li.available_calendar").each(function(index) {
        var thiscal = $(this).data();
        if (thiscal.calendar == cal) {
            eventsource = thiscal.eventsource;
            return false;
        }
    });
    if (eventsource !== undefined) {
        $("#calendar_view").fullCalendar("removeEventSource", eventsource);
        $("#calendar_view").fullCalendar("addEventSource", eventsource);
    } else {
        show_error(t("messages", "error_interfacefailure"), t("messages", "error_calendarnotfound", {
            "%calendar": cal
        }));
    }
};

var fg_for_bg = function fg_for_bg(color) {
    var colr = parseInt(color.substr(1), 16);
    var is_dark = (colr >>> 16) + (colr >>> 8 & 255) + (colr & 255) < 500;
    return is_dark ? "#ffffff" : "#000000";
};

var session_expired = function session_expired() {
    $(".ui-dialog-content").dialog("close");
    show_error(t("messages", "error_sessexpired"), t("messages", "error_loginagain"));
    setTimeout(function() {
        window.location = AgenDAVConf.base_url;
    }, 2e3);
};

var shares_manager = function shares_manager() {
    var shares_list = $("#shares");
    shares_manager_no_entries_placeholder();
    shares_list.on("click", ".remove", function(event) {
        $(this).closest(".share").remove();
        shares_manager_no_entries_placeholder();
    });
    $("#new_share").on("click", function(event) {
        var filter = $("#calendar_share_filter");
        if (filter.length === 0) {
            render_template("calendar_share_row", {
                new: "1"
            }, function(out) {
                $("#shares").append(out);
                shares_manager_no_entries_placeholder();
                shares_manager_enable_autocomplete();
                $("#calendar_share_filter").focus();
            });
            return;
        }
        filter.focus();
    });
};

var shares_manager_no_entries_placeholder = function shares_manager_no_entries_placeholder() {
    var shares = $("#shares");
    if (shares.find(".share").length === 0) {
        $("#no_shares").show();
    } else {
        $("#no_shares").hide();
    }
};

var shares_manager_enable_autocomplete = function shares_manager_enable_autocomplete() {
    var user_autocomplete_cache = {}, lastXhr;
    $("#calendar_share_filter").autocomplete({
        minLength: 3,
        source: function(request, response) {
            var term = request.term;
            if (term in user_autocomplete_cache) {
                response(user_autocomplete_cache[term]);
                return;
            }
            lastXhr = $.getJSON(AgenDAVConf.base_app_url + "principals", request, function(data, status, xhr) {
                user_autocomplete_cache[term] = data;
                if (xhr === lastXhr) {
                    response(data);
                }
            });
        },
        select: function(event, ui) {
            var permissions = $("#calendar_share_add_rw").val();
            render_template("calendar_share_row", {
                with: ui.item.url,
                displayname: ui.item.url,
                rw: permissions
            }, function(out) {
                $("#calendar_share_add_row").before(out);
                $("#calendar_share_filter").val("").focus();
            });
            return false;
        }
    });
    $("#calendar_share_filter").data("ui-autocomplete")._renderItem = function(ul, item) {
        var text = '<a><i class="fa fa-user"></i> ' + item.displayname;
        if (item.email !== null) {
            text += ' <span style="font-style: italic">&lt;' + item.email + "&gt;</span>";
        }
        text += "</a>";
        return $("<li></li>").data("item.autocomplete", item).append(text).appendTo(ul);
    };
};

var reminders_manager = function reminders_manager() {
    var tab_reminders = $("#tabs-reminders");
    var manager = $("#reminders");
    reminders_manager_no_entries_placeholder();
    manager.on("click", ".remove", function(event) {
        $(this).closest(".reminder").remove();
        reminders_manager_no_entries_placeholder();
    });
    manager.parent().on("click", "#new_reminder", function(event) {
        render_template("reminder_row", {}, function(out) {
            $("#reminders").append(out);
            reminders_manager_no_entries_placeholder();
        });
    });
};

var reminders_manager_no_entries_placeholder = function reminders_manager_no_entries_placeholder() {
    var manager = $("#reminders");
    if (manager.find(".reminder").length === 0) {
        $("#no_reminders").show();
    } else {
        $("#no_reminders").hide();
    }
};

var event_render_callback = function event_render_callback(event, element) {
    var icons = [];
    if (event.rrule !== undefined) {
        icons.push("fa-repeat");
    }
    if (event.reminders !== undefined && event.reminders.length > 0) {
        icons.push("fa-bell-o");
    }
    if (icons.length !== 0) {
        var icon_html = $('<span class="fc-event-icons"></span>');
        $.each(icons, function(n, i) {
            icon_html.append('<i class="fa ' + i + '"></i>');
        });
        element.find(".fc-title").after(icon_html);
    }
};

var event_click_callback = function event_click_callback(event, jsEvent, view) {
    var caldata = get_calendar_data(event.calendar);
    if (caldata === undefined) {
        show_error(t("messages", "error_interfacefailure"), t("messages", "error_calendarnotfound", {
            "%calendar": event.calendar
        }));
        return;
    }
    var event_data = $.extend({}, event, {
        caldata: caldata
    });
    if (caldata.is_shared === true && caldata.writable === false) {
        event_data.disable_actions = true;
    }
    if (event_data.rrule !== undefined) {
        var rrule = RRule.fromString(event_data.rrule);
        event_data.rrule_explained = AgenDAVRepeat.explainRRule(rrule);
    }
    event_data.readable_dates = AgenDAVDateAndTime.formatEventDates(event_data);
    render_template("event_details_popup", event_data, function(out) {
        event_details_popup.set({
            "content.text": out,
            "content.title": event_data.title
        }).reposition(jsEvent).show(jsEvent);
    });
};

var slots_drag_callback = function slots_drag_callback(start, end, jsEvent, view) {
    var pass_allday = false;
    if (view.name != "month" && !start.hasTime()) {
        pass_allday = true;
    }
    if (view.name == "month" || pass_allday === true) {
        end.subtract(1, "day");
    }
    var data = {
        start: start,
        end: end,
        allDay: pass_allday,
        view: view.name
    };
    $("#calendar_view").fullCalendar("unselect");
    open_event_edit_dialog(data);
};

var event_resize_callback = function event_resize_callback(event, delta, revertFunc, jsEvent, ui, view) {
    var allDay = !event.start.hasTime();
    event_alter("resize", event, delta, allDay, revertFunc, jsEvent, ui, view);
};

var event_drop_callback = function event_drop_callback(event, delta, revertFunc, jsEvent, ui, view) {
    var allDay = !event.start.hasTime();
    event_alter("drop", event, delta, allDay, revertFunc, jsEvent, ui, view);
};

var event_alter = function event_alter(alterType, event, delta, allDay, revertFunc, jsEvent, ui, view) {
    var fake_form = {
        url: AgenDAVConf.base_app_url + "events/" + alterType,
        data: {
            uid: event.uid,
            calendar: event.calendar,
            etag: event.etag,
            delta: delta.asMinutes(),
            allday: allDay,
            was_allday: event.orig_allday,
            timezone: AgenDAVUserPrefs.timezone
        }
    };
    if (event.rrule !== undefined) {
        fake_form.data.recurrence_id = event.recurrence_id;
    }
    fake_form.data[csrf_id] = get_csrf_token();
    send_form({
        form_object: fake_form,
        success: function(data) {
            var is_recurrent = event.rrule !== undefined;
            updateEvents(event.id, is_recurrent, {
                etag: data.etag
            });
            updateEvents(event.id, false, {
                orig_allday: event.allDay
            });
            if (is_recurrent) {
                updateEvents(event.id, true, {
                    has_exceptions: true
                });
                updateEvents(event.id, false, {
                    is_exception: true
                });
            }
        },
        exception: function(data) {
            show_error(t("messages", "error_modfailed"), data);
            revertFunc();
        },
        error: function() {
            revertFunc();
        }
    });
};

var event_delete = function event_delete(event_id) {
    var data = get_event_data(event_id);
    if (data === undefined) {
        show_error(t("messages", "error_interfacefailure"), t("messages", "error_current_event_not_loaded"));
        return;
    }
    if (data.rrule === undefined) {
        event_delete_proceed(data);
        return;
    }
    event_delete_recurrent_dialog(data);
};

var event_delete_proceed = function event_delete_proceed(data, recurrence_id) {
    var remove_all_instances = false;
    if (typeof recurrence_id === "undefined") {
        recurrence_id = null;
        remove_all_instances = true;
    }
    var remove_params = {
        calendar: data.calendar,
        uid: data.uid,
        href: data.href,
        etag: data.etag,
        recurrence_id: recurrence_id
    };
    remove_params[csrf_id] = get_csrf_token();
    send_form({
        form_object: {
            url: AgenDAVConf.base_app_url + "events/delete",
            data: remove_params
        },
        success: function(rdata) {
            removeEvents(data.id, remove_all_instances);
        },
        exception: function(rdata) {
            show_error(t("messages", "error_event_not_deleted"), rdata);
        }
    });
};

var event_delete_recurrent_dialog = function event_delete_recurrent_dialog(data) {
    var button_only_this_repetition = {
        text: t("labels", "delete_only_this_repetition"),
        class: "addicon btn-icon-event-delete",
        click: function() {
            event_delete_proceed(data, data.recurrence_id);
            destroy_dialog("#event_delete_dialog");
        }
    };
    var button_all_repetitions = {
        text: t("labels", "delete_all_repetitions"),
        class: "addicon btn-icon-event-delete",
        click: function() {
            event_delete_proceed(data);
            destroy_dialog("#event_delete_dialog");
        }
    };
    var buttons = [ button_only_this_repetition, button_all_repetitions ];
    data.applyid = "event_delete_form";
    show_dialog({
        template: "event_delete_recurrent_dialog",
        data: data,
        title: t("labels", "deleteevent"),
        buttons: buttons,
        divname: "event_delete_dialog",
        width: 400
    });
};

var modify_event_handler = function modify_event_handler(event_id) {
    var current_event = get_event_data(event_id);
    if (current_event === undefined) {
        show_error(t("messages", "error_interfacefailure"), t("messages", "error_current_event_not_loaded"));
        return;
    }
    if (current_event.rrule === undefined) {
        open_event_edit_dialog(current_event);
        return;
    }
    open_event_modify_recurrent_dialog(current_event);
};

var open_event_modify_recurrent_dialog = function open_event_modify_recurrent_dialog(event) {
    var button_only_this_repetition = {
        text: t("labels", "edit_only_this_repetition"),
        class: "addicon btn-icon-event-edit",
        click: function() {
            destroy_dialog("#event_edit_recurrent_dialog");
            open_event_edit_dialog(event);
        }
    };
    var button_all_repetitions = {
        text: t("labels", "edit_all_repetitions"),
        class: "addicon btn-icon-event-edit",
        click: function() {
            destroy_dialog("#event_edit_recurrent_dialog");
            load_base_event_for(event, function(base) {
                open_event_edit_dialog(base);
            }, function(jqXHR, textStatus) {
                show_error(t("messages", "error_interfacefailure"), textStatus);
            });
        }
    };
    var buttons = [ button_only_this_repetition, button_all_repetitions ];
    show_dialog({
        template: "event_edit_recurrent_dialog",
        data: event,
        title: t("labels", "editevent"),
        buttons: buttons,
        divname: "event_edit_recurrent_dialog",
        width: 400
    });
};

var show_calendar = function show_calendar(calendar_obj) {
    $("#calendar_view").fullCalendar("addEventSource", calendar_obj.data().eventsource);
    calendar_obj.removeClass("hidden_calendar");
};

var hide_calendar = function hide_calendar(calendar_obj) {
    $("#calendar_view").fullCalendar("removeEventSource", calendar_obj.data().eventsource);
    calendar_obj.addClass("hidden_calendar");
};

var toggle_calendar = function toggle_calendar(calendar_obj) {
    if (calendar_obj.hasClass("hidden_calendar")) {
        show_calendar(calendar_obj);
    } else {
        hide_calendar(calendar_obj);
    }
};

var get_csrf_token = function get_csrf_token() {
    return csrf_value;
};

var loading = function loading(status) {
    var $loading = $("#loading");
    var $refresh = $("#button-refresh");
    if (status === false) {
        $refresh.removeAttr("disabled");
        $loading.hide();
    } else {
        $refresh.attr("disabled", "disabled");
        $loading.show();
    }
};

var beforePrint = function beforePrint() {
    $("#calendar_view").addClass("printing");
    $("#calendar_view").fullCalendar("render");
};

var afterPrint = function afterPrint() {
    $("#calendar_view").removeClass("printing");
    $("#calendar_view").fullCalendar("render");
};

var setup_print_tweaks = function setup_print_tweaks() {
    if (window.matchMedia) {
        var mediaQueryList = window.matchMedia("print");
        mediaQueryList.addListener(function(mql) {
            if (mql.matches) {
                beforePrint();
            } else {
                afterPrint();
            }
        });
    }
    window.onbeforeprint = beforePrint;
    window.onafterprint = afterPrint;
};

var calendar_list = function calendar_list() {
    var calendars = $("div.calendar_list li.available_calendar");
    var total = calendars.length;
    var result = [];
    for (var i = 0; i < total; i++) {
        result.push($(calendars[i]).data());
    }
    return result;
};

var render_template = function render(template_name, template_data, callback) {
    dust.render(template_name, dustbase.push(template_data), function(err, out) {
        if (err !== null) {
            show_error(t("messages", "error_interfacefailure"), err.message);
            return;
        }
        callback(out);
    });
};

var check_required_fields = function check_required_fields(form) {
    var result = true;
    form.find("input:required").each(function() {
        if ($(this).val() === "") {
            $(this).parent().addClass("has-error");
            $(this).focus();
            result = false;
            return true;
        }
        $(this).parent().removeClass("has-error");
    });
    return result;
};

var generate_iso8601_values = function generate_iso8601_values(element) {
    var matches = $(element).find("div.generate-iso8601");
    $.each(matches, function(index, div) {
        var datepicker = $(div).find("input.date");
        var timepicker = $(div).find("input.time");
        if (datepicker.val() === "") {
            $(div).find("input.generated").val("");
            return true;
        }
        var ignore_time = false;
        var ignore_time_data = $(div).data("only-date-if-checked");
        if (ignore_time_data !== undefined) {
            ignore_time = $(ignore_time_data + ":checked").length === 1;
        }
        $(div).find("input.generated").val(AgenDAVDateAndTime.convertISO8601(datepicker, timepicker, ignore_time, AgenDAVUserPrefs.timezone));
    });
};

var setTranslations = function setTranslations(data) {
    AgenDAVConf.i18n = data;
    set_default_datepicker_options();
    AgenDAVRepeat.language = AgenDAVRepeat.generateLanguage();
};

var t = function t(domain, key, params) {
    var full_key = domain + "." + key;
    var result = AgenDAVConf.i18n[full_key];
    if (result === undefined) {
        return full_key;
    }
    for (var i in params) {
        result = result.replace(i, params[i]);
    }
    return result;
};

var rrule_gettext = function rrule_gettext(key) {
    return t("rrule", key);
};

var updateEvents = function updateEvents(id, is_recurrent, new_properties) {
    var filter = generateIdFilter(id, is_recurrent);
    var events = $("#calendar_view").fullCalendar("clientEvents", filter);
    for (var i = 0; i < events.length; i++) {
        for (var property in new_properties) {
            events[i][property] = new_properties[property];
        }
        $("#calendar_view").fullCalendar("updateEvent", events[i]);
    }
    return events.length;
};

var removeEvents = function removeEvents(id, wildcard) {
    var filter = generateIdFilter(id, wildcard);
    $("#calendar_view").fullCalendar("removeEvents", filter);
};

var generateIdFilter = function generateIdFilter(id, wildcard) {
    var result = id;
    if (wildcard === true) {
        var parts = id.split("@");
        var match_id = parts[0];
        result = function(event) {
            if (event.id === undefined) {
                return false;
            }
            return event.id === id || event.id.substring(0, match_id.length + 1) == match_id + "@";
        };
    }
    return result;
};

var handle_expired_session = function handle_expired_session() {
    $(document).ajaxError(function(event, jqxhr, settings, thrownError) {
        if (jqxhr.status !== undefined && jqxhr.status == 401) {
            session_expired();
        }
    });
};

var AgenDAVDateAndTime = AgenDAVDateAndTime || {};

AgenDAVDateAndTime.fullCalendarFormat = {
    "24": "H:mm",
    "12": "h(:mm)a"
};

AgenDAVDateAndTime.momentFormat = {
    "24": "HH:mm",
    "12": "hh:mm A",
    ymd: "YYYY-MM-DD",
    dmy: "DD/MM/YYYY",
    mdy: "MM/DD/YYYY"
};

AgenDAVDateAndTime.datepickerFormat = {
    ymd: "yy-mm-dd",
    dmy: "dd/mm/yy",
    mdy: "mm/dd/yy"
};

AgenDAVDateAndTime.timepickerSettings = {
    "12": {
        timeFormat: "h:i A",
        step: 30,
        maxTime: "11:30 PM"
    },
    "24": {
        timeFormat: "H:i",
        step: 30,
        maxTime: "23:30"
    }
};

AgenDAVDateAndTime.extractTime = function extractTime(dateobj) {
    return moment(dateobj).format(AgenDAVDateAndTime.momentFormat[AgenDAVUserPrefs.time_format]);
};

AgenDAVDateAndTime.extractDate = function extractDate(dateobj) {
    return moment(dateobj).format(AgenDAVDateAndTime.momentFormat[AgenDAVUserPrefs.date_format]);
};

AgenDAVDateAndTime.approxNearest = function approxNearest(dt) {
    var now = moment();
    var minutes = Math.ceil(now.minutes() / 15) * 15;
    var result = moment(dt).hours(now.hours()).minutes(0).seconds(0).add(minutes, "minutes");
    return result;
};

AgenDAVDateAndTime.endDate = function endDate(event) {
    if (event.end === undefined || event.end === null || event.start.diff(event.end) === 0) {
        if (event.allDay === true) {
            return moment(event.start);
        }
        return moment(event.start).add(1, "hours");
    }
    return moment(event.end);
};

AgenDAVDateAndTime.formatEventDates = function formatEventDates(event_data) {
    var result = "";
    var start = moment(event_data.start);
    var end = moment(event_data.end);
    if (event_data.end === null) {
        var unit = event_data.allDay ? "days" : "hours";
        end = moment(event_data.start);
        end.add(1, unit);
    }
    if (event_data.allDay === true) {
        end.subtract(1, "days");
        result = start.format("LL");
        if (!start.isSame(end, "day")) {
            result += " - " + end.format("LL");
        }
        return result;
    }
    result = start.format("LL") + " " + this.extractTime(start);
    var end_string = end.format("LL") + " " + this.extractTime(end);
    if (start.isSame(end, "day")) {
        end_string = this.extractTime(end);
    }
    result += " - " + end_string;
    return result;
};

AgenDAVDateAndTime.convertISO8601 = function convertISO8601(datepicker, timepicker, allday, timezone) {
    var result = datepicker.datepicker("getDate");
    if (timepicker.length === 0 || allday === true) {
        return moment(result).format("YYYY-MM-DDT00:00:00.000") + "Z";
    }
    result = timepicker.timepicker("getTime", result);
    return moment.tz(moment(result).format("YYYY-MM-DDTHH:mm:ss.000"), timezone).toISOString();
};

AgenDAVDateAndTime.getMoment = function getMoment(iso8601string, timezone) {
    return moment.tz(iso8601string, timezone);
};

var AgenDAVRepeat = AgenDAVRepeat || {};

AgenDAVRepeat.handleForm = function handleForm($form) {
    var $fixed_repeat_rule = $("#fixed_repeat_rule");
    var $repeat_frequency = $("#repeat_frequency");
    var $repeat_ends = $("#repeat_ends");
    if ($fixed_repeat_rule.val() == "true") {
        $form.find("select, input").attr("disabled", "disabled");
        var original_rrule = RRule.fromString($("#rrule_original").val());
        $("#fixed_repeat_rule_explanation").html(AgenDAVRepeat.explainRRule(original_rrule));
        return;
    }
    $form.on("change", "input,select.secondary", function(e) {
        AgenDAVRepeat.regenerate();
    });
    $repeat_frequency.on("change", function() {
        var new_frequency = $(this).val();
        var frequency = parseInt(new_frequency);
        if (frequency === -1 || new_frequency === "keep-original") {
            $form.find(".container_repeat_options").hide();
        } else {
            $form.find(".container_repeat_options").show();
            AgenDAVRepeat.showAllowedFieldsByFrequency(frequency);
        }
        $repeat_ends.trigger("change");
    });
    $repeat_ends.on("change", function() {
        var container_repeat_ends_options = $form.find("div.container_repeat_ends_options");
        var ends = $(this).val();
        if (ends === "never") {
            container_repeat_ends_options.hide();
        }
        if (ends === "after") {
            container_repeat_ends_options.show();
            $form.find("div.container_repeat_count").show();
            $form.find("div.container_repeat_until").hide();
            $form.find("input.repeat_until").val("");
        }
        if (ends === "date") {
            container_repeat_ends_options.show();
            $form.find("div.container_repeat_count").hide();
            $form.find("div.container_repeat_until").show();
            $form.find("input.repeat_count").val("");
        }
        generate_iso8601_values($form);
        var new_rrule = AgenDAVRepeat.generateRRule($form.find("input,select").serializeArray());
        if (new_rrule === null) {
            $("#rrule").val("");
            $("#repeat_explanation").html("");
            return;
        }
        $("#rrule").val(new_rrule.toString());
        $("#repeat_explanation").html(AgenDAVRepeat.explainRRule(new_rrule));
    });
    AgenDAVRepeat.regenerate();
};

AgenDAVRepeat.regenerate = function regenerate() {
    $("#repeat_frequency").trigger("change");
};

AgenDAVRepeat.generateRRule = function generateRRule(data) {
    var frequency = -1;
    var options = {};
    var result;
    var ends;
    var by_day = [];
    var keep_original_rrule = false;
    $.each(data, function(i, field) {
        var value = field.value;
        if (value === "" || value === "-") {
            return true;
        }
        if (field.name === "repeat_frequency") {
            if (value === "keep-original") {
                keep_original_rrule = true;
                return false;
            }
            value = parseInt(value);
            if (value === -1) {
                return false;
            }
            frequency = value;
            options.freq = value;
        }
        if (field.name === "repeat_by_day" && AgenDAVRepeat.shouldConsider(frequency, field.name)) {
            by_day.push(AgenDAVRepeat.getRRuleJsByDay(value));
        }
        if (field.name === "repeat_by_month_day" && AgenDAVRepeat.shouldConsider(frequency, field.name)) {
            options.bymonthday = value;
        }
        if (field.name === "repeat_interval" && value !== "1") {
            options.interval = value;
        }
        if (field.name === "repeat_ends") {
            ends = field.value;
        }
        if (field.name === "repeat_count" && ends === "after") {
            options.count = value;
        }
        if (field.name === "repeat_until_date" && ends === "date") {
            var is_all_day = $("input.allday").is(":checked");
            options.until = AgenDAVRepeat.generateUntilDate(is_all_day);
            options.onlydate = is_all_day;
        }
    });
    if (by_day.length > 0) {
        options.byweekday = by_day;
    }
    if (keep_original_rrule === true) {
        var rrule_original = RRule.fromString($("#rrule_original").val());
        return rrule_original;
    }
    if (options.freq === undefined) {
        return null;
    }
    return new RRule(options);
};

AgenDAVRepeat.getRRuleJsByDay = function getRRuleJsByDay(day) {
    if (day === "sunday") {
        return RRule.SU;
    }
    if (day === "monday") {
        return RRule.MO;
    }
    if (day === "tuesday") {
        return RRule.TU;
    }
    if (day === "wednesday") {
        return RRule.WE;
    }
    if (day === "thursday") {
        return RRule.TH;
    }
    if (day === "friday") {
        return RRule.FR;
    }
    if (day === "saturday") {
        return RRule.SA;
    }
};

AgenDAVRepeat.getLabelForByDay = function gettLabelForByDay(day) {
    var days = [ "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday" ];
    return days[day];
};

AgenDAVRepeat.explainRRule = function explainRRule(rrule) {
    return rrule.toText(rrule_gettext, AgenDAVRepeat.language);
};

AgenDAVRepeat.generateLanguage = function generateLanguage() {
    return {
        dayNames: [ AgenDAVConf.i18n["labels.sunday"], AgenDAVConf.i18n["labels.monday"], AgenDAVConf.i18n["labels.tuesday"], AgenDAVConf.i18n["labels.wednesday"], AgenDAVConf.i18n["labels.thursday"], AgenDAVConf.i18n["labels.friday"], AgenDAVConf.i18n["labels.saturday"] ],
        monthNames: [ AgenDAVConf.i18n["labels.january"], AgenDAVConf.i18n["labels.february"], AgenDAVConf.i18n["labels.march"], AgenDAVConf.i18n["labels.april"], AgenDAVConf.i18n["labels.may"], AgenDAVConf.i18n["labels.june"], AgenDAVConf.i18n["labels.july"], AgenDAVConf.i18n["labels.august"], AgenDAVConf.i18n["labels.september"], AgenDAVConf.i18n["labels.october"], AgenDAVConf.i18n["labels.november"], AgenDAVConf.i18n["labels.december"] ]
    };
};

AgenDAVRepeat.allOptionalFields = [ "repeat_by_day", "repeat_by_month_day" ];

AgenDAVRepeat.getFieldsForFrequency = function getFieldsForFrequency(frequency) {
    if (frequency === RRule.DAILY) {
        return [ "repeat_by_day" ];
    }
    if (frequency === RRule.WEEKLY) {
        return [ "repeat_by_day" ];
    }
    if (frequency === RRule.MONTHLY) {
        return [ "repeat_by_month_day" ];
    }
    if (frequency === RRule.YEARLY) {
        return [];
    }
};

AgenDAVRepeat.showAllowedFieldsByFrequency = function showAllowedFieldsByFrequency(frequency) {
    var total_fields = AgenDAVRepeat.allOptionalFields.length;
    for (var i = 0; i < total_fields; i++) {
        var current_field = AgenDAVRepeat.allOptionalFields[i];
        if (AgenDAVRepeat.shouldConsider(frequency, current_field)) {
            $(".container_" + current_field).show();
        } else {
            $(".container_" + current_field).hide();
        }
    }
};

AgenDAVRepeat.shouldConsider = function shouldConsider(frequency, field) {
    var allowed = AgenDAVRepeat.getFieldsForFrequency(frequency);
    if (allowed.indexOf(field) === -1) {
        return false;
    }
    return true;
};

AgenDAVRepeat.setRepeatRuleOnForm = function setRepeatRuleOnForm(rrule, form) {
    var rrulejs = RRule.fromString(rrule);
    for (var param in rrulejs.origOptions) {
        var value = rrulejs.options[param];
        if (param === "freq") {
            $("#repeat_frequency").val(value);
            continue;
        }
        if (param === "interval") {
            $("#repeat_interval").val(value);
            continue;
        }
        if (param === "count") {
            $("#repeat_count").val(value);
            $("#repeat_ends").val("after");
            continue;
        }
        if (param === "until") {
            $("#repeat_until").datepicker("setDate", value);
            $("#repeat_ends").val("date");
            continue;
        }
        if (param === "bymonthday") {
            $("#repeat_by_month_day").val(value);
            continue;
        }
        if (param === "byweekday") {
            if (value === null) {
                value = rrulejs.origOptions[param];
            }
            for (var i = 0; i < value.length; i++) {
                var label = AgenDAVRepeat.getLabelForByDay(value[i]);
                form.find(".container_repeat_by_day [value=" + label + "]").prop("checked", true);
            }
            continue;
        }
        if (param === "onlydate") {
            continue;
        }
        console.log("Ooops, property " + param + " not supported");
    }
    AgenDAVRepeat.regenerate();
    var generated_rrule = RRule.fromString($("#rrule").val());
    var generated_description = generated_rrule.toText();
    var original_description = rrulejs.toText();
    if (generated_description !== original_description) {
        $("#repeat_frequency").prepend('<option value="keep-original">' + t("labels", "keep_rrule") + "</option>");
        $("#repeat_warning_rrule_unreproducible").show();
        $("#repeat_frequency").val("keep-original");
        AgenDAVRepeat.regenerate();
    }
};

AgenDAVRepeat.generateUntilDate = function generateUntilDate(is_allday) {
    if ($("#repeats_frequency").val() === "-1" || $("#repeat_ends").val() !== "date") {
        return false;
    }
    var until_date = $("#repeat_until").datepicker("getDate");
    if (until_date === null) {
        return false;
    }
    var result = moment(until_date);
    if (is_allday === false) {
        var start = moment($("#start").val());
        result.set("hour", start.get("hour"));
        result.set("minute", start.get("minute"));
        result.set("second", start.get("second"));
    }
    return result.toDate();
};

(function(dust) {
    dust.register("calendar_basic_form_part", body_0);
    function body_0(chk, ctx) {
        return chk.x(ctx.get([ "calendar" ], false), ctx, {
            block: body_1
        }, {}).w('<input type="hidden" name="is_shared"value="').x(ctx.get([ "is_shared" ], false), ctx, {
            else: body_2,
            block: body_3
        }, {}).w('" /><input type="hidden" name="is_owned"value="').x(ctx.get([ "is_owned" ], false), ctx, {
            else: body_4,
            block: body_5
        }, {}).w('" />').p("form_element_start", ctx, ctx, {
            for: "displayname",
            label: "displayname"
        }).w('<input required autofocus name="displayname" type="text" size="25" maxlength="255" value="').x(ctx.get([ "displayname" ], false), ctx, {
            block: body_6
        }, {}).w('" class="displayname form-control" />').p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "color",
            label: "color"
        }).w('<input name="calendar_color"value="').x(ctx.get([ "color" ], false), ctx, {
            else: body_7,
            block: body_8
        }, {}).w('" class="calendar_color pick_color form-control" maxlength="7" size="7" />').p("form_element_end", ctx, ctx, {}).x(ctx.get([ "public_url" ], false), ctx, {
            block: body_9
        }, {});
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w('<input type="hidden" name="calendar" value="').f(ctx.get([ "calendar" ], false), ctx, "h").w('" />');
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.w("false");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w("true");
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.w("false");
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w("true");
    }
    body_5.__dustBody = !0;
    function body_6(chk, ctx) {
        return chk.f(ctx.get([ "displayname" ], false), ctx, "h");
    }
    body_6.__dustBody = !0;
    function body_7(chk, ctx) {
        return chk.f(ctx.get([ "default_calendar_color" ], false), ctx, "h");
    }
    body_7.__dustBody = !0;
    function body_8(chk, ctx) {
        return chk.f(ctx.get([ "color" ], false), ctx, "h");
    }
    body_8.__dustBody = !0;
    function body_9(chk, ctx) {
        return chk.w('<div class="public_url_container"><i class="fa fa-lg fa-link"></i> <a href="').f(ctx.get([ "public_url" ], false), ctx, "h").w('">').h("i18n", ctx, {}, {
            type: "labels",
            name: "publicurl"
        }, "h").w("</p></a></div>");
    }
    body_9.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("calendar_create_dialog", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div id="calendar_create_dialog">').p("form_open", ctx, ctx, {
            applyclass: "form-horizontal",
            applyid: "calendar_create_form"
        }).p("calendar_basic_form_part", ctx, ctx, {}).p("form_close", ctx, ctx, {}).w("</div>");
    }
    body_0.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("calendar_delete_dialog", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div id="calendar_delete_dialog">').p("form_open", ctx, ctx, {}).w('<input type="hidden" name="calendar" value="').f(ctx.get([ "calendar" ], false), ctx, "h").w('" /><p>').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_confirmcaldelete"
        }, "h").w('</p><p><div class="calendar_color" style="background-color: ').f(ctx.get([ "color" ], false), ctx, "h").w(';"></div> ').f(ctx.get([ "displayname" ], false), ctx, "h").w("</p><p>").h("i18n", ctx, {}, {
            type: "messages",
            name: "info_permanentremoval"
        }, "h").w("</p>").p("form_close", ctx, ctx, {}).w("</div>");
    }
    body_0.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("calendar_list_entry", body_0);
    function body_0(chk, ctx) {
        return chk.w('<li data-calendar-url="').f(ctx.get([ "url" ], false), ctx, "h").w('" class="available_calendar').x(ctx.get([ "default_calendar" ], false), ctx, {
            block: body_1
        }, {}).w('"><i class="calendar_color fa fa-lg fa-square fa-li" style="color: ').x(ctx.get([ "color" ], false), ctx, {
            else: body_2,
            block: body_3
        }, {}).w('"></i><span class="icons">').x(ctx.get([ "is_shared" ], false), ctx, {
            block: body_4
        }, {}).x(ctx.get([ "is_owned" ], false), ctx, {
            block: body_6
        }, {}).w('</span><span class="text"').nx(ctx.get([ "is_owned" ], false), ctx, {
            block: body_8
        }, {}).w(">").f(ctx.get([ "displayname" ], false), ctx, "h").w('</span><i title="').h("i18n", ctx, {}, {
            type: "labels",
            name: "modifycalendar"
        }, "h").w('" class="cfg pseudobutton fa fa-cogs"></i></li>');
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w(" default_calendar");
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.f(ctx.get([ "default_calendar_color" ], false), ctx, "h");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.f(ctx.get([ "color" ], false), ctx, "h");
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.nx(ctx.get([ "writable" ], false), ctx, {
            block: body_5
        }, {});
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w('<i title="').h("i18n", ctx, {}, {
            type: "labels",
            name: "readonly"
        }, "h").w('" class="fa fa-lock"></i>');
    }
    body_5.__dustBody = !0;
    function body_6(chk, ctx) {
        return chk.h("gt", ctx, {
            block: body_7
        }, {
            key: ctx.getPath(false, [ "shares", "length" ]),
            value: 0
        }, "h");
    }
    body_6.__dustBody = !0;
    function body_7(chk, ctx) {
        return chk.w('<i title="').h("i18n", ctx, {}, {
            type: "labels",
            name: "currentlysharing"
        }, "h").w('" class="fa fa-share"></i>');
    }
    body_7.__dustBody = !0;
    function body_8(chk, ctx) {
        return chk.w('title="').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_sharedby",
            user: body_9
        }, "h").w('"');
    }
    body_8.__dustBody = !0;
    function body_9(chk, ctx) {
        return chk.f(ctx.get([ "owner" ], false), ctx, "h");
    }
    body_9.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("calendar_modify_dialog", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div id="calendar_modify_dialog">').p("form_open", ctx, ctx, {
            applyclass: "form-horizontal",
            applyid: "calendar_modify_form"
        }).w('<ul class="nav nav-tabs" role="tablist"><li role="presentation" class="active"><a role="tab" href="#tabs-general" data-toggle="tab"><i class="tab-icon fa fa-tag"></i>').h("i18n", ctx, {}, {
            type: "labels",
            name: "generaloptions"
        }, "h").w("</a></li>").x(ctx.get([ "enable_calendar_sharing" ], false), ctx, {
            block: body_1
        }, {}).w('</ul><div class="tab-content"><div role="tabpanel" id="tabs-general" class="tab-pane active">').nx(ctx.get([ "is_owned" ], false), ctx, {
            block: body_3
        }, {}).p("calendar_basic_form_part", ctx, ctx, {}).w("</div>").x(ctx.get([ "enable_calendar_sharing" ], false), ctx, {
            block: body_7
        }, {}).w("</div><!-- tab-content -->").p("form_close", ctx, ctx, {}).w("</div>");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.nx(ctx.get([ "is_shared" ], false), ctx, {
            block: body_2
        }, {});
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.w('<li role="presentation"><a role="tab" href="#tabs-share" data-toggle="tab"><i class="tab-icon fa fa-group"></i>').h("i18n", ctx, {}, {
            type: "labels",
            name: "shareoptions"
        }, "h").w("</a></li>");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w('<div class="share_info ui-corner-all">').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_sharedby",
            user: body_4
        }, "h").w(" ").h("eq", ctx, {
            block: body_5
        }, {
            key: body_6,
            value: "0"
        }, "h").w("</div>");
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.f(ctx.get([ "owner" ], false), ctx, "h");
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w("(").h("i18n", ctx, {}, {
            type: "labels",
            name: "readonly"
        }, "h").w(")");
    }
    body_5.__dustBody = !0;
    function body_6(chk, ctx) {
        return chk.f(ctx.get([ "rw" ], false), ctx, "h");
    }
    body_6.__dustBody = !0;
    function body_7(chk, ctx) {
        return chk.nx(ctx.get([ "is_shared" ], false), ctx, {
            block: body_8
        }, {});
    }
    body_7.__dustBody = !0;
    function body_8(chk, ctx) {
        return chk.w('<div role="tabpanel" id="tabs-share" class="tab-pane">').p("calendar_share_table", ctx, ctx, {}).w("</div>");
    }
    body_8.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("calendar_share_access_options", body_0);
    function body_0(chk, ctx) {
        return chk.w(' <option value="0"').h("eq", ctx, {
            block: body_1
        }, {
            key: body_2,
            value: "0"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "readonly"
        }, "h").w('</option><option value="1"').h("eq", ctx, {
            block: body_3
        }, {
            key: body_4,
            value: "1"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "readandwrite"
        }, "h").w("</option>");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w(' selected="true"');
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.f(ctx.get([ "rw" ], false), ctx, "h");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w(' selected="true"');
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.f(ctx.get([ "rw" ], false), ctx, "h");
    }
    body_4.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("calendar_share_row", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div class="form-group row share"').x(ctx.get([ "new" ], false), ctx, {
            block: body_1
        }, {}).w('><div class="col-md-12"><div class="col-md-6">').nx(ctx.get([ "new" ], false), ctx, {
            block: body_2
        }, {}).x(ctx.get([ "new" ], false), ctx, {
            block: body_4
        }, {}).w('</div><div class="col-md-4">').nx(ctx.get([ "new" ], false), ctx, {
            block: body_5
        }, {}).x(ctx.get([ "new" ], false), ctx, {
            block: body_6
        }, {}).p("calendar_share_access_options", ctx, ctx, {}).w('</select></div><div class="col-md-2"><p class="form-control-static"><a href="javascript:void(0)" class="remove"><i class="fa fa-remove fa-fw"></i></a></p></div></div></div>');
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w(' id="calendar_share_add_row"');
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.w('<input type="hidden" name="shares[with][]" value="').f(ctx.get([ "with" ], false), ctx, "h").w('" /><p class="form-control-static"><span class="username" title="').f(ctx.get([ "with" ], false), ctx, "h").w('">').f(ctx.get([ "displayname" ], false), ctx, "h").w("</span>").x(ctx.get([ "email" ], false), ctx, {
            block: body_3
        }, {}).w("</p>");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w("<em> &lt;").f(ctx.get([ "email" ], false), ctx, "h").w("&gt;</em>");
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.w('<input name="filter" class="form-control" id="calendar_share_filter" value="" maxlength="255" size="10" />');
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w('<select name="shares[rw][]" class="form-control">');
    }
    body_5.__dustBody = !0;
    function body_6(chk, ctx) {
        return chk.w('<select name="new_rw" class="form-control" id="calendar_share_add_rw">');
    }
    body_6.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("calendar_share_table", body_0);
    function body_0(chk, ctx) {
        return chk.w('<p id="no_shares" class="text-center">').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_notshared"
        }, "h").w('</p><div id="shares">').s(ctx.get([ "shares" ], false), ctx, {
            block: body_1
        }, {}).w('</div><div class="text-right"><a href="javascript:void(0)" id="new_share"><i class="fa fa-plus"></i> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "add_share"
        }, "h").w("</a></div>");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.p("calendar_share_row", ctx, ctx, {});
    }
    body_1.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("datepicker_button", body_0);
    function body_0(chk, ctx) {
        return chk.w('<i class="btn fa fa-calendar" title="').h("i18n", ctx, {}, {
            type: "labels",
            name: "choose_date"
        }, "h").w('"></i><input type="text" style="width: 0;height: 0;border:0;" id="datepicker_fullcalendar" />');
    }
    body_0.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("event_basic_form_part", body_0);
    function body_0(chk, ctx) {
        return chk.x(ctx.get([ "uid" ], false), ctx, {
            block: body_1
        }, {}).p("form_element_start", ctx, ctx, {
            for: "summary",
            label: "summary"
        }).w('<input required name="summary" type="text" size="25" maxlength="255" value="').f(ctx.get([ "title" ], false), ctx, "h").w('" class="summary form-control" />').p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "location",
            label: "location"
        }).w('<input name="location" type="text" size="25" maxlength="255" value="').f(ctx.get([ "location" ], false), ctx, "h").w('" class="location form-control" />').p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "calendar",
            label: "calendar"
        }).w('<select name="calendar" class="form-control"').x(ctx.get([ "fixed_calendar" ], false), ctx, {
            block: body_4
        }, {}).w(">").s(ctx.get([ "calendars" ], false), ctx, {
            block: body_5
        }, {
            current_calendar: ctx.get([ "calendar" ], false)
        }).w("</select>").p("form_element_end", ctx, ctx, {}).w('<div class="generate-iso8601" data-only-date-if-checked="input.allday"><input class="generated" type="hidden" name="start" id="start" />').p("form_element_start", ctx, ctx, {
            for: "start_date",
            label: "startdate"
        }).w('<div class="row"><div class="col-sm-4"><input required name="start_date" type="text" size="15" maxlength="10" value="').f(ctx.get([ "start_date" ], false), ctx, "h").w('"class="start_date date form-control" /></div><div class="col-sm-3"><input required name="start_time" type="text" size="15" maxlength="10" value="').f(ctx.get([ "start_time" ], false), ctx, "h").w('" class="start_time time form-control" /></div></div>').p("form_element_end", ctx, ctx, {}).w('</div><div class="generate-iso8601" data-only-date-if-checked="input.allday"><input class="generated" type="hidden" name="end" id="end">').p("form_element_start", ctx, ctx, {
            for: "end_date",
            label: "enddate"
        }).w('<div class="row"><div class="col-sm-4"><input required name="end_date" type="text" size="15" maxlength="10" value="').f(ctx.get([ "end_date" ], false), ctx, "h").w('" class="end_date date form-control" /></div><div class="col-sm-3"><input required name="end_time" type="text" size="15" maxlength="10" value="').f(ctx.get([ "end_time" ], false), ctx, "h").w('" class="time end_time time form-control" /></div></div>').p("form_element_end", ctx, ctx, {}).w("</div>").p("form_element_start", ctx, ctx, {
            for: "allday",
            label: "alldayform"
        }).w('<div class="checkbox"><label><input type="checkbox" name="allday" class="allday" value="true" ').x(ctx.get([ "allDay" ], false), ctx, {
            block: body_9
        }, {}).w(" /></label></div>").p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "description",
            label: "description"
        }).w('<textarea name="description" class="form-control" rows="4">').f(ctx.get([ "description" ], false), ctx, "h").w("</textarea>").p("form_element_end", ctx, ctx, {});
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w('<input type="hidden" name="modification" value="true" /><input type="hidden" name="uid" value="').f(ctx.get([ "uid" ], false), ctx, "h").w('" /><input type="hidden" name="href" value="').f(ctx.get([ "href" ], false), ctx, "h").w('" /><input type="hidden" name="etag" value="').f(ctx.get([ "etag" ], false), ctx, "h").w('" /><input type="hidden" name="original_calendar" value="').f(ctx.get([ "calendar" ], false), ctx, "h").w('" />').x(ctx.get([ "recurrence_id" ], false), ctx, {
            block: body_2
        }, {}).x(ctx.get([ "fixed_calendar" ], false), ctx, {
            block: body_3
        }, {});
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.w('<input type="hidden" name="recurrence_id" value="').f(ctx.get([ "recurrence_id" ], false), ctx, "h").w('" />');
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w('<input type="hidden" name="calendar" value="').f(ctx.get([ "calendar" ], false), ctx, "h").w('" />');
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.w(' disabled="disabled"');
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w('<option value="').f(ctx.get([ "url" ], false), ctx, "h").w('"').h("eq", ctx, {
            block: body_6
        }, {
            key: body_7,
            value: body_8
        }, "h").w(">").f(ctx.get([ "displayname" ], false), ctx, "h").w("</option>");
    }
    body_5.__dustBody = !0;
    function body_6(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_6.__dustBody = !0;
    function body_7(chk, ctx) {
        return chk.f(ctx.get([ "calendar" ], false), ctx, "h");
    }
    body_7.__dustBody = !0;
    function body_8(chk, ctx) {
        return chk.f(ctx.get([ "current_calendar" ], false), ctx, "h");
    }
    body_8.__dustBody = !0;
    function body_9(chk, ctx) {
        return chk.w('checked="checked"');
    }
    body_9.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("event_delete_recurrent_dialog", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div id="event_delete_dialog">').x(ctx.get([ "first_instance" ], false), ctx, {
            else: body_1,
            block: body_2
        }, {}).w("</div>");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w("<p>").h("i18n", ctx, {}, {
            type: "messages",
            name: "info_delete_recurrent_event"
        }, "h").w("</p>");
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.w("<p>").h("i18n", ctx, {}, {
            type: "messages",
            name: "info_delete_recurrent_event_first_instance"
        }, "h").w("</p>");
    }
    body_2.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("event_details_popup", body_0);
    function body_0(chk, ctx) {
        return chk.w('<p class="start_and_finish">').f(ctx.get([ "readable_dates" ], false), ctx, "h").w('</p><dl class="dl-horizontal"><dt>').h("i18n", ctx, {}, {
            type: "labels",
            name: "calendar"
        }, "h").w('</dt><dd><i class="calendar_color fa fa-lg fa-square" style="color: ').f(ctx.getPath(false, [ "caldata", "color" ]), ctx, "h").w('"></i>').f(ctx.getPath(false, [ "caldata", "displayname" ]), ctx, "h").w("</dd>").x(ctx.get([ "location" ], false), ctx, {
            block: body_1
        }, {}).x(ctx.get([ "description" ], false), ctx, {
            block: body_2
        }, {}).x(ctx.get([ "rrule" ], false), ctx, {
            block: body_3
        }, {}).s(ctx.get([ "reminders" ], false), ctx, {
            block: body_4
        }, {}).w("</dl>").nx(ctx.get([ "disable_actions" ], false), ctx, {
            block: body_5
        }, {});
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w("<dt>").h("i18n", ctx, {}, {
            type: "labels",
            name: "location"
        }, "h").w("</dt><dd>").f(ctx.get([ "location" ], false), ctx, "h").w("</dd>");
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.w("<dt>").h("i18n", ctx, {}, {
            type: "labels",
            name: "description"
        }, "h").w("</dt><dd>").f(ctx.get([ "description" ], false), ctx, "h").w("</dd>");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w("<dt>").h("i18n", ctx, {}, {
            type: "labels",
            name: "repeat"
        }, "h").w("</dt><dd>").f(ctx.get([ "rrule_explained" ], false), ctx, "h").w("</dd>");
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.w("<dt>").h("i18n", ctx, {}, {
            type: "labels",
            name: "reminder"
        }, "h").w("</dt><dd>").p("reminder_description", ctx, ctx, {}).w("</dd>");
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w('<div class="actions"><span class="right"><a href="javascript:void(0)" data-event-id="').f(ctx.get([ "id" ], false), ctx, "h").w('" class="modify">').h("i18n", ctx, {}, {
            type: "labels",
            name: "modify"
        }, "h").w('</a></span><span class="left"><a href="javascript:void(0)" data-event-id="').f(ctx.get([ "id" ], false), ctx, "h").w('" class="remove">').h("i18n", ctx, {}, {
            type: "labels",
            name: "delete"
        }, "h").w("</a></span></div>");
    }
    body_5.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("event_edit_dialog", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div id="event_edit_dialog">').p("form_open", ctx, ctx, {
            applyclass: "form-horizontal",
            applyid: "event_edit_form"
        }).w('<ul class="nav nav-tabs" role="tablist"><li role="presentation" class="active"><a role="tab" href="#tabs-general" data-toggle="tab"><i class="tab-icon fa fa-tag"></i>').h("i18n", ctx, {}, {
            type: "labels",
            name: "generaloptions"
        }, "h").w('</a></li><li role="presentation"><a role="tab" href="#tabs-recurrence" data-toggle="tab"><i class="tab-icon fa fa-repeat"></i>').h("i18n", ctx, {}, {
            type: "labels",
            name: "repeatoptions"
        }, "h").w('</a></li><li role="presentation"><a role="tab" href="#tabs-reminders" data-toggle="tab"><i class="tab-icon fa fa-bell"></i>').h("i18n", ctx, {}, {
            type: "labels",
            name: "remindersoptions"
        }, "h").w('</a></li><li role="presentation"><a role="tab" href="#tabs-workgroup" data-toggle="tab"><i class="tab-icon fa fa-group"></i>').h("i18n", ctx, {}, {
            type: "labels",
            name: "workgroupoptions"
        }, "h").w('</a></li></ul><div class="tab-content"><div role="tabpanel" class="tab-pane active" id="tabs-general">').p("event_basic_form_part", ctx, ctx, {}).w('</div><div role="tabpanel" class="tab-pane" id="tabs-recurrence">').p("repeat_rule_form", ctx, ctx, {}).w('</div><div role="tabpanel" class="tab-pane" id="tabs-reminders">').p("reminders", ctx, ctx, {}).w('</div><div role="tabpanel" class="tab-pane" id="tabs-workgroup">').p("form_element_start", ctx, ctx, {
            for: "class",
            label: "privacy"
        }).w('<select name="class" type="text" class="form-control"><option value="PUBLIC"').h("eq", ctx, {
            block: body_1
        }, {
            key: body_2,
            value: "PUBLIC"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "public"
        }, "h").w('</option><option value="PRIVATE"').h("eq", ctx, {
            block: body_3
        }, {
            key: body_4,
            value: "PRIVATE"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "private"
        }, "h").w('</option><option value="CONFIDENTIAL"').h("eq", ctx, {
            block: body_5
        }, {
            key: body_6,
            value: "CONFIDENTIAL"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "confidential"
        }, "h").w("</option></select>").p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "transp",
            label: "transp"
        }).w('<select name="transp" type="text" class="form-control"><option value="OPAQUE"').h("eq", ctx, {
            block: body_7
        }, {
            key: body_8,
            value: "OPAQUE"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "opaque"
        }, "h").w('</option><option value="TRANSPARENT"').h("eq", ctx, {
            block: body_9
        }, {
            key: body_10,
            value: "TRANSPARENT"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "transparent"
        }, "h").w("</option></select>").p("form_element_end", ctx, ctx, {}).w("</div></div><!-- tab-content -->").p("form_close", ctx, ctx, {}).w("</div>");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.f(ctx.get([ "icalendar_class" ], false), ctx, "h");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.f(ctx.get([ "icalendar_class" ], false), ctx, "h");
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_5.__dustBody = !0;
    function body_6(chk, ctx) {
        return chk.f(ctx.get([ "icalendar_class" ], false), ctx, "h");
    }
    body_6.__dustBody = !0;
    function body_7(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_7.__dustBody = !0;
    function body_8(chk, ctx) {
        return chk.f(ctx.get([ "transp" ], false), ctx, "h");
    }
    body_8.__dustBody = !0;
    function body_9(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_9.__dustBody = !0;
    function body_10(chk, ctx) {
        return chk.f(ctx.get([ "transp" ], false), ctx, "h");
    }
    body_10.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("event_edit_recurrent_dialog", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div id="event_edit_recurrent_dialog"><p>').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_edit_recurrent_event"
        }, "h").w("</p>").x(ctx.get([ "has_exceptions" ], false), ctx, {
            block: body_1
        }, {}).w("</div>");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w("<p>").h("i18n", ctx, {}, {
            type: "messages",
            name: "info_base_event_with_exceptions_modification"
        }, "h").w("</p>");
    }
    body_1.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("form_close", body_0);
    function body_0(chk, ctx) {
        return chk.w("</form>");
    }
    body_0.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("form_element_end", body_0);
    function body_0(chk, ctx) {
        return chk.x(ctx.get([ "input_help" ], false), ctx, {
            block: body_1
        }, {}).w("</div></div>");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w('<p class="help-block">').f(ctx.get([ "input_help" ], false), ctx, "h").w("</p>");
    }
    body_1.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("form_element_start", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div class="form-group ').f(ctx.get([ "class" ], false), ctx, "h").w('"><label ').x(ctx.get([ "for" ], false), ctx, {
            block: body_1
        }, {}).w('class="col-sm-3 control-label">').h("i18n", ctx, {}, {
            type: "labels",
            name: ctx.get([ "label" ], false)
        }, "h").w('</label><div class="col-sm-9">');
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w('for="').f(ctx.get([ "for" ], false), ctx, "h").w('"');
    }
    body_1.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("form_open", body_0);
    function body_0(chk, ctx) {
        return chk.w('<form action="').f(ctx.getPath(false, [ "frm", "action" ]), ctx, "h").w('" method="').f(ctx.getPath(false, [ "frm", "method" ]), ctx, "h").w('"').x(ctx.get([ "applyclass" ], false), ctx, {
            block: body_1
        }, {}).x(ctx.get([ "applyid" ], false), ctx, {
            block: body_2
        }, {}).w(' accept-charset="utf-8"><input type="hidden" name="').f(ctx.get([ "csrf_token_name" ], false), ctx, "h").w('" value="').f(ctx.get([ "csrf_token_value" ], false), ctx, "h").w('">');
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w('class="').f(ctx.get([ "applyclass" ], false), ctx, "h").w('"');
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.w(' id="').f(ctx.get([ "applyid" ], false), ctx, "h").w('"');
    }
    body_2.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("reminder_row", body_0);
    function body_0(chk, ctx) {
        return chk.w('<div class="form-group row reminder"><div class="col-md-12"><div class="col-md-2"><input class="form-control" type="text" name="reminders[count][]" value="').x(ctx.get([ "count" ], false), ctx, {
            else: body_1,
            block: body_2
        }, {}).w('"/></div><div class="col-md-4"><select class="form-control" name="reminders[unit][]"><option value="minutes"').h("eq", ctx, {
            block: body_3
        }, {
            key: body_4,
            value: "minutes"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "minutes"
        }, "h").w('</option><option value="hours"').h("eq", ctx, {
            block: body_5
        }, {
            key: body_6,
            value: "hours"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "hours"
        }, "h").w('</option><option value="days"').h("eq", ctx, {
            block: body_7
        }, {
            key: body_8,
            value: "days"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "days"
        }, "h").w('</option><option value="weeks"').h("eq", ctx, {
            block: body_9
        }, {
            key: body_10,
            value: "weeks"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "weeks"
        }, "h").w('</option><option value="months"').h("eq", ctx, {
            block: body_11
        }, {
            key: body_12,
            value: "months"
        }, "h").w(">").h("i18n", ctx, {}, {
            type: "labels",
            name: "months"
        }, "h").w('</option></select></div><div class="col-md-4"><p class="form-control-static">').h("i18n", ctx, {}, {
            type: "labels",
            name: "before_start"
        }, "h").w('</p></div><div class="col-md-2"><p class="form-control-static"><a href="javascript:void(0)" class="remove"><i class="fa fa-remove fa-fw"></i></a></p></div></div></div>');
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w("0");
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.f(ctx.get([ "count" ], false), ctx, "h");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.f(ctx.get([ "unit" ], false), ctx, "h");
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_5.__dustBody = !0;
    function body_6(chk, ctx) {
        return chk.f(ctx.get([ "unit" ], false), ctx, "h");
    }
    body_6.__dustBody = !0;
    function body_7(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_7.__dustBody = !0;
    function body_8(chk, ctx) {
        return chk.f(ctx.get([ "unit" ], false), ctx, "h");
    }
    body_8.__dustBody = !0;
    function body_9(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_9.__dustBody = !0;
    function body_10(chk, ctx) {
        return chk.f(ctx.get([ "unit" ], false), ctx, "h");
    }
    body_10.__dustBody = !0;
    function body_11(chk, ctx) {
        return chk.w(' selected="selected"');
    }
    body_11.__dustBody = !0;
    function body_12(chk, ctx) {
        return chk.f(ctx.get([ "unit" ], false), ctx, "h");
    }
    body_12.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("reminder_description", body_0);
    function body_0(chk, ctx) {
        return chk.f(ctx.get([ "count" ], false), ctx, "h").w(" ").h("select", ctx, {
            block: body_1
        }, {
            key: body_7
        }, "h").w(" ").h("i18n", ctx, {}, {
            type: "labels",
            name: "before_start"
        }, "h");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.h("eq", ctx, {
            block: body_2
        }, {
            value: "minutes"
        }, "h").h("eq", ctx, {
            block: body_3
        }, {
            value: "hours"
        }, "h").h("eq", ctx, {
            block: body_4
        }, {
            value: "days"
        }, "h").h("eq", ctx, {
            block: body_5
        }, {
            value: "weeks"
        }, "h").h("eq", ctx, {
            block: body_6
        }, {
            value: "months"
        }, "h");
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.h("i18n", ctx, {}, {
            type: "labels",
            name: "minutes"
        }, "h");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.h("i18n", ctx, {}, {
            type: "labels",
            name: "hours"
        }, "h");
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.h("i18n", ctx, {}, {
            type: "labels",
            name: "days"
        }, "h");
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.h("i18n", ctx, {}, {
            type: "labels",
            name: "weeks"
        }, "h");
    }
    body_5.__dustBody = !0;
    function body_6(chk, ctx) {
        return chk.h("i18n", ctx, {}, {
            type: "labels",
            name: "months"
        }, "h");
    }
    body_6.__dustBody = !0;
    function body_7(chk, ctx) {
        return chk.f(ctx.get([ "unit" ], false), ctx, "h");
    }
    body_7.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("reminders", body_0);
    function body_0(chk, ctx) {
        return chk.w('<p class="text-center" id="no_reminders">').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_noreminders"
        }, "h").w('</p><div class="text-center" id="reminders">').s(ctx.get([ "reminders" ], false), ctx, {
            block: body_1
        }, {}).w('</div><div class="text-right"><a href="javascript:void(0)" id="new_reminder"><i class="fa fa-plus"></i> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "add_reminder"
        }, "h").w('</a></div><hr><p><small class="alert">').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_reminders_agendav_support"
        }, "h").w("</small></p>");
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.p("reminder_row", ctx, ctx, {});
    }
    body_1.__dustBody = !0;
    return body_0;
})(dust);

(function(dust) {
    dust.register("repeat_rule_form", body_0);
    function body_0(chk, ctx) {
        return chk.w('<p id="repeat_warning_rrule_unreproducible" class="text-warning">').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_rrule_not_reproducible"
        }, "h").w("</p>").x(ctx.get([ "fixed_repeat_rule" ], false), ctx, {
            block: body_1
        }, {}).w('<input type="hidden" name="fixed_repeat_rule" id="fixed_repeat_rule" value="').f(ctx.get([ "fixed_repeat_rule" ], false), ctx, "h").w('"><input type="hidden" name="rrule" id="rrule" value="').f(ctx.get([ "rrule" ], false), ctx, "h").w('"><input type="hidden" name="rrule_original" id="rrule_original" value="').f(ctx.get([ "rrule" ], false), ctx, "h").w('">').nx(ctx.get([ "fixed_repeat_rule" ], false), ctx, {
            block: body_2
        }, {});
    }
    body_0.__dustBody = !0;
    function body_1(chk, ctx) {
        return chk.w('<p id="repeat_warning_rrule_fixed" class="text-warning">').h("i18n", ctx, {}, {
            type: "messages",
            name: "info_rrule_protected"
        }, "h").w("</p>").p("form_element_start", ctx, ctx, {
            for: "",
            label: "repeat_explanation"
        }).w('<p class="form-control-static" id="fixed_repeat_rule_explanation"></p>').p("form_element_end", ctx, ctx, {});
    }
    body_1.__dustBody = !0;
    function body_2(chk, ctx) {
        return chk.p("form_element_start", ctx, ctx, {
            for: "frequency",
            label: "repeat"
        }).w('<select name="repeat_frequency" class="form-control" id="repeat_frequency"><option value="-1">').h("i18n", ctx, {}, {
            type: "labels",
            name: "repeatno"
        }, "h").w('</option><option value="').f(ctx.get([ "daily" ], false), ctx, "h").w('">').h("i18n", ctx, {}, {
            type: "labels",
            name: "repeatdaily"
        }, "h").w('</option><option value="').f(ctx.get([ "weekly" ], false), ctx, "h").w('">').h("i18n", ctx, {}, {
            type: "labels",
            name: "repeatweekly"
        }, "h").w('</option><option value="').f(ctx.get([ "monthly" ], false), ctx, "h").w('">').h("i18n", ctx, {}, {
            type: "labels",
            name: "repeatmonthly"
        }, "h").w('</option><option value="').f(ctx.get([ "yearly" ], false), ctx, "h").w('">').h("i18n", ctx, {}, {
            type: "labels",
            name: "repeatyearly"
        }, "h").w("</option></select>").p("form_element_end", ctx, ctx, {}).w('<div class="container_repeat_options">').p("form_element_start", ctx, ctx, {
            for: "interval",
            label: "every"
        }).w('<div class="col-md-3"><select name="repeat_interval" class="secondary form-control" id ="repeat_interval">').s(ctx.get([ "numbers1to31" ], false), ctx, {
            block: body_3
        }, {}).w("</select></div>").p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "byday",
            label: "repeat_by_day",
            class: "container_repeat_by_day"
        }).w('<label class="checkbox-inline"><input class="secondary" type="checkbox" name="repeat_by_day" value="sunday"> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "sunday_short"
        }, "h").w('</label><label class="checkbox-inline"><input class="secondary" type="checkbox" name="repeat_by_day" value="monday"> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "monday_short"
        }, "h").w('</label><label class="checkbox-inline"><input class="secondary" type="checkbox" name="repeat_by_day" value="tuesday"> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "tuesday_short"
        }, "h").w('</label><label class="checkbox-inline"><input class="secondary" type="checkbox" name="repeat_by_day" value="wednesday"> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "wednesday_short"
        }, "h").w('</label><label class="checkbox-inline"><input class="secondary" type="checkbox" name="repeat_by_day" value="thursday"> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "thursday_short"
        }, "h").w('</label><label class="checkbox-inline"><input class="secondary" type="checkbox" name="repeat_by_day" value="friday"> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "friday_short"
        }, "h").w('</label><label class="checkbox-inline"><input class="secondary" type="checkbox" name="repeat_by_day" value="saturday"> ').h("i18n", ctx, {}, {
            type: "labels",
            name: "saturday_short"
        }, "h").w("</label>").p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "repeat_by_month_day",
            label: "repeat_by_month_day",
            class: "container_repeat_by_month_day"
        }).w('<div class="col-md-3"><select name="repeat_by_month_day" class="secondary form-control" id="repeat_by_month_day"><option value="">-</option>').s(ctx.get([ "numbers1to31" ], false), ctx, {
            block: body_4
        }, {}).w("</select></div>").p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "",
            label: "ends",
            class: "container_repeat_ends"
        }).w('<div class="row"><div class="col-md-5"><select name="repeat_ends" class="form-control" id="repeat_ends"><option value="never">').h("i18n", ctx, {}, {
            type: "labels",
            name: "never"
        }, "h").w('</option><option value="after">').h("i18n", ctx, {}, {
            type: "labels",
            name: "after"
        }, "h").w('</option><option value="date">').h("i18n", ctx, {}, {
            type: "labels",
            name: "choose_date"
        }, "h").w('</option></select></div><div class="col-md-5 container_repeat_ends_options"><div class="container_repeat_count"><div class="col-md-6"><select name="repeat_count" class="secondary form-control" id="repeat_count">').s(ctx.get([ "numbers1to31" ], false), ctx, {
            block: body_5
        }, {}).w('</select></div><div class="col-md-6"><p class="form-control-static">').h("i18n", ctx, {}, {
            type: "labels",
            name: "occurrences"
        }, "h").w('</p></div></div><!-- container_recurence_count --><div class="generate-iso8601 container_repeat_until"><input type="hidden" class="generated" name="repeat_until_date" /><input type="text" name="repeat_until" class="date form-control" id="repeat_until" maxlength="10" size="15"/></div><!-- container_repeat_until --></div><!-- container_repeat_ends_options, inside container_repeat_ends --></div><!-- row, inside container_repeat_ends -->').p("form_element_end", ctx, ctx, {}).p("form_element_start", ctx, ctx, {
            for: "",
            label: "repeat_explanation"
        }).w('<p class="form-control-static" id="repeat_explanation"></p>').p("form_element_end", ctx, ctx, {}).w("</div>");
    }
    body_2.__dustBody = !0;
    function body_3(chk, ctx) {
        return chk.w('<option value="').f(ctx.getPath(true, []), ctx, "h").w('">').f(ctx.getPath(true, []), ctx, "h").w("</option>");
    }
    body_3.__dustBody = !0;
    function body_4(chk, ctx) {
        return chk.w('<option value="').f(ctx.getPath(true, []), ctx, "h").w('">').f(ctx.getPath(true, []), ctx, "h").w("</option>");
    }
    body_4.__dustBody = !0;
    function body_5(chk, ctx) {
        return chk.w('<option value="').f(ctx.getPath(true, []), ctx, "h").w('">').f(ctx.getPath(true, []), ctx, "h").w("</option>");
    }
    body_5.__dustBody = !0;
    return body_0;
})(dust);